<?xml version="1.0"?>
<doc>
    <assembly>
        <name>itext.io</name>
    </assembly>
    <members>
        <member name="T:iText.IO.Codec.BitFile">
            <summary>Came from GIFEncoder initially.</summary>
            <remarks>
            Came from GIFEncoder initially.
            Modified - to allow for output compressed data without the block counts
            which breakup the compressed data stream for GIF.
            </remarks>
        </member>
        <member name="F:iText.IO.Codec.BitFile.blocks">
            <summary>note this also indicates gif format BITFile.</summary>
        </member>
        <member name="M:iText.IO.Codec.BitFile.#ctor(System.IO.Stream,System.Boolean)">
            <param name="output">destination for output data</param>
            <param name="blocks">GIF LZW requires block counts for output data</param>
        </member>
        <member name="M:iText.IO.Codec.BitFile.Flush">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.BitFile.WriteBits(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Codec.CCITTG4Encoder">
            <summary>Encodes data in the CCITT G4 FAX format.</summary>
        </member>
        <member name="M:iText.IO.Codec.CCITTG4Encoder.#ctor(System.Int32)">
            <summary>Creates a new encoder.</summary>
            <param name="width">the line width</param>
        </member>
        <member name="M:iText.IO.Codec.CCITTG4Encoder.Fax4Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>Encodes a number of lines.</summary>
            <param name="data">the data to be encoded</param>
            <param name="offset">the offset into the data</param>
            <param name="size">the size of the data to be encoded</param>
        </member>
        <member name="M:iText.IO.Codec.CCITTG4Encoder.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>Encodes a full image.</summary>
            <param name="data">the data to encode</param>
            <param name="width">the image width</param>
            <param name="height">the image height</param>
            <returns>the encoded image</returns>
        </member>
        <member name="M:iText.IO.Codec.CCITTG4Encoder.Fax4Encode(System.Byte[],System.Int32)">
            <summary>Encodes a number of lines.</summary>
            <param name="data">the data to be encoded</param>
            <param name="height">the number of lines to encode</param>
        </member>
        <member name="M:iText.IO.Codec.CCITTG4Encoder.Close">
            <summary>Closes the encoder and returns the encoded data.</summary>
            <returns>the encoded data</returns>
        </member>
        <member name="T:iText.IO.Codec.Jbig2SegmentReader">
            <summary>
            Class to read a JBIG2 file at a basic level: understand all the segments,
            understand what segments belong to which pages, how many pages there are,
            what the width and height of each page is, and global segments if there
            are any.
            </summary>
            <remarks>
            Class to read a JBIG2 file at a basic level: understand all the segments,
            understand what segments belong to which pages, how many pages there are,
            what the width and height of each page is, and global segments if there
            are any.  Or: the minimum required to be able to take a normal sequential
            or random-access organized file, and be able to embed JBIG2 pages as images
            in a PDF.
            TODO: the indeterminate-segment-size value of dataLength, else?
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.#ctor(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.Read">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.ReadSegment(iText.IO.Codec.Jbig2SegmentReader.Jbig2Segment)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.ReadHeader">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.ReadFileHeader">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Codec.Jbig2SegmentReader.Jbig2Segment">
            <summary>Inner class that holds information about a JBIG2 segment.</summary>
        </member>
        <member name="T:iText.IO.Codec.Jbig2SegmentReader.Jbig2Page">
            <summary>Inner class that holds information about a JBIG2 page.</summary>
        </member>
        <member name="M:iText.IO.Codec.Jbig2SegmentReader.Jbig2Page.GetData(System.Boolean)">
            <summary>
            return as a single byte array the header-data for each segment in segment number
            order, EMBEDDED organization, but i am putting the needed segments in SEQUENTIAL organization.
            </summary>
            <remarks>
            return as a single byte array the header-data for each segment in segment number
            order, EMBEDDED organization, but i am putting the needed segments in SEQUENTIAL organization.
            if for_embedding, skip the segment types that are known to be not for acrobat.
            </remarks>
            <param name="for_embedding"/>
            <exception cref="T:System.IO.IOException"/>
            <returns>a byte array</returns>
        </member>
        <member name="T:iText.IO.Codec.LZWCompressor">
            <summary>
            Modified from original LZWCompressor to change interface to passing a
            buffer of data to be compressed.
            </summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.codeSize_">
            <summary>base underlying code size of data being compressed 8 for TIFF, 1 to 8 for GIF</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.clearCode_">
            <summary>reserved clear code based on code size</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.endOfInfo_">
            <summary>reserved end of data code based on code size</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.numBits_">
            <summary>current number bits output for each code</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.limit_">
            <summary>limit at which current number of bits code size has to be increased</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.prefix_">
            <summary>the prefix code which represents the predecessor string to current input point</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.bf_">
            <summary>output destination for bit codes</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.lzss_">
            <summary>general purpose LZW string table</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWCompressor.tiffFudge_">
            <summary>modify the limits of the code values in LZW encoding due to TIFF bug / feature</summary>
        </member>
        <member name="M:iText.IO.Codec.LZWCompressor.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <param name="outputStream">destination for compressed data</param>
            <param name="codeSize">the initial code size for the LZW compressor</param>
            <param name="TIFF">flag indicating that TIFF lzw fudge needs to be applied</param>
            <exception cref="T:System.IO.IOException">if underlying output stream error</exception>
        </member>
        <member name="M:iText.IO.Codec.LZWCompressor.Compress(System.Byte[],System.Int32,System.Int32)">
            <param name="buf">data to be compressed to output stream</param>
            <exception cref="T:System.IO.IOException">if underlying output stream error</exception>
        </member>
        <member name="M:iText.IO.Codec.LZWCompressor.Flush">
            <summary>
            Indicate to compressor that no more data to go so write out
            any remaining buffered data.
            </summary>
            <exception cref="T:System.IO.IOException">if underlying output stream error</exception>
        </member>
        <member name="T:iText.IO.Codec.LZWStringTable">
            <summary>General purpose LZW String Table.</summary>
            <remarks>
            General purpose LZW String Table.
            Extracted from GIFEncoder by Adam Doppelt
            Comments added by Robin Luiten
            <code>expandCode</code> added by Robin Luiten
            The strLen_ table to give quick access to the lenght of an expanded
            code for use by the <code>expandCode</code> method added by Robin.
            </remarks>
        </member>
        <member name="F:iText.IO.Codec.LZWStringTable.RES_CODES">
            <summary>codesize + Reserved Codes</summary>
        </member>
        <member name="F:iText.IO.Codec.LZWStringTable.strLen_">
            <summary>
            each entry corresponds to a code and contains the length of data
            that the code expands to when decoded.
            </summary>
        </member>
        <member name="M:iText.IO.Codec.LZWStringTable.#ctor">
            <summary>Constructor allocate memory for string store data</summary>
        </member>
        <member name="M:iText.IO.Codec.LZWStringTable.AddCharString(System.Int16,System.Byte)">
            <param name="index">value of -1 indicates no predecessor [used in initialization]</param>
            <param name="b">
            the byte [character] to add to the string store which follows
            the predecessor string specified the index.
            </param>
            <returns>
            0xFFFF if no space in table left for addition of predecessor
            index and byte b. Else return the code allocated for combination index + b.
            </returns>
        </member>
        <member name="M:iText.IO.Codec.LZWStringTable.FindCharString(System.Int16,System.Byte)">
            <param name="index">index to prefix string</param>
            <param name="b">the character that follws the index prefix</param>
            <returns>
            b if param index is HASH_FREE. Else return the code
            for this prefix and byte successor
            </returns>
        </member>
        <member name="M:iText.IO.Codec.LZWStringTable.ClearTable(System.Int32)">
            <param name="codesize">
            the size of code to be preallocated for the
            string store.
            </param>
        </member>
        <member name="M:iText.IO.Codec.LZWStringTable.ExpandCode(System.Byte[],System.Int32,System.Int16,System.Int32)">
            <summary>
            If expanded data doesn't fit into array only what will fit is written
            to buf and the return value indicates how much of the expanded code has
            been written to the buf.
            </summary>
            <remarks>
            If expanded data doesn't fit into array only what will fit is written
            to buf and the return value indicates how much of the expanded code has
            been written to the buf. The next call to expandCode() should be with
            the same code and have the skip parameter set the negated value of the
            previous return. Successive negative return values should be negated and
            added together for next skip parameter value with same code.
            </remarks>
            <param name="buf">buffer to place expanded data into</param>
            <param name="offset">offset to place expanded data</param>
            <param name="code">
            the code to expand to the byte array it represents.
            PRECONDITION This code must already be in the LZSS
            </param>
            <param name="skipHead">
            is the number of bytes at the start of the expanded code to
            be skipped before data is written to buf. It is possible that skipHead is
            equal to codeLen.
            </param>
            <returns>
            the length of data expanded into buf. If the expanded code is longer
            than space left in buf then the value returned is a negative number which when
            negated is equal to the number of bytes that were used of the code being expanded.
            This negative value also indicates the buffer is full.
            </returns>
        </member>
        <member name="T:iText.IO.Codec.PngWriter">
            <summary>Writes a PNG image.</summary>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WriteHeader(System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WriteEnd">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WriteData(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WritePalette(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WriteIccProfile(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.OutputInt(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.OutputInt(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.PngWriter.WriteChunk(System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Codec.TIFFConstants">
            <summary>A list of constants used in class TIFFImage.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SUBFILETYPE">
            <summary>subfile data descriptor</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.FILETYPE_REDUCEDIMAGE">
            <summary>reduced resolution version</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.FILETYPE_PAGE">
            <summary>one page of many</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.FILETYPE_MASK">
            <summary>transparency mask</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_OSUBFILETYPE">
            <summary>+kind of data in subfile</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.OFILETYPE_IMAGE">
            <summary>full resolution image data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.OFILETYPE_REDUCEDIMAGE">
            <summary>reduced size image data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.OFILETYPE_PAGE">
            <summary>one page of many</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IMAGEWIDTH">
            <summary>image width in pixels</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IMAGELENGTH">
            <summary>image height in pixels</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_BITSPERSAMPLE">
            <summary>bits per channel (sample)</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_COMPRESSION">
            <summary>data compression technique</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_NONE">
            <summary>dump mode</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_CCITTRLE">
            <summary>CCITT modified Huffman RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_CCITTFAX3">
            <summary>CCITT Group 3 fax encoding</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_CCITTFAX4">
            <summary>CCITT Group 4 fax encoding</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.IO.Codec.TIFFConstants.COMPRESSION_LZW" -->
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_OJPEG">
            <summary>!6.0 JPEG</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_JPEG">
            <summary>%JPEG DCT compression</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_NEXT">
            <summary>NeXT 2-bit RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_CCITTRLEW">
            <summary>#1 w/ word alignment</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_PACKBITS">
            <summary>Macintosh RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_THUNDERSCAN">
            <summary>ThunderScan RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_IT8CTPAD">
            <summary>IT8 CT w/padding</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_IT8LW">
            <summary>IT8 Linework RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_IT8MP">
            <summary>IT8 Monochrome picture</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_IT8BL">
            <summary>IT8 Binary line art</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_PIXARFILM">
            <summary>Pixar companded 10bit LZW</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_PIXARLOG">
            <summary>Pixar companded 11bit ZIP</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_DEFLATE">
            <summary>Deflate compression</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_ADOBE_DEFLATE">
            <summary>Deflate compression, as recognized by Adobe</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_DCS">
            <summary>Kodak DCS encoding</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_JBIG">
            <summary>ISO JBIG</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_SGILOG">
            <summary>SGI Log Luminance RLE</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COMPRESSION_SGILOG24">
            <summary>SGI Log 24-bit packed</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PHOTOMETRIC">
            <summary>photometric interpretation</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_MINISWHITE">
            <summary>min value is white</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_MINISBLACK">
            <summary>min value is black</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_RGB">
            <summary>RGB color model</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_PALETTE">
            <summary>color map indexed</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_MASK">
            <summary>$holdout mask</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_SEPARATED">
            <summary>!color separations</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_YCBCR">
            <summary>!CCIR 601</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_CIELAB">
            <summary>!1976 CIE L*a*b</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_LOGL">
            <summary>CIE Log2(L)</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PHOTOMETRIC_LOGLUV">
            <summary>CIE Log2(L) (u',v')</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_THRESHHOLDING">
            <summary>+thresholding used on data</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.IO.Codec.TIFFConstants.THRESHHOLD_BILEVEL" -->
        <member name="F:iText.IO.Codec.TIFFConstants.THRESHHOLD_HALFTONE">
            <summary>or dithered scan</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.THRESHHOLD_ERRORDIFFUSE">
            <summary>usually floyd-steinberg</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_CELLWIDTH">
            <summary>+dithering matrix width</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_CELLLENGTH">
            <summary>+dithering matrix height</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FILLORDER">
            <summary>data order within a byte</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.FILLORDER_MSB2LSB">
            <summary>most significant -&gt; least</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.FILLORDER_LSB2MSB">
            <summary>least significant -&gt; most</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_DOCUMENTNAME">
            <summary>name of doc.</summary>
            <remarks>name of doc. image is from</remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IMAGEDESCRIPTION">
            <summary>info about image</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_MAKE">
            <summary>scanner manufacturer name</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_MODEL">
            <summary>scanner model name/number</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_STRIPOFFSETS">
            <summary>offsets to data strips</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_ORIENTATION">
            <summary>+image orientation</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_TOPLEFT">
            <summary>row 0 top, col 0 lhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_TOPRIGHT">
            <summary>row 0 top, col 0 rhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_BOTRIGHT">
            <summary>row 0 bottom, col 0 rhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_BOTLEFT">
            <summary>row 0 bottom, col 0 lhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_LEFTTOP">
            <summary>row 0 lhs, col 0 top</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_RIGHTTOP">
            <summary>row 0 rhs, col 0 top</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_RIGHTBOT">
            <summary>row 0 rhs, col 0 bottom</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.ORIENTATION_LEFTBOT">
            <summary>row 0 lhs, col 0 bottom</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SAMPLESPERPIXEL">
            <summary>samples per pixel</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_ROWSPERSTRIP">
            <summary>rows per strip of data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_STRIPBYTECOUNTS">
            <summary>bytes counts for strips</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_MINSAMPLEVALUE">
            <summary>+minimum sample value</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_MAXSAMPLEVALUE">
            <summary>+maximum sample value</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_XRESOLUTION">
            <summary>pixels/resolution in x</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_YRESOLUTION">
            <summary>pixels/resolution in y</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PLANARCONFIG">
            <summary>storage organization</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PLANARCONFIG_CONTIG">
            <summary>single image plane</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PLANARCONFIG_SEPARATE">
            <summary>separate planes of data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PAGENAME">
            <summary>page name image is from</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_XPOSITION">
            <summary>x page offset of image lhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_YPOSITION">
            <summary>y page offset of image lhs</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FREEOFFSETS">
            <summary>+byte offset to free block</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FREEBYTECOUNTS">
            <summary>+sizes of free blocks</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_GRAYRESPONSEUNIT">
            <summary>$gray scale curve accuracy</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GRAYRESPONSEUNIT_10S">
            <summary>tenths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GRAYRESPONSEUNIT_100S">
            <summary>hundredths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GRAYRESPONSEUNIT_1000S">
            <summary>thousandths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GRAYRESPONSEUNIT_10000S">
            <summary>ten-thousandths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GRAYRESPONSEUNIT_100000S">
            <summary>hundred-thousandths</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_GRAYRESPONSECURVE">
            <summary>$gray scale response curve</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_GROUP3OPTIONS">
            <summary>32 flag bits</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GROUP3OPT_2DENCODING">
            <summary>2-dimensional coding</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GROUP3OPT_UNCOMPRESSED">
            <summary>data not compressed</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GROUP3OPT_FILLBITS">
            <summary>fill to byte boundary</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_GROUP4OPTIONS">
            <summary>32 flag bits</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.GROUP4OPT_UNCOMPRESSED">
            <summary>data not compressed</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_RESOLUTIONUNIT">
            <summary>units of resolutions</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.RESUNIT_NONE">
            <summary>no meaningful units</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.RESUNIT_INCH">
            <summary>english</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.RESUNIT_CENTIMETER">
            <summary>metric</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PAGENUMBER">
            <summary>page numbers of multi-page</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_COLORRESPONSEUNIT">
            <summary>$color curve accuracy</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COLORRESPONSEUNIT_10S">
            <summary>tenths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COLORRESPONSEUNIT_100S">
            <summary>hundredths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COLORRESPONSEUNIT_1000S">
            <summary>thousandths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COLORRESPONSEUNIT_10000S">
            <summary>ten-thousandths of a unit</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.COLORRESPONSEUNIT_100000S">
            <summary>hundred-thousandths</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TRANSFERFUNCTION">
            <summary>!colorimetry info</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.IO.Codec.TIFFConstants.TIFFTAG_SOFTWARE" -->
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_DATETIME">
            <summary>creation date and time</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_ARTIST">
            <summary>creator of image</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_HOSTCOMPUTER">
            <summary>machine where created</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PREDICTOR">
            <summary>prediction scheme w/ LZW</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PREDICTOR_NONE">
            <summary>no predictor</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.PREDICTOR_HORIZONTAL_DIFFERENCING">
            <summary>horizontal differencing</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_WHITEPOINT">
            <summary>image white point</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PRIMARYCHROMATICITIES">
            <summary>!primary chromaticities</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_COLORMAP">
            <summary>RGB map for pallette image</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_HALFTONEHINTS">
            <summary>!highlight+shadow info</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TILEWIDTH">
            <summary>!rows/data tile</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TILELENGTH">
            <summary>!cols/data tile</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TILEOFFSETS">
            <summary>!offsets to data tiles</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TILEBYTECOUNTS">
            <summary>!byte counts for tiles</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_BADFAXLINES">
            <summary>lines w/ wrong pixel count</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_CLEANFAXDATA">
            <summary>regenerated line info</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.CLEANFAXDATA_CLEAN">
            <summary>no errors detected</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.CLEANFAXDATA_REGENERATED">
            <summary>receiver regenerated lines</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.CLEANFAXDATA_UNCLEAN">
            <summary>uncorrected errors exist</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_CONSECUTIVEBADFAXLINES">
            <summary>max consecutive bad lines</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SUBIFD">
            <summary>subimage descriptors</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_INKSET">
            <summary>!inks in separated image</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.INKSET_CMYK">
            <summary>!cyan-magenta-yellow-black</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_INKNAMES">
            <summary>!ascii names of inks</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_NUMBEROFINKS">
            <summary>!number of inks</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_DOTRANGE">
            <summary>!0% and 100% dot codes</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TARGETPRINTER">
            <summary>!separation target</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_EXTRASAMPLES">
            <summary>!info about extra samples</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.EXTRASAMPLE_UNSPECIFIED">
            <summary>!unspecified data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.EXTRASAMPLE_ASSOCALPHA">
            <summary>!associated alpha data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.EXTRASAMPLE_UNASSALPHA">
            <summary>!unassociated alpha data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SAMPLEFORMAT">
            <summary>!data sample format</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_UINT">
            <summary>!unsigned integer data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_INT">
            <summary>!signed integer data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_IEEEFP">
            <summary>!IEEE floating point data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_VOID">
            <summary>!untyped data</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_COMPLEXINT">
            <summary>!complex signed int</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.SAMPLEFORMAT_COMPLEXIEEEFP">
            <summary>!complex ieee floating</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SMINSAMPLEVALUE">
            <summary>!variable MinSampleValue</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_SMAXSAMPLEVALUE">
            <summary>!variable MaxSampleValue</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGTABLES">
            <summary>%JPEG table stream</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGPROC">
            <summary>!JPEG processing algorithm</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.JPEGPROC_BASELINE">
            <summary>!baseline sequential</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.JPEGPROC_LOSSLESS">
            <summary>!Huffman coded lossless</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGIFOFFSET">
            <summary>!pointer to SOI marker</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGIFBYTECOUNT">
            <summary>!JFIF stream length</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGRESTARTINTERVAL">
            <summary>!restart interval length</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGLOSSLESSPREDICTORS">
            <summary>!lossless proc predictor</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGPOINTTRANSFORM">
            <summary>!lossless point transform</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGQTABLES">
            <summary>!Q matrice offsets</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGDCTABLES">
            <summary>!DCT table offsets</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JPEGACTABLES">
            <summary>!AC coefficient offsets</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_YCBCRCOEFFICIENTS">
            <summary>!RGB -&gt; YCbCr transform</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_YCBCRSUBSAMPLING">
            <summary>!YCbCr subsampling factors</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_YCBCRPOSITIONING">
            <summary>!subsample positioning</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.YCBCRPOSITION_CENTERED">
            <summary>!as in PostScript Level 2</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.YCBCRPOSITION_COSITED">
            <summary>!as in CCIR 601-1</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_REFERENCEBLACKWHITE">
            <summary>!colorimetry info</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_REFPTS">
            <summary>image reference points</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_REGIONTACKPOINT">
            <summary>region-xform tack point</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_REGIONWARPCORNERS">
            <summary>warp quadrilateral</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_REGIONAFFINE">
            <summary>affine transformation mat</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_MATTEING">
            <summary>$use ExtraSamples</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_DATATYPE">
            <summary>$use SampleFormat</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IMAGEDEPTH">
            <summary>z depth of image</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_TILEDEPTH">
            <summary>z depth/data tile</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_IMAGEFULLWIDTH">
            <summary>full image size in x</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_IMAGEFULLLENGTH">
            <summary>full image size in y</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_TEXTUREFORMAT">
            <summary>texture map format</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_WRAPMODES" -->
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_FOVCOT">
            <summary>cotan(fov) for env.</summary>
            <remarks>cotan(fov) for env. maps</remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN">
            <summary>W2S</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA">
            <summary>W2C</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_WRITERSERIALNUMBER">
            <summary>
            device serial number
            tag 33405 is a private tag registered to Eastman Kodak
            </summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_COPYRIGHT">
            <summary>tag 33432 is listed in the 6.0 spec w/ unknown ownership</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_RICHTIFFIPTC">
            <summary>IPTC TAG from RichTIFF specifications</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8SITE">
            <summary>site name</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8COLORSEQUENCE">
            <summary>color seq.</summary>
            <remarks>color seq. [RGB,CMYK,etc]</remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8HEADER">
            <summary>DDES Header</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8RASTERPADDING">
            <summary>raster scanline padding</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8BITSPERRUNLENGTH">
            <summary># of bits in short run</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH">
            <summary># of bits in long run</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8COLORTABLE">
            <summary>LW colortable</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8IMAGECOLORINDICATOR">
            <summary>BP/BL image color switch</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8BKGCOLORINDICATOR">
            <summary>BP/BL bg color switch</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8IMAGECOLORVALUE">
            <summary>BP/BL image color value</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8BKGCOLORVALUE">
            <summary>BP/BL bg color value</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8PIXELINTENSITYRANGE">
            <summary>MP pixel intensity value</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8TRANSPARENCYINDICATOR">
            <summary>HC transparency switch</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_IT8COLORCHARACTERIZATION">
            <summary>color character.</summary>
            <remarks>color character. table</remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FRAMECOUNT">
            <summary>Sequence Frame Count</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_ICCPROFILE">
            <summary>
            ICC profile data
            tag 34750 is a private tag registered to Adobe?
            </summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_PHOTOSHOP">
            <summary>tag 34377 is private tag registered to Adobe for PhotoShop</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_JBIGOPTIONS">
            <summary>
            JBIG options
            tag 34750 is a private tag registered to Pixel Magic
            </summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FAXRECVPARAMS">
            <summary>encoded Class 2 ses.</summary>
            <remarks>encoded Class 2 ses. parms</remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FAXSUBADDRESS">
            <summary>received SubAddr string</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FAXRECVTIME">
            <summary>receive time (secs)</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_STONITS">
            <summary>Sample value to Nits</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_FEDEX_EDR">
            <summary>
            unknown use
            tag 34929 is a private tag registered to FedEx
            </summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFConstants.TIFFTAG_DCSHUESHIFTVALUES">
            <summary>
            hue shift correction data
            tag 65535 is an undefined tag used by Eastman Kodak
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Codec.TIFFDirectory" -->
        <member name="F:iText.IO.Codec.TIFFDirectory.isBigEndian">
            <summary>A boolean storing the endianness of the stream.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFDirectory.numEntries">
            <summary>The number of entries in the IFD.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFDirectory.fields">
            <summary>An array of TIFFFields.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFDirectory.fieldIndex">
            <summary>A Hashtable indexing the fields by tag number.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFDirectory.IFDOffset">
            <summary>The offset of this IFD.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFDirectory.nextIFDOffset">
            <summary>The offset of the next IFD.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.#ctor">
            <summary>The default constructor.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int32)">
            <summary>Constructs a TIFFDirectory from a SeekableStream.</summary>
            <remarks>
            Constructs a TIFFDirectory from a SeekableStream.
            The directory parameter specifies which directory to read from
            the linked list present in the stream; directory 0 is normally
            read but it is possible to store multiple images in a single
            TIFF file by maintaining multiple directories.
            </remarks>
            <param name="stream">a SeekableStream to read from.</param>
            <param name="directory">the index of the directory to read.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int64,System.Int32)">
            <summary>Constructs a TIFFDirectory by reading a SeekableStream.</summary>
            <remarks>
            Constructs a TIFFDirectory by reading a SeekableStream.
            The ifd_offset parameter specifies the stream offset from which
            to begin reading; this mechanism is sometimes used to store
            private IFDs within a TIFF file that are not part of the normal
            sequence of IFDs.
            </remarks>
            <param name="stream">a SeekableStream to read from.</param>
            <param name="ifd_offset">the long byte offset of the directory.</param>
            <param name="directory">
            the index of the directory to read beyond the
            one at the current stream offset; zero indicates the IFD
            at the current offset.
            </param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.Initialize(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetNumEntries">
            <summary>Returns the number of directory entries.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetField(System.Int32)">
            <summary>
            Returns the value of a given tag as a TIFFField,
            or null if the tag is not present.
            </summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.IsTagPresent(System.Int32)">
            <summary>Returns true if a tag appears in the directory.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetTags">
            <summary>
            Returns an ordered array of ints indicating the tag
            values.
            </summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFields">
            <summary>
            Returns an array of TIFFFields containing all the fields
            in this directory.
            </summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsByte(System.Int32,System.Int32)">
            <summary>
            Returns the value of a particular index of a given tag as a
            byte.
            </summary>
            <remarks>
            Returns the value of a particular index of a given tag as a
            byte.  The caller is responsible for ensuring that the tag is
            present and has type TIFFField.TIFF_SBYTE, TIFF_BYTE, or
            TIFF_UNDEFINED.
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsByte(System.Int32)">
            <summary>
            Returns the value of index 0 of a given tag as a
            byte.
            </summary>
            <remarks>
            Returns the value of index 0 of a given tag as a
            byte.  The caller is responsible for ensuring that the tag is
            present and has  type TIFFField.TIFF_SBYTE, TIFF_BYTE, or
            TIFF_UNDEFINED.
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsLong(System.Int32,System.Int32)">
            <summary>
            Returns the value of a particular index of a given tag as a
            long.
            </summary>
            <remarks>
            Returns the value of a particular index of a given tag as a
            long.  The caller is responsible for ensuring that the tag is
            present and has type TIFF_BYTE, TIFF_SBYTE, TIFF_UNDEFINED,
            TIFF_SHORT, TIFF_SSHORT, TIFF_SLONG or TIFF_LONG.
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsLong(System.Int32)">
            <summary>
            Returns the value of index 0 of a given tag as a
            long.
            </summary>
            <remarks>
            Returns the value of index 0 of a given tag as a
            long.  The caller is responsible for ensuring that the tag is
            present and has type TIFF_BYTE, TIFF_SBYTE, TIFF_UNDEFINED,
            TIFF_SHORT, TIFF_SSHORT, TIFF_SLONG or TIFF_LONG.
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsFloat(System.Int32,System.Int32)">
            <summary>
            Returns the value of a particular index of a given tag as a
            float.
            </summary>
            <remarks>
            Returns the value of a particular index of a given tag as a
            float.  The caller is responsible for ensuring that the tag is
            present and has numeric type (all but TIFF_UNDEFINED and
            TIFF_ASCII).
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsFloat(System.Int32)">
            <summary>Returns the value of index 0 of a given tag as a float.</summary>
            <remarks>
            Returns the value of index 0 of a given tag as a float.  The
            caller is responsible for ensuring that the tag is present and
            has numeric type (all but TIFF_UNDEFINED and TIFF_ASCII).
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsDouble(System.Int32,System.Int32)">
            <summary>
            Returns the value of a particular index of a given tag as a
            double.
            </summary>
            <remarks>
            Returns the value of a particular index of a given tag as a
            double.  The caller is responsible for ensuring that the tag is
            present and has numeric type (all but TIFF_UNDEFINED and
            TIFF_ASCII).
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetFieldAsDouble(System.Int32)">
            <summary>Returns the value of index 0 of a given tag as a double.</summary>
            <remarks>
            Returns the value of index 0 of a given tag as a double.  The
            caller is responsible for ensuring that the tag is present and
            has numeric type (all but TIFF_UNDEFINED and TIFF_ASCII).
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadShort(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadUnsignedShort(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadInt(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadUnsignedInt(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadLong(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadFloat(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadDouble(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadUnsignedShort(iText.IO.Source.RandomAccessFileOrArray,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.ReadUnsignedInt(iText.IO.Source.RandomAccessFileOrArray,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetNumDirectories(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>
            Returns the number of image directories (subimages) stored in a
            given TIFF file, represented by a <code>SeekableStream</code>.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.IsBigEndian">
            <summary>
            Returns a boolean indicating whether the byte order used in the
            the TIFF file is big-endian (i.e.
            </summary>
            <remarks>
            Returns a boolean indicating whether the byte order used in the
            the TIFF file is big-endian (i.e. whether the byte order is from
            the most significant to the least significant)
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetIFDOffset">
            <summary>
            Returns the offset of the IFD corresponding to this
            <code>TIFFDirectory</code>.
            </summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFDirectory.GetNextIFDOffset">
            <summary>
            Returns the offset of the next IFD after the IFD corresponding to this
            <code>TIFFDirectory</code>.
            </summary>
        </member>
        <member name="T:iText.IO.Codec.TIFFFaxDecoder">
            <summary>Class that can decode TIFF files.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFFaxDecoder.#ctor(System.Int32,System.Int32,System.Int32)">
            <param name="fillOrder">The fill order of the compressed data bytes.</param>
            <param name="w"/>
            <param name="h"/>
        </member>
        <member name="M:iText.IO.Codec.TIFFFaxDecoder.ReverseBits(System.Byte[])">
            <summary>Reverses the bits in the array</summary>
            <param name="b">the bits to reverse</param>
        </member>
        <member name="T:iText.IO.Codec.TIFFFaxDecompressor">
            <summary>Class that can decompress TIFF files.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFFaxDecompressor.fillOrder">
            <summary>The logical order of bits within a byte.</summary>
            <remarks>
            The logical order of bits within a byte.
            <pre>
            1 = MSB-to-LSB
            2 = LSB-to-MSB (flipped)
            </pre>
            </remarks>
        </member>
        <member name="F:iText.IO.Codec.TIFFFaxDecompressor.uncompressedMode">
            <summary>Uncompressed mode flag: 1 if uncompressed, 0 if not.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFFaxDecompressor.fillBits">
            <summary>
            EOL padding flag: 1 if fill bits have been added before an EOL such
            that the EOL ends on a byte boundary, 0 otherwise.
            </summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFFaxDecompressor.oneD">
            <summary>Coding dimensionality: 1 for 2-dimensional, 0 for 1-dimensional.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFFaxDecompressor.SetOptions(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Invokes the superclass method and then sets instance variables on
            the basis of the metadata set on this decompressor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Codec.TIFFField" -->
        <member name="F:iText.IO.Codec.TIFFField.TIFF_BYTE">
            <summary>Flag for 8 bit unsigned integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_ASCII">
            <summary>Flag for null-terminated ASCII strings.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_SHORT">
            <summary>Flag for 16 bit unsigned integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_LONG">
            <summary>Flag for 32 bit unsigned integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_RATIONAL">
            <summary>Flag for pairs of 32 bit unsigned integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_SBYTE">
            <summary>Flag for 8 bit signed integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_UNDEFINED">
            <summary>Flag for 8 bit uninterpreted bytes.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_SSHORT">
            <summary>Flag for 16 bit signed integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_SLONG">
            <summary>Flag for 32 bit signed integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_SRATIONAL">
            <summary>Flag for pairs of 32 bit signed integers.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_FLOAT">
            <summary>Flag for 32 bit IEEE floats.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.TIFF_DOUBLE">
            <summary>Flag for 64 bit IEEE doubles.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.tag">
            <summary>The tag number.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.type">
            <summary>The tag type.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.count">
            <summary>The number of data items present in the field.</summary>
        </member>
        <member name="F:iText.IO.Codec.TIFFField.data">
            <summary>The field data.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFField.#ctor">
            <summary>The default constructor.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.#ctor(System.Int32,System.Int32,System.Int32,System.Object)" -->
        <member name="M:iText.IO.Codec.TIFFField.GetTag">
            <summary>Returns the tag number, between 0 and 65535.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFField.GetFieldType">
            <summary>Returns the type of the data stored in the IFD.</summary>
            <remarks>
            Returns the type of the data stored in the IFD.
            For a TIFF6.0 file, the value will equal one of the
            TIFF_ constants defined in this class.  For future
            revisions of TIFF, higher values are possible.
            </remarks>
        </member>
        <member name="M:iText.IO.Codec.TIFFField.GetCount">
            <summary>Returns the number of elements in the IFD.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsBytes" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsChars" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsShorts" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsInts" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsLongs" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsFloats" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsDoubles" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsSRationals" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsRationals" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsInt(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsLong(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsFloat(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsDouble(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsString(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsSRational(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.GetAsRational(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Codec.TIFFField.CompareTo(iText.IO.Codec.TIFFField)" -->
        <member name="T:iText.IO.Codec.TIFFLZWDecoder">
            <summary>A class for performing LZW decoding.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.Decode(System.Byte[],System.Byte[],System.Int32)">
            <summary>Method to decode LZW compressed data.</summary>
            <param name="data">The compressed data.</param>
            <param name="uncompData">Array to return the uncompressed data in.</param>
            <param name="h">The number of rows the compressed data contains.</param>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.InitializeStringTable">
            <summary>Initialize the string table.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.WriteString(System.Byte[])">
            <summary>Write out the string just uncompressed.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.AddStringToTable(System.Byte[],System.Byte)">
            <summary>Add a new string to the string table.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.AddStringToTable(System.Byte[])">
            <summary>Add a new string to the string table.</summary>
        </member>
        <member name="M:iText.IO.Codec.TIFFLZWDecoder.ComposeString(System.Byte[],System.Byte)">
            <summary>Append <code>newString</code> to the end of <code>oldString</code>.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter">
            <summary>Exports images as TIFF.</summary>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.WriteFile(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.WriteShort(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.WriteLong(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.CompressLZW(System.IO.Stream,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldBase">
            <summary>Inner class class containing information about a field.</summary>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.FieldBase.WriteField(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Codec.TiffWriter.FieldBase.WriteValue(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldShort">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldLong">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldRational">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldByte">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldUndefined">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldImage">
            <summary>Inner class containing info about a field.</summary>
        </member>
        <member name="T:iText.IO.Codec.TiffWriter.FieldAscii">
            <summary>Inner class containing info about an ASCII field.</summary>
        </member>
        <member name="T:iText.IO.Colors.IccProfile">
            <summary>Class used to represented the International Color Consortium profile</summary>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetInstance(System.Byte[],System.Int32)">
            <summary>Construct an icc profile from the passed byte[], using the passed number of components.</summary>
            <param name="data">byte[] containing the raw icc profile data</param>
            <param name="numComponents">number of components the profile contains</param>
            <returns>IccProfile constructed from the data</returns>
            <exception cref="T:iText.IO.IOException">when the specified number of components and the number of components in the created profile do not match.
                </exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetInstance(System.Byte[])">
            <summary>Construct an icc profile from the passed byte[], using the passed number of components.</summary>
            <param name="data">byte[] containing the raw icc profile data</param>
            <returns>IccProfile constructed from the data</returns>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetInstance(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>Construct an icc profile from the passed random-access file or array.</summary>
            <param name="file">random-access file or array containing the profile</param>
            <returns>IccProfile constructed from the data</returns>
            <exception cref="T:iText.IO.IOException">if the source does not contain a valid icc profile</exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetInstance(System.IO.Stream)">
            <summary>Construct an icc profile from the passed InputStream.</summary>
            <param name="stream">inputstream containing the profile</param>
            <returns>IccProfile constructed from the data</returns>
            <exception cref="T:iText.IO.IOException">if the source does not contain a valid icc profile</exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetInstance(System.String)">
            <summary>Construct an icc profile from the file found at the passed path</summary>
            <param name="filename">path to the file contaning the profile</param>
            <returns>IccProfile constructed from the data</returns>
            <exception cref="T:iText.IO.IOException">if the source does not contain a valid icc profile</exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetIccColorSpaceName(System.Byte[])">
            <summary>Get the Color space name of the icc profile found in the data.</summary>
            <param name="data">byte[] containing the icc profile</param>
            <returns>String containing the color space of the profile</returns>
            <exception cref="T:iText.IO.IOException">if the source does not contain a valid icc profile</exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetIccDeviceClass(System.Byte[])">
            <summary>Get the device class of the icc profile found in the data.</summary>
            <param name="data">byte[] containing the icc profile</param>
            <returns>String containing the device class of the profile</returns>
            <exception cref="T:iText.IO.IOException">if the source does not contain a valid icc profile</exception>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetIccNumberOfComponents(System.Byte[])">
            <summary>Get the number of color components of the icc profile found in the data.</summary>
            <param name="data">byte[] containing the icc profile</param>
            <returns>Number of color components</returns>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetData">
            <summary>Get the icc color profile data.</summary>
            <returns>byte[] containing the data</returns>
        </member>
        <member name="M:iText.IO.Colors.IccProfile.GetNumComponents">
            <summary>Get the number of color components in the profile.</summary>
            <returns>number of components</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFont.GetEntireIndexRange(System.Int32)">
            <summary>a utility that creates a range item for an entire index</summary>
            <param name="indexOffset">where the index is</param>
            <returns>a range item representing the entire index</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFont.GetCID(System.String)">
            <summary>get a single CID font.</summary>
            <remarks>
            get a single CID font. The PDF architecture (1.4)
            supports 16-bit strings only with CID CFF fonts, not
            in Type-1 CFF fonts, so we convert the font to CID if
            it is in the Type-1 format.
            Two other tasks that we need to do are to select
            only a single font from the CFF package (this again is
            a PDF restriction) and to subset the CharStrings glyph
            description.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.CFFFont.buf">
            <summary>A random Access File or an array</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.Item">
            <summary>List items for the linked list that builds the new CID font.</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFont.Item.Increment(System.Int32[])">
            <summary>remember the current offset and increment by item's size in bytes.</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFont.Item.Emit(System.Byte[])">
            <summary>Emit the byte stream for this item.</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFont.Item.Xref">
            <summary>Fix up cross references to this item (applies only to markers).</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFont.OffsetItem.Set(System.Int32)">
            <summary>set the value of an offset item that was initially unknown.</summary>
            <remarks>
            set the value of an offset item that was initially unknown.
            It will be fixed up latex by a call to xref on some marker.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.CFFFont.RangeItem">
            <summary>A range item.</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.IndexOffsetItem">
            <summary>An index-offset item for the list.</summary>
            <remarks>
            An index-offset item for the list.
            The size denotes the required size in the CFF. A positive
            value means that we need a specific size in bytes (for offset arrays)
            and a negative value means that this is a dict item that uses a
            variable-size representation.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.CFFFont.SubrMarkerItem">
            <summary>
            TODO To change the template for this generated type comment go to
            Window - Preferences - Java - Code Generation - Code and Comments
            </summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.DictOffsetItem">
            <summary>an unknown offset in a dictionary for the list.</summary>
            <remarks>
            an unknown offset in a dictionary for the list.
            We will fix up the offset later; for now, assume it's large.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.CFFFont.UInt24Item">
            <summary>Card24 item.</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.UInt32Item">
            <summary>Card32 item.</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.UInt16Item">
            <summary>A SID or Card16 item.</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.UInt8Item">
            <summary>A Card8 item.</summary>
        </member>
        <member name="T:iText.IO.Font.CFFFont.DictNumberItem">
            <summary>A dictionary number on the list.</summary>
            <remarks>
            A dictionary number on the list.
            This implementation is inefficient: it doesn't use the variable-length
            representation.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.CFFFont.MarkerItem">
            <summary>An offset-marker item for the list.</summary>
            <remarks>
            An offset-marker item for the list.
            It is used to mark an offset and to set the offset list item.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.CFFFontSubset">
            <summary>This Class subsets a CFF Type Font.</summary>
            <remarks>
            This Class subsets a CFF Type Font. The subset is preformed for CID fonts and NON CID fonts.
            The Charstring is subsetted for both types. For CID fonts only the FDArray which are used are embedded.
            The Lsubroutines of the FDArrays used are subsetted as well. The Subroutine subset supports both Type1 and Type2
            formatting although only tested on Type2 Format.
            For Non CID the Lsubroutines are subsetted. On both types the Gsubroutines is subsetted.
            A font which was not of CID type is transformed into CID as a part of the subset process.
            The CID synthetic creation was written by Sivan Toledo (sivan@math.tau.ac.il)
            </remarks>
            <author>Oren Manor (manorore@post.tau.ac.il) and Ygal Blum (blumygal@post.tau.ac.il)</author>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.ENDCHAR_OP">
            <summary>Operator codes for unused  CharStrings and unused local and global Subrs</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.SubrsFunctions">
            <summary>The Strings in this array represent Type1/Type2 operator names</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.SubrsEscapeFuncs">
            <summary>The Strings in this array represent Type1/Type2 escape operator names</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.GlyphsUsed">
            <summary>
            A Map containing the glyphs used in the text after being converted
            to glyph number by the CMap
            </summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.glyphsInList">
            <summary>The GlyphsUsed keys as an list</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.FDArrayUsed">
            <summary>A Set for keeping the FDArrays being used by the font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.hSubrsUsed">
            <summary>A Maps array for keeping the subroutines used in each FontDict</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.lSubrsUsed">
            <summary>The SubroutinesUsed Maps as lists</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.hGSubrsUsed">
            <summary>A Map for keeping the Global subroutines used in the font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.lGSubrsUsed">
            <summary>The Global SubroutinesUsed Maps as lists</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.hSubrsUsedNonCID">
            <summary>A Map for keeping the subroutines used in a non-cid font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.lSubrsUsedNonCID">
            <summary>The SubroutinesUsed Map as list</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.NewLSubrsIndex">
            <summary>An array of the new Indexes for the local Subr.</summary>
            <remarks>An array of the new Indexes for the local Subr. One index for each FontDict</remarks>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.NewSubrsIndexNonCID">
            <summary>The new subroutines index for a non-cid font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.NewGSubrsIndex">
            <summary>The new global subroutines index of the font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.NewCharStringsIndex">
            <summary>The new CharString of the font</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.GBias">
            <summary>The bias for the global subroutines</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.OutputList">
            <summary>The linked list for generating the new font stream</summary>
        </member>
        <member name="F:iText.IO.Font.CFFFontSubset.NumOfHints">
            <summary>Number of arguments to the stem operators in a subroutine calculated recursively</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.#ctor(System.Byte[],System.Collections.Generic.IDictionary{System.Int32,System.Int32[]})">
            <summary>C'tor for CFFFontSubset</summary>
            <param name="cff">- The font file</param>
            <param name="GlyphsUsed">- a Map that contains the glyph used in the subset</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CountCharset(System.Int32,System.Int32)">
            <summary>Calculates the length of the charset according to its format</summary>
            <param name="Offset">The Charset Offset</param>
            <param name="NumofGlyphs">Number of glyphs in the font</param>
            <returns>the length of the Charset</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CountRange(System.Int32,System.Int32)">
            <summary>Function calculates the number of ranges in the Charset</summary>
            <param name="NumofGlyphs">The number of glyphs in the font</param>
            <param name="Type">The format of the Charset</param>
            <returns>The number of ranges in the Charset data structure</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReadFDSelect(System.Int32)">
            <summary>Read the FDSelect of the font and compute the array and its length</summary>
            <param name="Font">The index of the font being processed</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.BuildFDArrayUsed(System.Int32)">
            <summary>Function reads the FDSelect and builds the FDArrayUsed Map According to the glyphs used</summary>
            <param name="Font">the Number of font being processed</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReadFDArray(System.Int32)">
            <summary>Read the FDArray count, offsize and Offset array</summary>
            <param name="Font"/>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.Process(System.String)">
            <summary>
            The Process function extracts one font out of the CFF file and returns a
            subset version of the original.
            </summary>
            <param name="fontName">- The name of the font to be taken out of the CFF</param>
            <returns>The new font stream</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CalcBias(System.Int32,System.Int32)">
            <summary>
            Function calcs bias according to the CharString type and the count
            of the subrs
            </summary>
            <param name="Offset">The offset to the relevant subrs index</param>
            <param name="Font">the font</param>
            <returns>The calculated Bias</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.BuildNewCharString(System.Int32)">
            <summary>Function uses BuildNewIndex to create the new index of the subset charstrings</summary>
            <param name="FontIndex">the font</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Font.CFFFontSubset.BuildNewLGSubrs(System.Int32)" -->
        <member name="M:iText.IO.Font.CFFFontSubset.BuildFDSubrsOffsets(System.Int32,System.Int32)">
            <summary>
            The function finds for the FD array processed the local subr offset and its
            offset array.
            </summary>
            <param name="Font">the font</param>
            <param name="FD">The FDARRAY processed</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Font.CFFFontSubset.BuildSubrUsed(System.Int32,System.Int32,System.Int32,System.Int32[],System.Collections.Generic.IDictionary{System.Int32,System.Int32[]},System.Collections.Generic.IList{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Font.CFFFontSubset.BuildGSubrsUsed(System.Int32)" -->
        <member name="M:iText.IO.Font.CFFFontSubset.ReadASubr(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IDictionary{System.Int32,System.Int32[]},System.Collections.Generic.IList{System.Int32},System.Int32[])">
            <summary>The function reads a subrs (glyph info) between begin and end.</summary>
            <remarks>
            The function reads a subrs (glyph info) between begin and end.
            Adds calls to a Lsubr to the hSubr and lSubrs.
            Adds calls to a Gsubr to the hGSubr and lGSubrs.
            </remarks>
            <param name="begin">the start point of the subr</param>
            <param name="end">the end point of the subr</param>
            <param name="GBias">the bias of the Global Subrs</param>
            <param name="LBias">the bias of the Local Subrs</param>
            <param name="hSubr">the Map for the lSubrs</param>
            <param name="lSubr">the list for the lSubrs</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.HandelStack">
            <summary>
            Function Checks how the current operator effects the run time stack after being run
            An operator may increase or decrease the stack size
            </summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.StackOpp">
            <summary>Function checks the key and return the change to the stack after the operator</summary>
            <returns>The change in the stack. 2-&gt; flush the stack</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.EmptyStack">
            <summary>Empty the Type2 Stack</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.PopStack">
            <summary>Pop one element from the stack</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.PushStack">
            <summary>Add an item to the stack</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReadCommand">
            <summary>The function reads the next command after the file pointer is set</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CalcHints(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>The function reads the subroutine and returns the number of the hint in it.</summary>
            <remarks>
            The function reads the subroutine and returns the number of the hint in it.
            If a call to another subroutine is found the function calls recursively.
            </remarks>
            <param name="begin">the start point of the subr</param>
            <param name="end">the end point of the subr</param>
            <param name="LBias">the bias of the Local Subrs</param>
            <param name="GBias">the bias of the Global Subrs</param>
            <param name="LSubrsOffsets">The Offsets array of the subroutines</param>
            <returns>The number of hints in the subroutine read.</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.BuildNewIndex(System.Int32[],System.Collections.Generic.IDictionary{System.Int32,System.Int32[]},System.Byte)">
            <summary>Function builds the new offset array, object array and assembles the index.</summary>
            <remarks>
            Function builds the new offset array, object array and assembles the index.
            used for creating the glyph and subrs subsetted index
            </remarks>
            <param name="Offsets">the offset array of the original index</param>
            <param name="Used">the Map of the used objects</param>
            <param name="OperatorForUnusedEntries">the operator inserted into the data stream for unused entries</param>
            <returns>the new index subset version</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.AssembleIndex(System.Int32[],System.Byte[])">
            <summary>
            Function creates the new index, inserting the count,offsetsize,offset array
            and object array.
            </summary>
            <param name="NewOffsets">the subsetted offset array</param>
            <param name="NewObjects">the subsetted object array</param>
            <returns>the new index created</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.BuildNewFile(System.Int32)">
            <summary>The function builds the new output stream according to the subset process</summary>
            <param name="Font">the font</param>
            <returns>the subsetted font stream</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CopyHeader">
            <summary>Function Copies the header from the original fileto the output list</summary>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.BuildIndexHeader(System.Int32,System.Int32,System.Int32)">
            <summary>Function Build the header of an index</summary>
            <param name="Count">the count field of the index</param>
            <param name="Offsize">the offsize field of the index</param>
            <param name="First">the first offset of the index</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateKeys(iText.IO.Font.CFFFont.OffsetItem,iText.IO.Font.CFFFont.OffsetItem,iText.IO.Font.CFFFont.OffsetItem,iText.IO.Font.CFFFont.OffsetItem)">
            <summary>Function adds the keys into the TopDict</summary>
            <param name="fdarrayRef">OffsetItem for the FDArray</param>
            <param name="fdselectRef">OffsetItem for the FDSelect</param>
            <param name="charsetRef">OffsetItem for the CharSet</param>
            <param name="charstringsRef">OffsetItem for the CharString</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateNewStringIndex(System.Int32)">
            <summary>
            Function takes the original string item and adds the new strings
            to accommodate the CID rules
            </summary>
            <param name="Font">the font</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateFDSelect(iText.IO.Font.CFFFont.OffsetItem,System.Int32)">
            <summary>Function creates new FDSelect for non-CID fonts.</summary>
            <remarks>
            Function creates new FDSelect for non-CID fonts.
            The FDSelect built uses a single range for all glyphs
            </remarks>
            <param name="fdselectRef">OffsetItem for the FDSelect</param>
            <param name="nglyphs">the number of glyphs in the font</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateCharset(iText.IO.Font.CFFFont.OffsetItem,System.Int32)">
            <summary>Function creates new CharSet for non-CID fonts.</summary>
            <remarks>
            Function creates new CharSet for non-CID fonts.
            The CharSet built uses a single range for all glyphs
            </remarks>
            <param name="charsetRef">OffsetItem for the CharSet</param>
            <param name="nglyphs">the number of glyphs in the font</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateFDArray(iText.IO.Font.CFFFont.OffsetItem,iText.IO.Font.CFFFont.OffsetItem,System.Int32)">
            <summary>Function creates new FDArray for non-CID fonts.</summary>
            <remarks>
            Function creates new FDArray for non-CID fonts.
            The FDArray built has only the "Private" operator that points to the font's
            original private dict
            </remarks>
            <param name="fdarrayRef">OffsetItem for the FDArray</param>
            <param name="privateRef">OffsetItem for the Private Dict</param>
            <param name="Font">the font</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.Reconstruct(System.Int32)">
            <summary>Function reconstructs the FDArray, PrivateDict and LSubr for CID fonts</summary>
            <param name="Font">the font</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReconstructFDArray(System.Int32,iText.IO.Font.CFFFont.OffsetItem[])">
            <summary>Function subsets the FDArray and builds the new one with new offsets</summary>
            <param name="Font">The font</param>
            <param name="fdPrivate">OffsetItem Array (one for each FDArray)</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReconstructPrivateDict(System.Int32,iText.IO.Font.CFFFont.OffsetItem[],iText.IO.Font.CFFFont.IndexBaseItem[],iText.IO.Font.CFFFont.OffsetItem[])">
            <summary>Function Adds the new private dicts (only for the FDs used) to the list</summary>
            <param name="Font">the font</param>
            <param name="fdPrivate">OffsetItem array one element for each private</param>
            <param name="fdPrivateBase">IndexBaseItem array one element for each private</param>
            <param name="fdSubrs">OffsetItem array one element for each private</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.ReconstructPrivateSubrs(System.Int32,iText.IO.Font.CFFFont.IndexBaseItem[],iText.IO.Font.CFFFont.OffsetItem[])">
            <summary>Function Adds the new LSubrs dicts (only for the FDs used) to the list</summary>
            <param name="Font">The index of the font</param>
            <param name="fdPrivateBase">The IndexBaseItem array for the linked list</param>
            <param name="fdSubrs">OffsetItem array for the linked list</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CalcSubrOffsetSize(System.Int32,System.Int32)">
            <summary>
            Calculates how many byte it took to write the offset for the subrs in a specific
            private dict.
            </summary>
            <param name="Offset">The Offset for the private dict</param>
            <param name="Size">The size of the private dict</param>
            <returns>The size of the offset of the subrs in the private dict</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CountEntireIndexRange(System.Int32)">
            <summary>Function computes the size of an index</summary>
            <param name="indexOffset">The offset for the computed index</param>
            <returns>The size of the index</returns>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateNonCIDPrivate(System.Int32,iText.IO.Font.CFFFont.OffsetItem)">
            <summary>
            The function creates a private dict for a font that was not CID
            All the keys are copied as is except for the subrs key
            </summary>
            <param name="Font">the font</param>
            <param name="Subr">The OffsetItem for the subrs of the private</param>
        </member>
        <member name="M:iText.IO.Font.CFFFontSubset.CreateNonCIDSubrs(System.Int32,iText.IO.Font.CFFFont.IndexBaseItem,iText.IO.Font.CFFFont.OffsetItem)">
            <summary>
            the function marks the beginning of the subrs index and adds the subsetted subrs
            index to the output list.
            </summary>
            <param name="Font">the font</param>
            <param name="PrivateBase">IndexBaseItem for the private that's referencing to the subrs</param>
            <param name="Subrs">OffsetItem for the subrs</param>
        </member>
        <member name="F:iText.IO.Font.FontProgram.encodingScheme">
            <summary>The font's encoding name.</summary>
            <remarks>
            The font's encoding name. This encoding is 'StandardEncoding' or 'AdobeStandardEncoding' for a font
            that can be totally encoded according to the characters names. For all other names the font is treated as symbolic.
            </remarks>
        </member>
        <member name="M:iText.IO.Font.FontProgram.GetWidth(System.Int32)">
            <summary>Get glyph's width.</summary>
            <param name="unicode">a unicode symbol or FontSpecif code.</param>
            <returns>Gets width in normalized 1000 units.</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgram.GetCharBBox(System.Int32)">
            <summary>Get glyph's bbox.</summary>
            <param name="unicode">a unicode symbol or FontSpecif code.</param>
            <returns>Gets bbox in normalized 1000 units.</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgram.GetKerning(System.Int32,System.Int32)">
            <summary>Gets the kerning between two glyphs.</summary>
            <param name="first">the first unicode value</param>
            <param name="second">the second unicode value</param>
            <returns>the kerning to be applied</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgram.GetKerning(iText.IO.Font.Otf.Glyph,iText.IO.Font.Otf.Glyph)">
            <summary>Gets the kerning between two glyphs.</summary>
            <param name="first">the first glyph</param>
            <param name="second">the second glyph</param>
            <returns>the kerning to be applied</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgram.GetBaseName(System.String)">
            <summary>Gets the name without the modifiers Bold, Italic or BoldItalic.</summary>
            <param name="name">the full name of the font</param>
            <returns>the name without the modifiers Bold, Italic or BoldItalic</returns>
        </member>
        <member name="F:iText.IO.Font.CidFontProperties.RESOURCE_PATH_CMAP">
            <summary>The path to the font resources.</summary>
        </member>
        <member name="M:iText.IO.Font.CidFontProperties.IsCidFont(System.String,System.String)">
            <summary>Checks if its a valid CJKFont font.</summary>
            <param name="fontName">the font name.</param>
            <param name="enc">the encoding.</param>
            <returns>
            
            <see langword="true"/>
            if it is CJKFont.
            </returns>
        </member>
        <member name="M:iText.IO.Font.CidFontProperties.LoadRegistry">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.CidFontProperties.ReadFontProperties(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.CMapEncoding.#ctor(System.String)">
            <param name="cmap">CMap name.</param>
        </member>
        <member name="M:iText.IO.Font.CMapEncoding.#ctor(System.String,System.String)">
            <param name="cmap">CMap name.</param>
            <param name="uniMap">CMap to convert Unicode value to CID.</param>
        </member>
        <member name="T:iText.IO.Font.Cmap.AbstractCMap">
            <author>psoares</author>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapByteCid">
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapByteCid.DecodeSequence(System.Byte[],System.Int32,System.Int32)">
            <param name="cidBytes"/>
            <param name="offset"/>
            <param name="length"/>
            <returns/>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapCidByte">
            <author>psoares</author>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapCidUni">
            <author>psoares</author>
        </member>
        <member name="F:iText.IO.Font.Cmap.CMapContentParser.COMMAND_TYPE">
            <summary>Commands have this type.</summary>
        </member>
        <member name="F:iText.IO.Font.Cmap.CMapContentParser.tokeniser">
            <summary>Holds value of property tokeniser.</summary>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.#ctor(iText.IO.Source.PdfTokenizer)">
            <summary>Creates a new instance of PdfContentParser</summary>
            <param name="tokeniser">the tokeniser with the content</param>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.Parse(System.Collections.Generic.IList{iText.IO.Font.Cmap.CMapObject})">
            <summary>Parses a single command from the content.</summary>
            <remarks>
            Parses a single command from the content. Each command is output as an array of arguments
            having the command itself as the last element. The returned array will be empty if the
            end of content was reached.
            </remarks>
            <param name="ls">
            an
            <c>ArrayList</c>
            to use. It will be cleared before using.
            </param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.ReadDictionary">
            <summary>Reads a dictionary.</summary>
            <remarks>
            Reads a dictionary. The tokeniser must be positioned past the
            <c>"&lt;&lt;"</c>
            token.
            </remarks>
            <returns>the dictionary</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.ReadArray">
            <summary>Reads an array.</summary>
            <remarks>Reads an array. The tokeniser must be positioned past the "[" token.</remarks>
            <returns>an array</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.ReadObject">
            <summary>Reads a pdf object.</summary>
            <returns>the pdf object</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.NextValidToken">
            <summary>Reads the next token skipping over the comments.</summary>
            <returns>
            
            <see langword="true"/>
            if a token was read,
            <see langword="false"/>
            if the end of content was reached.
            </returns>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapContentParser.ToHex(System.Int32)">
            <summary>Gets an hex string in the format "&lt;HHHH&gt;".</summary>
            <param name="n">the number</param>
            <returns>the hex string</returns>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapLocationFromBytes">
            <author>psoares</author>
        </member>
        <member name="T:iText.IO.Font.Cmap.ICMapLocation">
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Cmap.ICMapLocation.GetLocation(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapLocationFromBytes.GetLocation(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapLocationResource">
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapLocationResource.GetLocation(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapObject.ToString">
            <summary>
            Return String representation of
            <c>value</c>
            field.
            </summary>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapParser.ParseCid(System.String,iText.IO.Font.Cmap.AbstractCMap,iText.IO.Font.Cmap.ICMapLocation)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapParser.ParseCid(System.String,iText.IO.Font.Cmap.AbstractCMap,iText.IO.Font.Cmap.ICMapLocation,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapToUnicode">
            <summary>This class represents a CMap file.</summary>
            <author>Ben Litchfield (ben@benlitchfield.com)</author>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.#ctor">
            <summary>Creates a new instance of CMap.</summary>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.HasByteMappings">
            <summary>This will tell if this cmap has any two byte mappings.</summary>
            <returns>true If there are any two byte mappings, false otherwise.</returns>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.Lookup(System.Byte[],System.Int32,System.Int32)">
            <summary>This will perform a lookup into the map.</summary>
            <param name="code">The code used to lookup.</param>
            <param name="offset">The offset into the byte array.</param>
            <param name="length">The length of the data we are getting.</param>
            <returns>The string that matches the lookup.</returns>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.CreateReverseMapping">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.CreateCharsFromSingleBytes(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Cmap.CMapToUnicode.CreateCharsFromDoubleBytes(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Cmap.CMapUniCid">
            <author>psoares</author>
        </member>
        <member name="F:iText.IO.Font.FontCache.CMAP_RESOURCE_PATH">
            <summary>The path to the font resources.</summary>
        </member>
        <member name="M:iText.IO.Font.FontCache.IsPredefinedCidFont(System.String)">
            <summary>
            Checks if the font with the given name and encoding is one
            of the predefined CID fonts.
            </summary>
            <param name="fontName">the font name.</param>
            <returns>
            
            <see langword="true"/>
            if it is CJKFont.
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontCache.LoadRegistry">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontCache.ReadFontProperties(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.FontConstants">
            <summary>
            Font constants for
            <see cref="T:iText.IO.Font.FontProgramFactory"/>
            and PdfFontFactory.
            </summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.RESOURCE_PATH">
            <summary>The path to the font resources.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.UNDEFINED">
            <summary>Undefined font style.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.NORMAL">
            <summary>Normal font style.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BOLD">
            <summary>Bold font style.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.ITALIC">
            <summary>Italic font style.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.UNDERLINE">
            <summary>Deprecated.</summary>
            <remarks>Deprecated. Will be removed in 7.1</remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.STRIKETHRU">
            <summary>Deprecated.</summary>
            <remarks>Deprecated. Will be removed in 7.1</remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BOLDITALIC">
            <summary>Bold-Italic font style.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TYPE_1_FONT">
            <summary>Type 1 PostScript font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TYPE_1_COMPACT_FONT">
            <summary>Compact Font Format PostScript font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TRUE_TYPE_FONT">
            <summary>TrueType or OpenType with TrueType outlines font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.CID_FONT_TYPE_0_FONT">
            <summary>CIDFont Type0 (Type1 outlines).</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.CID_FONT_TYPE_2_FONT">
            <summary>CIDFont Type2 (TrueType outlines).</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.OPEN_TYPE_FONT">
            <summary>OpenType with Type1 outlines.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.COURIER">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.COURIER_BOLD">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.COURIER_OBLIQUE">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.COURIER_BOLDOBLIQUE">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.HELVETICA">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.HELVETICA_BOLD">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.HELVETICA_OBLIQUE">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.HELVETICA_BOLDOBLIQUE">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.SYMBOL">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TIMES_ROMAN">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TIMES_BOLD">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TIMES_ITALIC">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.TIMES_BOLDITALIC">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.ZAPFDINGBATS">
            <summary>This is a possible value of a base 14 type 1 font</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.ASCENT">
            <summary>
            The maximum height above the baseline reached by glyphs in this
            font, excluding the height of glyphs for accented characters.
            </summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.CAPHEIGHT">
            <summary>
            The y coordinate of the top of flat capital letters, measured from
            the baseline.
            </summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.DESCENT">
            <summary>
            The maximum depth below the baseline reached by glyphs in this
            font.
            </summary>
            <remarks>
            The maximum depth below the baseline reached by glyphs in this
            font. The value is a negative number.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.ITALICANGLE">
            <summary>
            The angle, expressed in degrees counterclockwise from the vertical,
            of the dominant vertical strokes of the font.
            </summary>
            <remarks>
            The angle, expressed in degrees counterclockwise from the vertical,
            of the dominant vertical strokes of the font. The value is
            negative for fonts that slope to the right, as almost all italic fonts do.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BBOXLLX">
            <summary>The lower left x glyph coordinate.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BBOXLLY">
            <summary>The lower left y glyph coordinate.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BBOXURX">
            <summary>The upper right x glyph coordinate.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.BBOXURY">
            <summary>The upper right y glyph coordinate.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.AWT_ASCENT">
            <summary>AWT Font property.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.AWT_DESCENT">
            <summary>AWT Font property.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.AWT_LEADING">
            <summary>AWT Font property.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.AWT_MAXADVANCE">
            <summary>AWT Font property.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.UNDERLINE_POSITION">
            <summary>The underline position.</summary>
            <remarks>The underline position. Usually a negative value.</remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.UNDERLINE_THICKNESS">
            <summary>The underline thickness.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.STRIKETHROUGH_POSITION">
            <summary>The strikethrough position.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.STRIKETHROUGH_THICKNESS">
            <summary>The strikethrough thickness.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.SUBSCRIPT_SIZE">
            <summary>The recommended vertical size for subscripts for this font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.SUBSCRIPT_OFFSET">
            <summary>The recommended vertical offset from the baseline for subscripts for this font.</summary>
            <remarks>The recommended vertical offset from the baseline for subscripts for this font. Usually a negative value.
                </remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.SUPERSCRIPT_SIZE">
            <summary>The recommended vertical size for superscripts for this font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.SUPERSCRIPT_OFFSET">
            <summary>The recommended vertical offset from the baseline for superscripts for this font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.WEIGHT_CLASS">
            <summary>The weight class of the font, as defined by the font author.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.WIDTH_CLASS">
            <summary>The width class of the font, as defined by the font author.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.FONT_WEIGHT">
            <summary>The entry of PDF FontDescriptor dictionary.</summary>
            <remarks>
            The entry of PDF FontDescriptor dictionary.
            (Optional; PDF 1.5; strongly recommended for Type 3 fonts in Tagged PDF documents)
            The weight (thickness) component of the fully-qualified font name or font specifier.
            A value larger than 500 indicates bold font-weight.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.FontConstants.notdef">
            <summary>A not defined character in a custom PDF encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.FontConstants.CODE_PAGES">
            <summary>The code pages possible for a True Type font.</summary>
        </member>
        <member name="F:iText.IO.Font.FontEncoding.baseEncoding">
            <summary>Base font encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.FontEncoding.fontSpecific">
            <summary>
            <see langword="true"/>
            if the font must use its built in encoding. In that case
            the
            <c>encoding</c>
            is only used to map a char to the position inside the font, not to the expected char name.
            </summary>
        </member>
        <member name="F:iText.IO.Font.FontEncoding.unicodeToCode">
            <summary>Mapping map from unicode to simple code according to the encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.FontEncoding.differences">
            <summary>Encoding names.</summary>
        </member>
        <member name="F:iText.IO.Font.FontEncoding.unicodeDifferences">
            <summary>Encodings unicode differences</summary>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.CreateFontSpecificEncoding">
            <summary>This encoding will base on font encoding (FontSpecific encoding in Type 1 terminology)</summary>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.GetUnicode(System.Int32)">
            <summary>Gets unicode value for corresponding font's char code.</summary>
            <param name="index">font's char code</param>
            <returns>-1, if the char code unsupported or valid unicode.</returns>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.ConvertToBytes(System.String)">
            <summary>
            Converts a
            <c>String</c>
            to a
            <c>byte</c>
            array according to the encoding.
            String could contain a unicode symbols or font specific codes.
            </summary>
            <param name="text">
            the
            <c>String</c>
            to be converted.
            </param>
            <returns>
            an array of
            <c>byte</c>
            representing the conversion according to the encoding
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.ConvertToByte(System.Int32)">
            <summary>
            Converts a unicode symbol or font specific code
            to
            <c>byte</c>
            according to the encoding.
            </summary>
            <param name="unicode">a unicode symbol or FontSpecif code to be converted.</param>
            <returns>
            a
            <c>byte</c>
            representing the conversion according to the encoding
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.CanEncode(System.Int32)">
            <summary>
            Check whether a unicode symbol or font specific code can be converted
            to
            <c>byte</c>
            according to the encoding.
            </summary>
            <param name="unicode">a unicode symbol or font specific code to be checked.</param>
            <returns>
            
            <see langword="true"/>
            if
            <c>ch</c>
            could be encoded.
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.CanDecode(System.Int32)">
            <summary>
            Check whether a
            <c>byte</c>
            code can be converted
            to unicode symbol according to the encoding.
            </summary>
            <param name="code">a byte code to be checked.</param>
            <returns>
            
            <see langword="true"/>
            if
            <paramref name="code"/>
            could be decoded.
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontEncoding.NormalizeEncoding(System.String)">
            <summary>Normalize the encoding names.</summary>
            <remarks>
            Normalize the encoding names. "winansi" is changed to "Cp1252" and
            "macroman" is changed to "MacRoman".
            </remarks>
            <param name="enc">the encoding to be normalized</param>
            <returns>the normalized encoding</returns>
        </member>
        <member name="M:iText.IO.Font.FontNames.GetNames(System.Int32)">
            <summary>Extracts the names of the font in all the languages available.</summary>
            <param name="id">the name id to retrieve in OpenType notation</param>
            <returns>
            not empty
            <c>String[][]</c>
            if any names exists, otherwise
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramDescriptorFactory.FetchTTCDescriptor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramDescriptorFactory.FetchTrueTypeFontDescriptor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramDescriptorFactory.FetchTrueTypeFontDescriptor(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramDescriptorFactory.FetchOpenTypeFontDescriptor(iText.IO.Font.OpenTypeParser)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramDescriptorFactory.FetchType1FontDescriptor(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.FontProgramFactory">
            <summary>Provides methods for creating various types of fonts.</summary>
        </member>
        <member name="F:iText.IO.Font.FontProgramFactory.DEFAULT_CACHED">
            <summary>This is the default value of the <VAR>cached</VAR> variable.</summary>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont">
            <summary>Creates a new standard Helvetica font program file.</summary>
            <returns>
            a
            <see cref="T:iText.IO.Font.FontProgram"/>
            object with Helvetica font description
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.String)">
            <summary>Creates a new font program.</summary>
            <remarks>
            Creates a new font program. This font program can be one of the 14 built in fonts,
            a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or one from collection) or
            a CJK font from the Adobe Asian Font Pack.
            TrueType fonts and CJK fonts can have an optional style modifier
            appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
            example would be "STSong-Light,Bold". Note that this modifiers do not work if
            the font is embedded. Fonts in TrueType Collections are addressed by index such as "msgothic.ttc,1".
            This would get the second font (indexes start at 0), in this case "MS PGothic".
            <p/>
            The fonts are cached and if they already exist they are extracted from the cache,
            not parsed again.
            <p/>
            </remarks>
            <param name="fontProgram">the name of the font or its location on file</param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            . This font program may come from the cache
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.String,System.Boolean)">
            <summary>Creates a new font program.</summary>
            <remarks>
            Creates a new font program. This font program can be one of the 14 built in fonts,
            a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or one from collection) or
            a CJK font from the Adobe Asian Font Pack.
            TrueType fonts and CJK fonts can have an optional style modifier
            appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
            example would be "STSong-Light,Bold". Note that this modifiers do not work if
            the font is embedded. Fonts in TrueType Collections are addressed by index such as "msgothic.ttc,1".
            This would get the second font (indexes start at 0), in this case "MS PGothic".
            <p/>
            The fonts are cached and if they already exist they are extracted from the cache,
            not parsed again.
            <p/>
            </remarks>
            <param name="fontProgram">the name of the font or its location on file</param>
            <param name="cached">whether to to cache this font program after it has been loaded</param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            . This font program may come from the cache
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.Byte[])">
            <summary>Creates a new font program.</summary>
            <remarks>
            Creates a new font program. This font program can be one of the 14 built in fonts,
            a Type1 font referred to by an AFM or PFM file, a TrueType font (simple only) or
            a CJK font from the Adobe Asian Font Pack.
            TrueType fonts and CJK fonts can have an optional style modifier
            appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
            example would be "STSong-Light,Bold". Note that this modifiers do not work if
            the font is embedded. Fonts in TrueType Collections are addressed by index such as "msgothic.ttc,1".
            This would get the second font (indexes start at 0), in this case "MS PGothic".
            <p/>
            The fonts are cached and if they already exist they are extracted from the cache,
            not parsed again.
            <p/>
            </remarks>
            <param name="fontProgram">the byte contents of the font program</param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            . This font program may come from the cache
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.Byte[],System.Boolean)">
            <summary>Creates a new font program.</summary>
            <remarks>
            Creates a new font program. This font program can be one of the 14 built in fonts,
            a Type 1 font referred to by an AFM or PFM file, a TrueType font (simple only) or
            a CJK font from the Adobe Asian Font Pack.
            TrueType fonts and CJK fonts can have an optional style modifier
            appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
            example would be "STSong-Light,Bold". Note that this modifiers do not work if
            the font is embedded. Fonts in TrueType Collections are addressed by index such as "msgothic.ttc,1".
            This would get the second font (indexes start at 0), in this case "MS PGothic".
            <p/>
            The fonts are cached and if they already exist they are extracted from the cache,
            not parsed again.
            <p/>
            </remarks>
            <param name="fontProgram">the byte contents of the font program</param>
            <param name="cached">whether to to cache this font program</param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            . This font program may come from the cache
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.String,System.Byte[],System.Boolean)">
            <summary>This method is deprecated and will be made private in 7.1</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.String,System.Byte[],System.Byte[],System.Boolean)">
            <summary>This method is deprecated and will be completely removed in 7.1</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.Byte[],System.Byte[])">
            <summary>Creates a new Type 1 font by the byte contents of the corresponding AFM/PFM and PFB files</summary>
            <param name="afm">the contents of the AFM or PFM metrics file</param>
            <param name="pfb">the contents of the PFB file</param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.Byte[],System.Byte[],System.Boolean)">
            <summary>Creates a new Type 1 font by the byte contents of the corresponding AFM/PFM and PFB files</summary>
            <param name="afm">the contents of the AFM or PFM metrics file</param>
            <param name="pfb">the contents of the PFB file</param>
            <param name="cached">
            specifies whether to cache the created
            <see cref="T:iText.IO.Font.FontProgram"/>
            or not
            </param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.String,System.String)">
            <summary>Creates a new Type 1 font by the corresponding AFM/PFM and PFB files</summary>
            <param name="metricsPath">path to the AFM or PFM metrics file</param>
            <param name="binaryPath">path to the contents of the PFB file</param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.String,System.String,System.Boolean)">
            <summary>Creates a new Type 1 font by the corresponding AFM/PFM and PFB files</summary>
            <param name="metricsPath">path to the AFM or PFM metrics file</param>
            <param name="binaryPath">path to the contents of the PFB file</param>
            <param name="cached">
            specifies whether to cache the created
            <see cref="T:iText.IO.Font.FontProgram"/>
            or not
            </param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.String,System.Int32,System.Boolean)">
            <summary>Creates a new TrueType font program from ttc (TrueType Collection) file.</summary>
            <param name="ttc">location  of TrueType Collection file (*.ttc)</param>
            <param name="ttcIndex">the index of the font file from the collection to be read</param>
            <param name="cached">
            true if the font comes from the cache or is added to
            the cache if new, false if the font is always created new
            </param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance. This font may come from the cache but only if cached
            is true, otherwise it will always be created new
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateFont(System.Byte[],System.Int32,System.Boolean)">
            <summary>Creates a new TrueType font program from ttc (TrueType Collection) file bytes.</summary>
            <param name="ttc">the content of a TrueType Collection file (*.ttc)</param>
            <param name="ttcIndex">the index of the font file from the collection to be read</param>
            <param name="cached">
            true if the font comes from the cache or is added to
            the cache if new, false if the font is always created new
            </param>
            <returns>
            returns a new
            <see cref="T:iText.IO.Font.FontProgram"/>
            instance. This font may come from the cache but only if cached
            is true, otherwise it will always be created new
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateRegisteredFont(System.String,System.Int32,System.Boolean)">
            <summary>Creates a FontProgram from the font file that has been previously registered.</summary>
            <param name="fontName">
            either a font alias, if the font file has been registered with an alias,
            or just a font name otherwise
            </param>
            <param name="style">
            the style of the font to look for. Possible values are listed in
            <see cref="T:iText.IO.Font.FontConstants"/>
            .
            See
            <see cref="F:iText.IO.Font.FontConstants.BOLD"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.ITALIC"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.NORMAL"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.BOLDITALIC"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.UNDEFINED"/>
            </param>
            <param name="cached">whether to try to get the font program from cache</param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateRegisteredFont(System.String,System.Int32)">
            <summary>Creates a FontProgram from the font file that has been previously registered.</summary>
            <param name="fontName">
            either a font alias, if the font file has been registered with an alias,
            or just a font name otherwise
            </param>
            <param name="style">
            the style of the font to look for. Possible values are listed in
            <see cref="T:iText.IO.Font.FontConstants"/>
            .
            See
            <see cref="F:iText.IO.Font.FontConstants.BOLD"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.ITALIC"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.NORMAL"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.BOLDITALIC"/>
            ,
            <see cref="F:iText.IO.Font.FontConstants.UNDEFINED"/>
            </param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateRegisteredFont(System.String)">
            <summary>Creates a FontProgram from the font file that has been previously registered.</summary>
            <param name="fontName">
            either a font alias, if the font file has been registered with an alias,
            or just a font name otherwise
            </param>
            <returns>
            created
            <see cref="T:iText.IO.Font.FontProgram"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.RegisterFontFamily(System.String,System.String,System.String)">
            <summary>Register a font by giving explicitly the font family and name.</summary>
            <param name="familyName">the font family</param>
            <param name="fullName">the font name</param>
            <param name="path">the font path</param>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.RegisterFont(System.String)">
            <summary>Registers a .ttf, .otf, .afm, .pfm, or a .ttc font file.</summary>
            <remarks>
            Registers a .ttf, .otf, .afm, .pfm, or a .ttc font file.
            In case if TrueType Collection (.ttc), an additional parameter may be specified defining the index of the font
            to be registered, e.g. "path/to/font/collection.ttc,0". The index is zero-based.
            </remarks>
            <param name="path">the path to a font file</param>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.RegisterFont(System.String,System.String)">
            <summary>Register a font file and use an alias for the font contained in it.</summary>
            <param name="path">the path to a font file</param>
            <param name="alias">the alias you want to use for the font</param>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.RegisterFontDirectory(System.String)">
            <summary>Register all the fonts in a directory.</summary>
            <param name="dir">the directory</param>
            <returns>the number of fonts registered</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.RegisterSystemFontDirectories">
            <summary>Register fonts in some probable directories.</summary>
            <remarks>
            Register fonts in some probable directories. It usually works in Windows,
            Linux and Solaris.
            </remarks>
            <returns>the number of fonts registered</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.GetRegisteredFonts">
            <summary>Gets a set of registered font names.</summary>
            <returns>a set of registered fonts</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.GetRegisteredFontFamilies">
            <summary>Gets a set of registered font names.</summary>
            <returns>a set of registered font families</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.IsRegisteredFont(System.String)">
            <summary>Checks if a certain font is registered.</summary>
            <param name="fontName">the name of the font that has to be checked.</param>
            <returns>true if the font is found</returns>
        </member>
        <member name="M:iText.IO.Font.FontProgramFactory.CreateType1Font(System.String,System.String,System.Byte[],System.Byte[],System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.FontRegisterProvider">
            <summary>
            If you are using True Type fonts, you can declare the paths of the different ttf- and ttc-files
            to this class first and then create fonts in your code using one of the getFont method
            without having to enter a path as parameter.
            </summary>
        </member>
        <member name="F:iText.IO.Font.FontRegisterProvider.fontNames">
            <summary>This is a map of postscriptfontnames of fonts and the path of their font file.</summary>
        </member>
        <member name="F:iText.IO.Font.FontRegisterProvider.fontFamilies">
            <summary>This is a map of fontfamilies.</summary>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.#ctor">
            <summary>Creates new FontRegisterProvider</summary>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.GetFont(System.String,System.Int32)">
            <summary>Constructs a <CODE>Font</CODE>-object.</summary>
            <param name="fontName">the name of the font</param>
            <param name="style">the style of this font</param>
            <returns>the Font constructed based on the parameters</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.GetFont(System.String,System.Int32,System.Boolean)">
            <summary>Constructs a <CODE>Font</CODE>-object.</summary>
            <param name="fontName">the name of the font</param>
            <param name="style">the style of this font</param>
            <param name="cached">
            true if the font comes from the cache or is added to
            the cache if new, false if the font is always created new
            </param>
            <returns>the Font constructed based on the parameters</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.GetFontProgram(System.String,System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.RegisterFontFamily(System.String,System.String,System.String)">
            <summary>Register a font by giving explicitly the font family and name.</summary>
            <param name="familyName">the font family</param>
            <param name="fullName">the font name</param>
            <param name="path">the font path</param>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.RegisterFont(System.String)">
            <summary>Register a font file, either .ttf or .otf, .afm or a font from TrueType Collection.</summary>
            <remarks>
            Register a font file, either .ttf or .otf, .afm or a font from TrueType Collection.
            If a TrueType Collection is registered, an additional index of the font program can be specified
            </remarks>
            <param name="path">the path to a ttf- or ttc-file</param>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.RegisterFont(System.String,System.String)">
            <summary>Register a font file and use an alias for the font contained in it.</summary>
            <param name="path">the path to a font file</param>
            <param name="alias">the alias you want to use for the font</param>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.RegisterFontDirectory(System.String)">
            <summary>Register all the fonts in a directory.</summary>
            <param name="dir">the directory</param>
            <returns>the number of fonts registered</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Font.FontRegisterProvider.RegisterFontDirectory(System.String,System.Boolean)" -->
        <member name="M:iText.IO.Font.FontRegisterProvider.RegisterSystemFontDirectories">
            <summary>Register fonts in some probable directories.</summary>
            <remarks>
            Register fonts in some probable directories. It usually works in Windows,
            Linux and Solaris.
            </remarks>
            <returns>the number of fonts registered</returns>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.GetRegisteredFonts">
            <summary>Gets a set of registered font names.</summary>
            <returns>a set of registered fonts</returns>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.GetRegisteredFontFamilies">
            <summary>Gets a set of registered font names.</summary>
            <returns>a set of registered font families</returns>
        </member>
        <member name="M:iText.IO.Font.FontRegisterProvider.IsRegisteredFont(System.String)">
            <summary>Checks if a certain font is registered.</summary>
            <param name="fontname">the name of the font that has to be checked.</param>
            <returns>true if the font is found</returns>
        </member>
        <member name="T:iText.IO.Font.IExtraEncoding">
            <summary>
            Classes implementing this interface can create custom encodings or
            replace existing ones.
            </summary>
            <remarks>
            Classes implementing this interface can create custom encodings or
            replace existing ones. It is used in the context of <code>PdfEncoding</code>.
            </remarks>
            <author>Paulo Soares</author>
        </member>
        <member name="M:iText.IO.Font.IExtraEncoding.CharToByte(System.String,System.String)">
            <summary>Converts an Unicode string to a byte array according to some encoding.</summary>
            <param name="text">the Unicode string</param>
            <param name="encoding">
            the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            </param>
            <returns>the conversion or <CODE>null</CODE> if no conversion is supported</returns>
        </member>
        <member name="M:iText.IO.Font.IExtraEncoding.CharToByte(System.Char,System.String)">
            <summary>Converts an Unicode char to a byte array according to some encoding.</summary>
            <param name="char1">the Unicode char</param>
            <param name="encoding">
            the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            </param>
            <returns>the conversion or <CODE>null</CODE> if no conversion is supported</returns>
        </member>
        <member name="M:iText.IO.Font.IExtraEncoding.ByteToChar(System.Byte[],System.String)">
            <summary>Converts a byte array to an Unicode string according to some encoding.</summary>
            <param name="b">the input byte array</param>
            <param name="encoding">
            the requested encoding. It's mainly of use if the same class
            supports more than one encoding.
            </param>
            <returns>the conversion or <CODE>null</CODE> if no conversion is supported</returns>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.fileName">
            <summary>The file name.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.raf">
            <summary>The file in use.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.ttcIndex">
            <summary>The index for the TTC font.</summary>
            <remarks>
            The index for the TTC font. It is -1
            <c>int</c>
            for a TTF file.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.directoryOffset">
            <summary>The offset from the start of the file to the table directory.</summary>
            <remarks>
            The offset from the start of the file to the table directory.
            It is 0 for TTF and may vary for TTC depending on the chosen font.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.fontName">
            <summary>The font name.</summary>
            <remarks>The font name. This name is usually extracted from the table 'name' with the 'Name ID' 6.</remarks>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.allNameEntries">
            <summary>All the names of the Names-Table.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.cff">
            <summary>Indicate, that the font contains 'CFF ' table.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.cffOffset">
            <summary>Offset to 'CFF ' table.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.cffLength">
            <summary>Length of 'CFF ' table.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.tables">
            <summary>Contains the location of the several tables.</summary>
            <remarks>
            Contains the location of the several tables. The key is the name of
            the table and the value is an <CODE>int[2]</CODE> where position 0
            is the offset from the start of the file and position 1 is the length
            of the table.
            </remarks>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.#ctor(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.#ctor(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.#ctor(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.GetPsFontName">
            <summary>Gets the Postscript font name.</summary>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.GetFullFont">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadCffFont">
            <summary>
            If this font file is using the Compact Font File Format, then this method
            will return the raw bytes needed for the font stream.
            </summary>
            <remarks>
            If this font file is using the Compact Font File Format, then this method
            will return the raw bytes needed for the font stream. If this method is
            ever made public: make sure to add a test if (cff == true).
            </remarks>
            <returns>a byte array</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.GetSubset(System.Collections.Generic.ICollection{System.Int32},System.Boolean)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.InitializeSfntTables">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.LoadTables(System.Boolean)">
            <summary>Reads the font data.</summary>
            <param name="all">if true, all tables will be read, otherwise only 'head', 'name', and 'os/2'.</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.Process">
            <summary>Reads the font data.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.GetTTCName(System.String)">
            <summary>Gets the name from a composed TTC file name.</summary>
            <remarks>
            Gets the name from a composed TTC file name.
            If I have for input "myfont.ttc,2" the return will
            be "myfont.ttc".
            </remarks>
            <param name="name">the full name</param>
            <returns>the simple file name</returns>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadGlyphWidths">
            <summary>Reads the glyphs widths.</summary>
            <remarks>
            Reads the glyphs widths. The widths are extracted from the table 'hmtx'.
            The glyphs are normalized to 1000 units (TrueTypeFont.UNITS_NORMALIZATION).
            Depends from
            <c>hhea.numberOfHMetrics</c>
            property,
            <seealso>HorizontalHeader</seealso>
            and
            <c>head.unitsPerEm</c>
            property,
            <seealso>HeaderTable</seealso>
            .
            </remarks>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadKerning(System.Int32)">
            <summary>Reads the kerning information from the 'kern' table.</summary>
            <param name="unitsPerEm">
            
            <c>head.unitsPerEm</c>
            property,
            <seealso>HeaderTable</seealso>
            .
            </param>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadBbox(System.Int32)">
            <summary>Read the glyf bboxes from 'glyf' table.</summary>
            <param name="unitsPerEm">
            
            <c>head.unitsPerEm</c>
            property,
            <seealso>HeaderTable</seealso>
            .
            </param>
            <exception cref="T:iText.IO.IOException">the font is invalid.</exception>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadMaxGlyphId">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadNameTable">
            <summary>Extracts the names of the font in all the languages available.</summary>
            <exception cref="T:iText.IO.IOException">on error</exception>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadHheaTable">
            <summary>Read horizontal header, table 'hhea'.</summary>
            <exception cref="T:iText.IO.IOException">the font is invalid.</exception>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadHeadTable">
            <summary>Read font header, table 'head'.</summary>
            <exception cref="T:iText.IO.IOException">the font is invalid.</exception>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadOs_2Table">
            <summary>Reads the windows metrics table.</summary>
            <remarks>
            Reads the windows metrics table. The metrics are extracted from the table 'OS/2'.
            Depends from
            <c>head.unitsPerEm</c>
            property,
            <seealso>HeaderTable</seealso>
            .
            </remarks>
            <exception cref="T:iText.IO.IOException">the font is invalid.</exception>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadPostTable">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadCmapTable">
            <summary>Reads the several maps from the table 'cmap'.</summary>
            <remarks>
            Reads the several maps from the table 'cmap'. The maps of interest are 1.0 for symbolic
            fonts and 3.1 for all others. A symbolic font is defined as having the map 3.0.
            Depends from
            <c>readGlyphWidths()</c>
            .
            </remarks>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadStandardString(System.Int32)">
            <summary>
            Reads a <CODE>String</CODE> from the font file as bytes using the Cp1252
            encoding.
            </summary>
            <param name="length">the length of bytes to read</param>
            <returns>the <CODE>String</CODE> read</returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadUnicodeString(System.Int32)">
            <summary>Reads a Unicode <CODE>String</CODE> from the font file.</summary>
            <remarks>Reads a Unicode <CODE>String</CODE> from the font file. Each character is represented by two bytes.
                </remarks>
            <param name="length">the length of bytes to read. The <CODE>String</CODE> will have <CODE>length</CODE>/2 characters.
                </param>
            <returns>the <CODE>String</CODE> read.</returns>
            <exception cref="T:System.IO.IOException">the font file could not be read.</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.GetGlyphWidth(System.Int32)">
            <summary>Gets a glyph width.</summary>
            <param name="glyph">the glyph to get the width of</param>
            <returns>the width of the glyph in normalized 1000 units (TrueTypeFont.UNITS_NORMALIZATION)</returns>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadFormat0">
            <summary>The information in the maps of the table 'cmap' is coded in several formats.</summary>
            <remarks>
            The information in the maps of the table 'cmap' is coded in several formats.
            Format 0 is the Apple standard character to glyph index mapping table.
            </remarks>
            <returns>a <CODE>HashMap</CODE> representing this map</returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadFormat4(System.Boolean)">
            <summary>The information in the maps of the table 'cmap' is coded in several formats.</summary>
            <remarks>
            The information in the maps of the table 'cmap' is coded in several formats.
            Format 4 is the Microsoft standard character to glyph index mapping table.
            </remarks>
            <returns>a <CODE>HashMap</CODE> representing this map</returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadFormat6">
            <summary>The information in the maps of the table 'cmap' is coded in several formats.</summary>
            <remarks>
            The information in the maps of the table 'cmap' is coded in several formats.
            Format 6 is a trimmed table mapping. It is similar to format 0 but can have
            less than 256 entries.
            </remarks>
            <returns>a <CODE>HashMap</CODE> representing this map</returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.OpenTypeParser.ReadFormat12">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.OpenTypeParser.HeaderTable">
            <summary>The components of table 'head'.</summary>
        </member>
        <member name="T:iText.IO.Font.OpenTypeParser.HorizontalHeader">
            <summary>The components of table 'hhea'.</summary>
        </member>
        <member name="T:iText.IO.Font.OpenTypeParser.WindowsMetrics">
            <summary>The components of table 'OS/2'.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.PostTable.italicAngle">
            <summary>The italic angle.</summary>
            <remarks>
            The italic angle. It is usually extracted from the 'post' table or in it's
            absence with the code:
            <PRE>
            <c>-Math.atan2(hhea.caretSlopeRun, hhea.caretSlopeRise) * 180 / Math.PI</c>
            </PRE>
            </remarks>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.PostTable.isFixedPitch">
            <summary><CODE>true</CODE> if all the glyphs have the same width.</summary>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.CmapTable.cmap10">
            <summary>The map containing the code information for the table 'cmap', encoding 1.0.</summary>
            <remarks>
            The map containing the code information for the table 'cmap', encoding 1.0.
            The key is the code and the value is an
            <c>int[2]</c>
            where position 0
            is the glyph number and position 1 is the glyph width normalized to 1000 units.
            <seealso>TrueTypeFont.UNITS_NORMALIZATION</seealso>
            .
            </remarks>
        </member>
        <member name="F:iText.IO.Font.OpenTypeParser.CmapTable.cmap31">
            <summary>The map containing the code information for the table 'cmap', encoding 3.1 in Unicode.</summary>
            <remarks>
            The map containing the code information for the table 'cmap', encoding 3.1 in Unicode.
            The key is the code and the value is an
            <c>int[2]</c>
            where position 0
            is the glyph number and position 1 is the glyph width normalized to 1000 units.
            <seealso>TrueTypeFont.UNITS_NORMALIZATION</seealso>
            .
            </remarks>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.GetContextLength">
            <returns>length of the context glyph sequence defined by this rule.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.GetSubstLookupRecords">
            <returns>
            an array of <code>SubstLookupRecord</code>. Each record specifies a position in the context glyph
            sequence and a LookupListIndex to the substitution lookup that is applied at that position.
            </returns>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.IsGlyphMatchesInput(System.Int32,System.Int32)">
            <summary>Checks if glyph line element matches element from input sequence of the rule.</summary>
            <remarks>
            Checks if glyph line element matches element from input sequence of the rule.
            <br /><br />
            NOTE: rules do not contain the first element of the input sequence, the first element is defined by rule
            position in substitution table. Therefore atIdx shall not be 0.
            </remarks>
            <param name="atIdx">index in the rule sequence. Shall be: 0 &lt; atIdx &lt; ContextualSubstRule.getContextLength().
                </param>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.GetLookaheadContextLength">
            <returns>length of the lookahead context glyph sequence defined by this rule.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.GetBacktrackContextLength">
            <returns>length of the backtrack context glyph sequence defined by this rule.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.IsGlyphMatchesLookahead(System.Int32,System.Int32)">
            <summary>Checks if glyph line element matches element from lookahead sequence of the rule.</summary>
            <param name="atIdx">index in rule sequence. Shall be: 0 &lt;= atIdx &lt; ContextualSubstRule.getLookaheadContextLength().
                </param>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubstRule.IsGlyphMatchesBacktrack(System.Int32,System.Int32)">
            <summary>Checks if glyph line element matches element from backtrack sequence of the rule.</summary>
            <param name="atIdx">index in rule sequence. Shall be: 0 &lt;= atIdx &lt; ContextualSubstRule.getBacktrackContextLength().
                </param>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubTable.GetMatchingContextRule(iText.IO.Font.Otf.GlyphLine)">
            <summary>Gets a most preferable context rule that matches the line at current position.</summary>
            <remarks>
            Gets a most preferable context rule that matches the line at current position. If no matching context rule is found,
            it returns null.
            <br /><br />
            NOTE: if matching context rule is found, the <code>GlyphLine.start</code> and <code>GlyphLine.end</code> will be
            changed in such way, that they will point at start and end of the matching context glyph sequence inside the glyph line.
            </remarks>
            <param name="line">a line, which is to be checked if it matches some context.</param>
            <returns>matching context rule or null, if none was found.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubTable.GetSetOfRulesForStartGlyph(System.Int32)">
            <summary>Gets a set of rules, which start with given glyph id.</summary>
            <param name="startId">id of the first glyph in the sequence.</param>
        </member>
        <member name="M:iText.IO.Font.Otf.ContextualSubTable.CheckIfContextMatch(iText.IO.Font.Otf.GlyphLine,iText.IO.Font.Otf.ContextualSubstRule)">
            <summary>Checks if given glyph line at the given position matches given rule.</summary>
            <returns>
            either index which corresponds to the last glyph of the matching context inside the glyph line if context matches,
            or -1 if context doesn't match.
            </returns>
        </member>
        <member name="T:iText.IO.Font.Otf.FeatureRecord">
            <author>psoares</author>
        </member>
        <member name="T:iText.IO.Font.Otf.FontReadingException">
            <author><a href="mailto:paawak@gmail.com">Palash Ray</a></author>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Construct a non-mark Glyph, retrieving characters from unicode.</summary>
            <param name="code">code representation of the glyph in the font file</param>
            <param name="width">normalized width of the glyph</param>
            <param name="unicode">utf-32 representation of glyph if appears. Correct value is &gt; -1</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(System.Int32,System.Int32,System.Char[])">
            <summary>Construct a non-mark Glyph, using the codepoint of the characters as unicode point.</summary>
            <param name="code">code representation of the glyph in the font file</param>
            <param name="width">normalized width of the glyph</param>
            <param name="chars">The Unicode text represented by this Glyph.</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>Construct a non-mark Glyph, retrieving characters from unicode.</summary>
            <param name="code">code representation of the glyph in the font file</param>
            <param name="width">normalized width of the glyph</param>
            <param name="unicode">utf-32 representation of glyph if appears. Correct value is &gt; -1</param>
            <param name="bbox">The normalized bounding box of this Glyph.</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(System.Int32,System.Int32)">
            <summary>Construct a non-mark Glyph object with id -1 and characters retrieved from unicode.</summary>
            <param name="width">normalized width of the glyph</param>
            <param name="unicode">utf-32 representation of glyph if appears. Correct value is &gt; -1</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(System.Int32,System.Int32,System.Int32,System.Char[],System.Boolean)">
            <summary>Construct a glyph object form the passed arguments.</summary>
            <param name="code">code representation of the glyph in the font file</param>
            <param name="width">normalized width of the glyph</param>
            <param name="unicode">utf-32 representation of glyph if appears. Correct value is &gt; -1</param>
            <param name="chars">
            The Unicode text represented by this Glyph.
            if null is passed, the unicode value is used to retrieve the chars.
            </param>
            <param name="IsMark">True if the glyph is a Mark</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(iText.IO.Font.Otf.Glyph)">
            <summary>Copy a Glyph.</summary>
            <param name="glyph">Glyph to copy</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(iText.IO.Font.Otf.Glyph,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Copy a Glyph and assign new placement and advance offsets and a new index delta to base glyph</summary>
            <param name="glyph">Glyph to copy</param>
            <param name="xPlacement">x - placement offset</param>
            <param name="yPlacement">y - placement offset</param>
            <param name="xAdvance">x - advance offset</param>
            <param name="yAdvance">y - advance offset</param>
            <param name="anchorDelta">Index delta to base glyph. If after a glyph there are several anchored glyphs we should know we to find base glyph.
                </param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.#ctor(iText.IO.Font.Otf.Glyph,System.Int32)">
            <summary>Copy a glyph and assign the copied glyph a new unicode point and characters</summary>
            <param name="glyph">glyph to copy</param>
            <param name="unicode">new unicode point</param>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.Equals(System.Object)">
            <summary>Two Glyphs are equal if their unicode characters, code and normalized width are equal.</summary>
            <param name="obj"/>
            <returns>True if this equals obj cast to Glyph, false otherwise.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.GetUnicodeString">
            <summary>Gets a Unicode string corresponding to this glyph.</summary>
            <remarks>
            Gets a Unicode string corresponding to this glyph. In general case it might consist of many characters.
            If this glyph does not have a valid unicode (
            <seealso>#hasValidUnicode()</seealso>
            , then a string consisting of a special
            Unicode '\ufffd' character is returned.
            </remarks>
            <returns>the Unicode string that corresponds to this glyph</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.Glyph.GetUnicodeChars">
            <summary>Gets Unicode char sequence corresponding to this glyph.</summary>
            <remarks>
            Gets Unicode char sequence corresponding to this glyph. In general case it might consist of many characters.
            If this glyph does not have a valid unicode (
            <seealso>#hasValidUnicode()</seealso>
            , then a special Unicode '\ufffd' character is returned.
            </remarks>
            <returns>the Unicode char sequence that corresponds to this glyph</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.#ctor(System.Collections.Generic.IList{iText.IO.Font.Otf.Glyph})">
            <summary>Create a new line of Glyphs.</summary>
            <param name="glyphs">list containing the glyphs</param>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.#ctor(System.Collections.Generic.IList{iText.IO.Font.Otf.Glyph},System.Int32,System.Int32)">
            <summary>Create a new line of Glyphs from a slice of a List of Glyphs.</summary>
            <param name="glyphs">list of Glyphs to slice</param>
            <param name="start">starting index of the slice</param>
            <param name="end">terminating index of the slice</param>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.#ctor(System.Collections.Generic.IList{iText.IO.Font.Otf.Glyph},System.Collections.Generic.IList{iText.IO.Font.Otf.GlyphLine.ActualText},System.Int32,System.Int32)">
            <summary>Create a new line of Glyphs from a slice of a List of Glyphs, and add the actual text.</summary>
            <param name="glyphs">list of Glyphs to slice</param>
            <param name="actualText">corresponding list containing the actual text the glyphs represent</param>
            <param name="start">starting index of the slice</param>
            <param name="end">terminating index of the slice</param>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.#ctor(iText.IO.Font.Otf.GlyphLine)">
            <summary>Copy a line of Glyphs.</summary>
            <param name="other">line of Glyphs to copy</param>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.#ctor(iText.IO.Font.Otf.GlyphLine,System.Int32,System.Int32)">
            <summary>Copy a slice of a line of Glyphs</summary>
            <param name="other">line of Glyphs to copy</param>
            <param name="start">starting index of the slice</param>
            <param name="end">terminating index of the slice</param>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.ToUnicodeString(System.Int32,System.Int32)">
            <summary>Get the unicode string representation of the GlyphLine slice.</summary>
            <param name="start">starting index of the slice</param>
            <param name="end">terminating index of the slice</param>
            <returns>String containing the unicode representation of the slice.</returns>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphLine.Copy(System.Int32,System.Int32)">
            <summary>Copy a slice of this Glyphline.</summary>
            <param name="left">leftmost index of the slice</param>
            <param name="right">rightmost index of the slice</param>
            <returns>new GlyphLine containing the copied slice</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Font.Otf.GlyphPositioningTableReader" -->
        <member name="T:iText.IO.Font.Otf.OpenTypeFontTableReader">
            <author><a href="mailto:paawak@gmail.com">Palash Ray</a></author>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int32,iText.IO.Font.Otf.OpenTypeGdefTableReader,System.Collections.Generic.IDictionary{System.Int32,iText.IO.Font.Otf.Glyph},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadLookupTable(System.Int32,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadClassDefinition(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadUShortArray(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadUShortArray(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadCoverages(System.Int32[],System.Collections.Generic.IList{System.Collections.Generic.ICollection{System.Int32}})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadCoverageFormat(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadSubstLookupRecords(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadTagAndLocations(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.StartReadingTable">
            <summary>This is the starting point of the class.</summary>
            <remarks>
            This is the starting point of the class. A sub-class must call this
            method to start getting call backs to the
            <see cref="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadLookupTable(System.Int32,System.Int32,System.Int32[])"/>
            method.
            </remarks>
            <exception cref="T:iText.IO.Font.Otf.FontReadingException"/>
            <exception cref="T:iText.IO.Font.Otf.FontReadingException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadLookupListTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFontTableReader.ReadLookupTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphPositioningTableReader.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int32,iText.IO.Font.Otf.OpenTypeGdefTableReader,System.Collections.Generic.IDictionary{System.Int32,iText.IO.Font.Otf.Glyph},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphPositioningTableReader.ReadLookupTable(System.Int32,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Font.Otf.GlyphSubstitutionTableReader" -->
        <member name="M:iText.IO.Font.Otf.GlyphSubstitutionTableReader.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int32,iText.IO.Font.Otf.OpenTypeGdefTableReader,System.Collections.Generic.IDictionary{System.Int32,iText.IO.Font.Otf.Glyph},System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GlyphSubstitutionTableReader.ReadLookupTable(System.Int32,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GposLookupType2">
            <summary>
            Lookup Type 2:
            Pair Adjustment Positioning Subtable
            </summary>
        </member>
        <member name="T:iText.IO.Font.Otf.OpenTableLookup">
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTableLookup.ReadSubTables">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTableLookup.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat1.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat1.ReadFormat(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat1.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat2.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat2.ReadFormat(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType2.PairPosAdjustmentFormat2.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GposLookupType4">
            <summary>
            Lookup Type 4:
            MarkToBase Attachment Positioning Subtable
            </summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType4.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType4.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GposLookupType5">
            <summary>
            Lookup Type 5:
            MarkToLigature Attachment Positioning Subtable
            </summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType5.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType5.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GposLookupType6">
            <summary>
            Lookup Type 6:
            MarkToMark Attachment Positioning Subtable
            </summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType6.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GposLookupType6.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType1">
            <summary>LookupType 1: Single Substitution Subtable</summary>
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType1.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType1.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType2">
            <summary>LookupType 2: Multiple Substitution Subtable</summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType2.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType2.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType3">
            <summary>LookupType 3: Alternate Substitution Subtable</summary>
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType3.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType3.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType4">
            <summary>LookupType 4: Ligature Substitution Subtable</summary>
            <author>psoares</author>
        </member>
        <member name="F:iText.IO.Font.Otf.GsubLookupType4.ligatures">
            <summary>The key is the first character.</summary>
            <remarks>
            The key is the first character. The first element in the int array is the
            output ligature
            </remarks>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType4.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType4.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType5">
            <summary>LookupType 5: Contextual Substitution Subtable</summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType5.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType5.ReadSubTable(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType5.ReadSubTableFormat1(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType5.ReadSubTableFormat2(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType5.ReadSubTableFormat3(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.GsubLookupType6">
            <summary>LookupType 6: Chaining Contextual Substitution Subtable</summary>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType6.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType6.ReadSubTableFormat1(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType6.ReadSubTableFormat2(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.GsubLookupType6.ReadSubTableFormat3(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype5.SubTableLookup5Format1">
            <summary>Contextual Substitution Subtable: Simple context glyph substitution</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype5.SubTableLookup5Format2">
            <summary>Contextual Substitution Subtable: Class-based context glyph substitution</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype5.SubTableLookup5Format3">
            <summary>Contextual Substitution Subtable: Coverage-based context glyph substitution</summary>
        </member>
        <member name="M:iText.IO.Font.Otf.Lookuptype6.SubTableLookup6.CheckIfLookaheadContextMatch(iText.IO.Font.Otf.GlyphLine,iText.IO.Font.Otf.ContextualSubstRule,System.Int32)">
            <summary>Checks if given glyph line at the given position matches given rule.</summary>
        </member>
        <member name="M:iText.IO.Font.Otf.Lookuptype6.SubTableLookup6.CheckIfBacktrackContextMatch(iText.IO.Font.Otf.GlyphLine,iText.IO.Font.Otf.ContextualSubstRule)">
            <summary>Checks if given glyph line at the given position matches given rule.</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype6.SubTableLookup6Format1">
            <summary>Chaining Contextual Substitution Subtable: Simple Chaining Context Glyph Substitution</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype6.SubTableLookup6Format2">
            <summary>Chaining Contextual Substitution Subtable: Class-based Chaining Context Glyph Substitution</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.Lookuptype6.SubTableLookup6Format3">
            <summary>Chaining Contextual Substitution Subtable: Coverage-based Chaining Context Glyph Substitution</summary>
        </member>
        <member name="T:iText.IO.Font.Otf.MarkTable">
            <author>psoares</author>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeFeature.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeGdefTableReader.ReadTable">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeScript.#ctor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeScript.ReadScriptRecord(iText.IO.Font.Otf.TagAndLocation)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OpenTypeScript.ReadLanguageRecord(iText.IO.Font.Otf.TagAndLocation)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfClass.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadUShortArray(iText.IO.Source.RandomAccessFileOrArray,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadUShortArray(iText.IO.Source.RandomAccessFileOrArray,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadCoverages(iText.IO.Source.RandomAccessFileOrArray,System.Int32[],System.Collections.Generic.IList{System.Collections.Generic.ICollection{System.Int32}})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadCoverageFormat(iText.IO.Source.RandomAccessFileOrArray,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadRangeRecord(iText.IO.Source.RandomAccessFileOrArray,System.Collections.Generic.IList{System.Int32})">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadGposValueRecord(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadGposAnchor(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadMarkArray(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadSubstLookupRecords(iText.IO.Source.RandomAccessFileOrArray,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadAnchorArray(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadBaseArray(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Otf.OtfReadCommon.ReadLigatureArray(iText.IO.Font.Otf.OpenTypeFontTableReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.IDENTITY_H">
            <summary>The Unicode encoding with horizontal writing.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.IDENTITY_V">
            <summary>The Unicode encoding with vertical writing.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.CP1250">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.CP1252">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.CP1253">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.CP1257">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.WINANSI">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.MACROMAN">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.SYMBOL">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.ZAPFDINGBATS">
            <summary>A possible encoding.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.UNICODE_BIG">
            <summary>This is the encoding to be used to output text in Unicode.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.UNICODE_BIG_UNMARKED">
            <summary>This is the encoding to be used to output text for Identity-H/V CMaps.</summary>
        </member>
        <member name="F:iText.IO.Font.PdfEncodings.PDF_DOC_ENCODING">
            <summary>
            This is the default encoding to be used for converting Strings into
            bytes and vice versa.
            </summary>
            <remarks>
            This is the default encoding to be used for converting Strings into
            bytes and vice versa. The default encoding is PDF_DOC_ENCODING.
            </remarks>
        </member>
        <member name="M:iText.IO.Font.PdfEncodings.ConvertToBytes(System.String,System.String)">
            <summary>
            Converts a
            <c>String</c>
            to a
            <c>byte</c>
            array according
            to the font's encoding.
            </summary>
            <param name="encoding">the encoding</param>
            <param name="text">
            the
            <c>String</c>
            to be converted
            </param>
            <returns>
            an array of
            <c>byte</c>
            representing the conversion according to the font's encoding
            </returns>
        </member>
        <member name="M:iText.IO.Font.PdfEncodings.ConvertToBytes(System.Char,System.String)">
            <summary>
            Converts a
            <c>String</c>
            to a
            <c>byte</c>
            array according
            to the font's encoding.
            </summary>
            <param name="encoding">the encoding</param>
            <param name="ch">
            the
            <c>char</c>
            to be converted
            </param>
            <returns>
            an array of
            <c>byte</c>
            representing the conversion according to the font's encoding
            </returns>
        </member>
        <member name="M:iText.IO.Font.PdfEncodings.ConvertToString(System.Byte[],System.String)">
            <summary>
            Converts a
            <c>byte</c>
            array to a
            <c>String</c>
            according
            to the some encoding.
            </summary>
            <param name="bytes">the bytes to convert</param>
            <param name="encoding">the encoding</param>
            <returns>
            the converted
            <c>String</c>
            </returns>
        </member>
        <member name="M:iText.IO.Font.PdfEncodings.IsPdfDocEncoding(System.String)">
            <summary>
            Checks is
            <paramref name="text"/>
            only has PDF_DOC_ENCODING characters.
            </summary>
            <param name="text">
            the
            <c>String</c>
            to test
            </param>
            <returns>
            
            <see langword="true"/>
            if only PDF_DOC_ENCODING characters are present
            </returns>
        </member>
        <member name="M:iText.IO.Font.PdfEncodings.AddExtraEncoding(System.String,iText.IO.Font.IExtraEncoding)">
            <summary>Adds an extra encoding.</summary>
            <param name="name">the name of the encoding. The encoding recognition is case insensitive</param>
            <param name="enc">the conversion class</param>
        </member>
        <member name="T:iText.IO.Font.Pfm2afm">
            <summary>Converts a PFM file into an AFM file.</summary>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.#ctor(iText.IO.Source.RandomAccessFileOrArray,System.IO.Stream)">
            <summary>Creates a new instance of Pfm2afm</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.Convert(iText.IO.Source.RandomAccessFileOrArray,System.IO.Stream)">
            <summary>Converts a PFM file into an AFM file.</summary>
            <param name="input">the PFM file</param>
            <param name="output">the AFM file</param>
            <exception cref="T:System.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.ReadString(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.ReadString">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.Openpfm">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.Putheader">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.Putchartab">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Pfm2afm.Putkerntab">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Font.Pfm2afm.Win2PSStd">
            <summary>Translate table from 1004 to psstd.</summary>
            <remarks>
            Translate table from 1004 to psstd.  1004 is an extension of the
            Windows translate table used in PM.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.Pfm2afm.WinChars">
            <summary>Windows character names.</summary>
            <remarks>
            Windows character names.  Give a name to the used locations
            for when the all flag is specified.
            </remarks>
        </member>
        <member name="T:iText.IO.Font.TrueTypeCollection">
            <summary>Use this class for working with true type collection font (*.ttc)</summary>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.#ctor(System.Byte[],System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.#ctor(System.Byte[])">
            <summary>
            Creates a new
            <see cref="T:iText.IO.Font.TrueTypeCollection"/>
            instance by its bytes.
            </summary>
            <param name="ttc">the byte contents of the collection</param>
            <exception cref="T:System.IO.IOException">in case the input in mal-formatted</exception>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.#ctor(System.String,System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.#ctor(System.String)">
            <summary>
            Creates a new
            <see cref="T:iText.IO.Font.TrueTypeCollection"/>
            instance by its file path.
            </summary>
            <param name="ttcPath">the path of the collection</param>
            <exception cref="T:System.IO.IOException">in case the input in mal-formatted</exception>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.GetFontByTccIndex(System.Int32)">
            <summary>method return TrueTypeFont by ttc index</summary>
            <param name="ttcIndex">the index for the TTC font</param>
            <returns>TrueTypeFont</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.GetTTCSize">
            <summary>returns the number of fonts in True Type Collection (file or bytes array)</summary>
            <returns>returns the number of fonts</returns>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.IsCached">
            <summary>
            Indicates if fonts created by the call to
            <see cref="M:iText.IO.Font.TrueTypeCollection.GetFontByTccIndex(System.Int32)"/>
            will be cached or not.
            </summary>
            <returns><code>true</code> if the created fonts will be cached, <code>false</code> otherwise</returns>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.SetCached(System.Boolean)">
            <summary>
            Sets if fonts created by the call to
            <see cref="M:iText.IO.Font.TrueTypeCollection.GetFontByTccIndex(System.Int32)"/>
            will be cached or not.
            </summary>
            <param name="cached"><code>true</code> if the created fonts will be cached, <code>false</code> otherwise</param>
        </member>
        <member name="M:iText.IO.Font.TrueTypeCollection.InitFontSize">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Font.TrueTypeFont.kerning">
            <summary>The map containing the kerning information.</summary>
            <remarks>
            The map containing the kerning information. It represents the content of
            table 'kern'. The key is an <CODE>Integer</CODE> where the top 16 bits
            are the glyph number for the first character and the lower 16 bits are the
            glyph number for the second character. The value is the amount of kerning in
            normalized 1000 units as an <CODE>Integer</CODE>. This value is usually negative.
            </remarks>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.#ctor(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.#ctor(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.#ctor(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.GetKerning(iText.IO.Font.Otf.Glyph,iText.IO.Font.Otf.Glyph)">
            <summary>Gets the kerning between two glyphs.</summary>
            <param name="first">the first glyph</param>
            <param name="second">the second glyph</param>
            <returns>the kerning to be applied</returns>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.GetDirectoryOffset">
            <summary>The offset from the start of the file to the table directory.</summary>
            <remarks>
            The offset from the start of the file to the table directory.
            It is 0 for TTF and may vary for TTC depending on the chosen font.
            </remarks>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.ReadGdefTable">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.ReadGsubTable">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.ReadGposTable">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.InitializeFontProperties">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.GetCodePagesSupported">
            <summary>Gets the code pages supported by the font.</summary>
            <returns>the code pages supported by the font</returns>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFont.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Font.TrueTypeFontSubset">
            <summary>Subsets a True Type font by removing the unneeded glyphs from the font.</summary>
            <author>Paulo Soares</author>
        </member>
        <member name="F:iText.IO.Font.TrueTypeFontSubset.tableDirectory">
            <summary>Contains the location of the several tables.</summary>
            <remarks>
            Contains the location of the several tables. The key is the name of
            the table and the value is an
            <c>int[3]</c>
            where position 0
            is the checksum, position 1 is the offset from the start of the file
            and position 2 is the length of the table.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.TrueTypeFontSubset.rf">
            <summary>The file in use.</summary>
        </member>
        <member name="F:iText.IO.Font.TrueTypeFontSubset.fileName">
            <summary>The file name.</summary>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.#ctor(System.String,iText.IO.Source.RandomAccessFileOrArray,System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Boolean,System.Boolean)">
            <summary>Creates a new TrueTypeFontSubSet</summary>
            <param name="directoryOffset">The offset from the start of the file to the table directory</param>
            <param name="fileName">the file name of the font</param>
            <param name="glyphsUsed">the glyphs used</param>
            <param name="includeCmap">
            
            <see langword="true"/>
            if the table cmap is to be included in the generated font
            </param>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.Process">
            <summary>Does the actual work of subsetting the font.</summary>
            <returns>the subset font</returns>
            <exception cref="T:System.IO.IOException">on error</exception>
            <on>error</on>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.AssembleFont">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.CreateTableDirectory">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.ReadLoca">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.CreateNewGlyphTables">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.FlatGlyphs">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.CheckGlyphComposite(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.TrueTypeFontSubset.ReadStandardString(System.Int32)">
            <summary>
            Reads a
            <c>String</c>
            from the font file as bytes using the Cp1252 encoding.
            </summary>
            <param name="length">the length of bytes to read</param>
            <returns>
            the
            <c>String</c>
            read
            </returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="F:iText.IO.Font.Type1Font.kernPairs">
            <summary>Represents the section KernPairs in the AFM file.</summary>
            <remarks>
            Represents the section KernPairs in the AFM file.
            Key is uni1&lt;&lt;32 + uni2. Value is kerning value.
            </remarks>
        </member>
        <member name="F:iText.IO.Font.Type1Font.PFB_TYPES">
            <summary>Types of records in a PFB file.</summary>
            <remarks>Types of records in a PFB file. ASCII is 1 and BINARY is 2. They have to appear in the PFB file in this sequence.
                </remarks>
        </member>
        <member name="M:iText.IO.Font.Type1Font.CreateStandardFont(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Type1Font.#ctor(System.String,System.String,System.Byte[],System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Type1Font.HasKernPairs">
            <summary>Checks if the font has any kerning pairs.</summary>
            <returns>
            
            <see langword="true"/>
            if the font has any kerning pairs.
            </returns>
        </member>
        <member name="M:iText.IO.Font.Type1Font.SetKerning(System.Int32,System.Int32,System.Int32)">
            <summary>Sets the kerning between two Unicode chars.</summary>
            <param name="first">the first unicode char.</param>
            <param name="second">the second unicode char.</param>
            <param name="kern">the kerning to apply in normalized 1000 units.</param>
            <returns>
            
            <see langword="true"/>
            if the kerning was applied,
            <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:iText.IO.Font.Type1Font.GetGlyph(System.String)">
            <summary>Find glyph by glyph name.</summary>
            <param name="name">Glyph name</param>
            <returns>Glyph instance if found, otherwise null.</returns>
        </member>
        <member name="M:iText.IO.Font.Type1Font.Process">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Type1Parser.#ctor(System.String,System.String,System.Byte[],System.Byte[])">
            <summary>Creates a new Type1 font file.</summary>
            <param name="afm">the AFM file if the input is made with a <CODE>byte</CODE> array</param>
            <param name="pfb">the PFB file if the input is made with a <CODE>byte</CODE> array</param>
            <param name="metricsPath">the name of one of the 14 built-in fonts or the location of an AFM file. The file must end in '.afm'
                </param>
            <the>AFM file is invalid</the>
            <exception cref="T:System.IO.IOException">the AFM file could not be read</exception>
        </member>
        <member name="M:iText.IO.Font.Type1Parser.GetMetricsFile">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Type1Parser.GetPostscriptBinary">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Font.Type1Parser.IsAfmFile(iText.IO.Source.RandomAccessFileOrArray)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Image.ImageData.serialId">
            <summary>a static that is used for attributing a unique id to each image.</summary>
        </member>
        <member name="M:iText.IO.Image.ImageData.CanImageBeInline">
            <summary>Checks if image can be inline</summary>
            <returns>if the image can be inline</returns>
        </member>
        <member name="M:iText.IO.Image.ImageData.LoadData">
            <summary>Load data from URL.</summary>
            <remarks>
            Load data from URL. url must be not null.
            Note, this method doesn't check if data or url is null.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.ImageData.GetSerialId">
            <summary>Creates a new serial id.</summary>
            <returns>the new serialId</returns>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITTG4">
            <summary>Pure two-dimensional encoding (Group 4)</summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITTG3_1D">
            <summary>Pure one-dimensional encoding (Group 3, 1-D)</summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITTG3_2D">
            <summary>Mixed one- and two-dimensional encoding (Group 3, 2-D)</summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITT_BLACKIS1">
            <summary>
            A flag indicating whether 1-bits are to be interpreted as black pixels
            and 0-bits as white pixels,
            </summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITT_ENCODEDBYTEALIGN">
            <summary>
            A flag indicating whether the filter expects extra 0-bits before each
            encoded line so that the line begins on a byte boundary.
            </summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITT_ENDOFLINE">
            <summary>
            A flag indicating whether end-of-line bit patterns are required to be
            present in the encoding.
            </summary>
        </member>
        <member name="F:iText.IO.Image.RawImageData.CCITT_ENDOFBLOCK">
            <summary>
            A flag indicating whether the filter expects the encoded data to be
            terminated by an end-of-block pattern, overriding the Rows parameter.
            </summary>
            <remarks>
            A flag indicating whether the filter expects the encoded data to be
            terminated by an end-of-block pattern, overriding the Rows parameter. The
            use of this flag will set the key /EndOfBlock to false.
            </remarks>
        </member>
        <member name="M:iText.IO.Image.BmpImageData.GetSize">
            <returns>size of the image</returns>
        </member>
        <member name="M:iText.IO.Image.BmpImageData.IsNoHeader">
            <returns>True if the bitmap image does not contain a header</returns>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ProcessImage(iText.IO.Image.ImageData)">
            <summary>Process the passed Image data as a BMP image.</summary>
            <remarks>
            Process the passed Image data as a BMP image.
            Image is loaded and all image attributes are initialized and/or updated
            </remarks>
            <param name="image">the image to process as a BMP image</param>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Process(iText.IO.Image.BmpImageHelper.BmpParameters,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.GetImage(iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadPalette(System.Int32,iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Read1Bit(System.Int32,iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Read4Bit(System.Int32,iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Read8Bit(System.Int32,iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Read24Bit(System.Byte[],iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.Read1632Bit(System.Boolean,iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadRLE8(iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadRLE4(iText.IO.Image.BmpImageHelper.BmpParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadUnsignedByte(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadUnsignedShort(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadShort(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadWord(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadUnsignedInt(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadInt(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadDWord(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.BmpImageHelper.ReadLong(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.DrawingImageFactory.GetImage(System.Drawing.Image,System.Nullable{System.Drawing.Color})">
            <summary>Gets an instance of an Image from a java.awt.Image</summary>
            <param name="image">the java.awt.Image to convert</param>
            <param name="color">if different from <CODE>null</CODE> the transparency pixels are replaced by this color
            	</param>
            <returns>RawImage</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.DrawingImageFactory.GetImage(System.Drawing.Image,System.Nullable{System.Drawing.Color},System.Boolean)">
            <summary>
            Gets an instance of an Image from a System.Drwaing.Image.
            </summary>
            <param name="image">the System.Drawing.Image to convert</param>
            <param name="color">
            if different from null the transparency
            pixels are replaced by this color
            </param>
            <param name="forceBW">if true the image is treated as black and white</param>
            <returns>an object of type ImgRaw</returns>
        </member>
        <member name="M:iText.IO.Image.DrawingImageFactory.GetImage(System.Drawing.Image,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Converts a .NET image to a Native(PNG, JPG, GIF, WMF) image
            </summary>
            <param name="image"></param>
            <param name="?"></param>
            <returns></returns>
        </member>
        <member name="M:iText.IO.Image.GifImageData.LoadData">
            <summary>Load data by URL.</summary>
            <remarks>
            Load data by URL. url must be not null.
            Note, this method doesn't check if data or url is null.
            </remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ProcessImage(iText.IO.Image.GifImageData)">
            <summary>Reads image source and fills GifImage object with parameters (frames, width, height)</summary>
            <param name="image">GifImage</param>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ProcessImage(iText.IO.Image.GifImageData,System.Int32)">
            <summary>Reads image source and fills GifImage object with parameters (frames, width, height)</summary>
            <param name="image">GifImage</param>
            <param name="lastFrameNumber">the last frame of the gif image should be read</param>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.Process(System.IO.Stream,iText.IO.Image.GifImageHelper.GifParameters,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadHeader(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads GIF file header information.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadLSD(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads Logical Screen Descriptor</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadShort(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads next 16-bit value, LSB first</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadBlock(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads next variable length block from input.</summary>
            <returns>number of bytes stored in "buffer"</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadColorTable(System.Int32,iText.IO.Image.GifImageHelper.GifParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadContents(iText.IO.Image.GifImageHelper.GifParameters,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadFrame(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads next frame image</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.DecodeImageData(iText.IO.Image.GifImageHelper.GifParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.ReadGraphicControlExt(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>Reads Graphics Control Extension values</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.GifImageHelper.Skip(iText.IO.Image.GifImageHelper.GifParameters)">
            <summary>
            Skips variable length blocks up to and including
            next zero length block.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Byte[],System.Boolean)">
            <summary>Create an ImageData instance representing the image from the image bytes.</summary>
            <param name="bytes">byte representation of the image.</param>
            <param name="recoverImage">whether to recover from a image error (for TIFF-images)</param>
            <returns>The created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Byte[])">
            <summary>Create an ImageData instance representing the image from the image bytes.</summary>
            <param name="bytes">byte representation of the image.</param>
            <returns>The created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Uri,System.Boolean)">
            <summary>Create an ImageData instance representing the image from the file located at the specified url.</summary>
            <param name="url">location of the image</param>
            <param name="recoverImage">whether to recover from a image error (for TIFF-images)</param>
            <returns>The created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Uri)">
            <summary>Create an ImageData instance representing the image from the file located at the specified url.</summary>
            <param name="url">location of the image</param>
            <returns>The created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.String,System.Boolean)">
            <summary>Create an ImageData instance representing the image from the specified file.</summary>
            <param name="filename">filename of the file containing the image</param>
            <param name="recoverImage">whether to recover from a image error (for TIFF-images)</param>
            <returns>The created ImageData object.</returns>
            <exception cref="!:Java.Net.MalformedURLException"/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.String)">
            <summary>Create an ImageData instance representing the image from the specified file.</summary>
            <param name="filename">filename of the file containing the image</param>
            <returns>The created ImageData object.</returns>
            <exception cref="!:Java.Net.MalformedURLException"/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.Byte[],System.Int32[])">
            <summary>Create an ImageData instance from the passed parameters.</summary>
            <param name="width">width of the image in pixels</param>
            <param name="height">height of the image in pixels</param>
            <param name="reverseBits">whether to reverse the bits stored in data (TIFF images).</param>
            <param name="typeCCITT">Type of CCITT encoding</param>
            <param name="parameters">colour space parameters</param>
            <param name="data">array containing raw image data</param>
            <param name="transparency">array containing transparency information</param>
            <returns>created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32[])">
            <summary>Create an ImageData instance from the passed parameters.</summary>
            <param name="width">width of the image in pixels</param>
            <param name="height">height of the image in pixels</param>
            <param name="components">colour space components</param>
            <param name="bpc">bits per colour.</param>
            <param name="data">array containing raw image data</param>
            <param name="transparency">array containing transparency information</param>
            <returns>created ImageData object.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Drawing.Image,System.Nullable{System.Drawing.Color})">
            <summary>Gets an instance of an Image from a java.awt.Image</summary>
            <param name="image">the java.awt.Image to convert</param>
            <param name="color">if different from <CODE>null</CODE> the transparency pixels are replaced by this color
                </param>
            <returns>RawImage</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.Create(System.Drawing.Image,System.Nullable{System.Drawing.Color},System.Boolean)">
            <summary>Gets an instance of an Image from a java.awt.Image.</summary>
            <param name="image">the <CODE>java.awt.Image</CODE> to convert</param>
            <param name="color">if different from <CODE>null</CODE> the transparency pixels are replaced by this color
                </param>
            <param name="forceBW">if <CODE>true</CODE> the image is treated as black and white</param>
            <returns>RawImage</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateBmp(System.Uri,System.Boolean,System.Int32)">
            <summary>Get a bitmap ImageData instance from the specified url.</summary>
            <param name="url">location of the image.</param>
            <param name="noHeader">Whether the image contains a header.</param>
            <param name="size">size of the image</param>
            <returns>created ImageData.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateBmp(System.Byte[],System.Boolean,System.Int32)">
            <summary>Get a bitmap ImageData instance from the provided bytes.</summary>
            <param name="bytes">array containing the raw image data</param>
            <param name="noHeader">Whether the image contains a header.</param>
            <param name="size">size of the image</param>
            <returns>created ImageData.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGif(System.Byte[])">
            <summary>Return a GifImage object.</summary>
            <remarks>Return a GifImage object. This object cannot be added to a document</remarks>
            <param name="bytes">array containing the raw image data</param>
            <returns>GifImageData instance.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrame(System.Uri,System.Int32)">
            <summary>Returns a specified frame of the gif image</summary>
            <param name="url">url of gif image</param>
            <param name="frame">number of frame to be returned</param>
            <returns>GifImageData instance.</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrame(System.Byte[],System.Int32)">
            <summary>Returns a specified frame of the gif image</summary>
            <param name="bytes">byte array of gif image</param>
            <param name="frame">number of frame to be returned</param>
            <returns/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrames(System.Byte[],System.Int32[])">
            <summary>Returns <CODE>List</CODE> of gif image frames</summary>
            <param name="bytes">byte array of gif image</param>
            <param name="frameNumbers">array of frame numbers of gif image</param>
            <returns/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrames(System.Uri,System.Int32[])">
            <summary>Returns <CODE>List</CODE> of gif image frames</summary>
            <param name="url">url of gif image</param>
            <param name="frameNumbers">array of frame numbers of gif image</param>
            <returns/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrames(System.Byte[])">
            <summary>Returns <CODE>List</CODE> of gif image frames</summary>
            <param name="bytes">byte array of gif image</param>
            <returns>all frames of gif image</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateGifFrames(System.Uri)">
            <summary>Returns <CODE>List</CODE> of gif image frames</summary>
            <param name="url">url of gif image</param>
            <returns>all frames of gif image</returns>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.CreateJpeg(System.Uri)">
            <summary>Create a ImageData instance from a Jpeg image url</summary>
            <param name="url"/>
            <returns/>
        </member>
        <member name="M:iText.IO.Image.ImageDataFactory.IsSupportedType(System.Byte[])">
            <summary>Checks if the type of image (based on first 8 bytes) is supported by factory.
            <br/>
            <br/>
            <b>Note:</b>if this method returns <code>true</code> it doesn't means that <see cref="M:iText.IO.Image.ImageDataFactory.Create(System.Byte[])"/> won't throw exception
            </summary>
            <param name="source">image raw bytes</param>
            <returns><code>true</code> if first eight bytes are recognised by factory as valid image type and <code>false</code> otherwise</returns>
        </member>
        <member name="M:iText.IO.Image.Jbig2ImageData.GetNumberOfPages(System.Byte[])">
            <summary>Gets the number of pages in a JBIG2 image.</summary>
            <param name="bytes">a byte array containing a JBIG2 image</param>
            <returns>the number of pages</returns>
        </member>
        <member name="M:iText.IO.Image.Jbig2ImageData.GetNumberOfPages(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>Gets the number of pages in a JBIG2 image.</summary>
            <param name="raf">
            a
            <c>RandomAccessFileOrArray</c>
            containing a JBIG2 image
            </param>
            <returns>the number of pages</returns>
        </member>
        <member name="M:iText.IO.Image.Jbig2ImageHelper.GetGlobalSegment(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>
            Gets a byte array that can be used as a /JBIG2Globals,
            or null if not applicable to the given jbig2.
            </summary>
            <param name="ra">an random access file or array</param>
            <returns>a byte array</returns>
        </member>
        <member name="M:iText.IO.Image.Jpeg2000ImageHelper.ProcessParameters(iText.IO.Image.Jpeg2000ImageData)">
            <summary>This method checks if the image is a valid JPEG and processes some parameters.</summary>
        </member>
        <member name="M:iText.IO.Image.Jpeg2000ImageHelper.Jp2_read_colr(iText.IO.Image.Jpeg2000ImageHelper.Jpeg2000Box,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.Jpeg2000ImageHelper.Jp2_read_boxhdr(iText.IO.Image.Jpeg2000ImageHelper.Jpeg2000Box,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.Jpeg2000ImageHelper.Cio_read(System.Int32,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.NOT_A_MARKER">
            <summary>This is a type of marker.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.VALID_MARKER">
            <summary>This is a type of marker.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.UNSUPPORTED_MARKER">
            <summary>This is a type of marker.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.NOPARAM_MARKER">
            <summary>This is a type of marker.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.M_APP0">
            <summary>Marker value</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.M_APP2">
            <summary>Marker value</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.M_APPE">
            <summary>Marker value</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.M_APPD">
            <summary>Marker value for Photoshop IRB</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.VALID_MARKERS">
            <summary>Acceptable Jpeg markers.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.UNSUPPORTED_MARKERS">
            <summary>Unsupported Jpeg markers.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.NOPARAM_MARKERS">
            <summary>Jpeg markers without additional parameters.</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.JFIF_ID">
            <summary>sequence that is used in all Jpeg files</summary>
        </member>
        <member name="F:iText.IO.Image.JpegImageHelper.PS_8BIM_RESO">
            <summary>sequence preceding Photoshop resolution data</summary>
        </member>
        <member name="M:iText.IO.Image.JpegImageHelper.ProcessImage(iText.IO.Image.ImageData)">
            <summary>Process the passed Image data as a JPEG image.</summary>
            <remarks>
            Process the passed Image data as a JPEG image.
            Image is loaded and all image attributes are initialized and/or updated.
            </remarks>
            <param name="image">the image to process as a JPEG image</param>
        </member>
        <member name="M:iText.IO.Image.JpegImageHelper.ProcessParameters(System.IO.Stream,System.String,iText.IO.Image.ImageData)">
            <summary>This method checks if the image is a valid JPEG and processes some parameters.</summary>
            <exception cref="T:iText.IO.IOException"/>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.JpegImageHelper.GetShort(System.IO.Stream)">
            <summary>Reads a short from the <CODE>InputStream</CODE>.</summary>
            <param name="jpegStream">the <CODE>InputStream</CODE></param>
            <returns>an int</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Image.JpegImageHelper.Marker(System.Int32)" -->
        <member name="F:iText.IO.Image.PngImageHelper.IHDR">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.PLTE">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.IDAT">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.IEND">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.tRNS">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.pHYs">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.gAMA">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.cHRM">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.sRGB">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.iCCP">
            <summary>A PNG marker.</summary>
        </member>
        <member name="F:iText.IO.Image.PngImageHelper.PNGID">
            <summary>Some PNG specific values.</summary>
        </member>
        <member name="M:iText.IO.Image.PngImageHelper.ProcessPng(System.IO.Stream,iText.IO.Image.PngImageHelper.PngParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.PngImageHelper.ReadPng(System.IO.Stream,iText.IO.Image.PngImageHelper.PngParameters)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.PngImageHelper.GetInt(System.IO.Stream)">
            <summary>Gets an <CODE>int</CODE> from an <CODE>InputStream</CODE>.</summary>
            <param name="pngStream">an <CODE>InputStream</CODE></param>
            <returns>the value of an <CODE>int</CODE></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.PngImageHelper.GetWord(System.IO.Stream)">
            <summary>Gets a <CODE>word</CODE> from an <CODE>InputStream</CODE>.</summary>
            <param name="pngStream">an <CODE>InputStream</CODE></param>
            <returns>the value of an <CODE>int</CODE></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.PngImageHelper.GetString(System.IO.Stream)">
            <summary>Gets a <CODE>String</CODE> from an <CODE>InputStream</CODE>.</summary>
            <param name="pngStream">an <CODE>InputStream</CODE></param>
            <returns>the value of an <CODE>int</CODE></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Image.RawImageHelper.UpdateRawImageParameters(iText.IO.Image.RawImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>Update original image with Raw Image parameters.</summary>
            <param name="width">the exact width of the image</param>
            <param name="height">the exact height of the image</param>
            <param name="components">1,3 or 4 for GrayScale, RGB and CMYK</param>
            <param name="bpc">bits per component. Must be 1,2,4 or 8</param>
            <param name="data">the image data</param>
            <exception cref="T:iText.IO.IOException">on error</exception>
        </member>
        <member name="M:iText.IO.Image.TiffImageData.GetNumberOfPages(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>Gets the number of pages the TIFF document has.</summary>
            <param name="raf">
            a
            <c>RandomAccessFileOrArray</c>
            containing a TIFF image.
            </param>
            <returns>the number of pages.</returns>
        </member>
        <member name="M:iText.IO.Image.TiffImageData.GetNumberOfPages(System.Byte[])">
            <summary>Gets the number of pages the TIFF document has.</summary>
            <param name="bytes">a byte array containing a TIFF image.</param>
            <returns>the number of pages.</returns>
        </member>
        <member name="M:iText.IO.Image.TiffImageHelper.ProcessImage(iText.IO.Image.ImageData)">
            <summary>Processes the ImageData as a TIFF image.</summary>
            <param name="image">image to process.</param>
        </member>
        <member name="M:iText.IO.Image.TiffImageHelper.ProcessExtraSamples(iText.IO.Source.DeflaterOutputStream,iText.IO.Source.DeflaterOutputStream,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.IOException">
            <summary>Exception class for exceptions in io module.</summary>
        </member>
        <member name="F:iText.IO.IOException.obj">
            <summary>Object for more details</summary>
        </member>
        <member name="M:iText.IO.IOException.#ctor(System.String)">
            <summary>Creates a new IOException.</summary>
            <param name="message">the detail message.</param>
        </member>
        <member name="M:iText.IO.IOException.#ctor(System.Exception)">
            <summary>Creates a new IOException.</summary>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
        </member>
        <member name="M:iText.IO.IOException.#ctor(System.String,System.Object)">
            <summary>Creates a new IOException.</summary>
            <param name="message">the detail message.</param>
            <param name="obj">an object for more details.</param>
        </member>
        <member name="M:iText.IO.IOException.#ctor(System.String,System.Exception)">
            <summary>Creates a new IOException.</summary>
            <param name="message">the detail message.</param>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
        </member>
        <member name="M:iText.IO.IOException.#ctor(System.String,System.Exception,System.Object)">
            <summary>Creates a new instance of IOException.</summary>
            <param name="message">the detail message.</param>
            <param name="cause">
            the cause (which is saved for later retrieval by
            <see cref="P:System.Exception.InnerException"/>
            method).
            </param>
            <param name="obj">an object for more details.</param>
        </member>
        <member name="M:iText.IO.IOException.GetMessageParams">
            <summary>Gets additional params for Exception message.</summary>
        </member>
        <member name="M:iText.IO.IOException.SetMessageParams(System.Object[])">
            <summary>Sets additional params for Exception message.</summary>
            <param name="messageParams">additional params.</param>
            <returns>object itself.</returns>
        </member>
        <member name="P:iText.IO.IOException.Message">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:iText.IO.LogMessageConstant">
            <summary>Class containing constants to be used in logging.</summary>
        </member>
        <member name="T:iText.IO.Log.LoggerFactory">
            <summary>
            LoggerFactory can be used to set a logger. The logger should be created by
            implementing <see cref="!:Logger"/>. In the implementation users can choose how they
            log received messages. Added for developers. For some cases it can be handy
            to receive logging statements while developing applications with iText
            </summary>
            <author>redlab_b</author>
        </member>
        <member name="T:iText.IO.Log.NoOpLogger">
            <summary>
            The no-operation logger, it does nothing with the received logging
            statements. And returns false by default for <see cref="M:iText.IO.Log.NoOpLogger.IsDebugEnabled"/>,
            <see cref="M:iText.IO.Log.NoOpLogger.IsErrorEnabled"/>, <see cref="M:iText.IO.Log.NoOpLogger.IsInfoEnabled"/>, <see cref="M:iText.IO.Log.NoOpLogger.IsTraceEnabled"/> and
            <see cref="M:iText.IO.Log.NoOpLogger.IsWarnEnabled"/>.
            </summary>
            <author>redlab_b</author>
        </member>
        <member name="T:iText.IO.Source.ArrayRandomAccessSource">
            <summary>A RandomAccessSource that is based on an underlying byte array</summary>
        </member>
        <member name="T:iText.IO.Source.IRandomAccessSource">
            <summary>Represents an abstract source that bytes can be read from.</summary>
            <remarks>
            Represents an abstract source that bytes can be read from.  This class forms the foundation for all byte input in iText.
            Implementations do not keep track of a current 'position', but rather provide absolute get methods.  Tracking position
            should be handled in classes that use RandomAccessSource internally (via composition).
            </remarks>
        </member>
        <member name="M:iText.IO.Source.IRandomAccessSource.Get(System.Int64)">
            <summary>Gets a byte at the specified position</summary>
            <param name="position">byte position</param>
            <returns>the byte, or -1 if EOF is reached</returns>
            <exception cref="T:System.IO.IOException">in case of any reading error.</exception>
        </member>
        <member name="M:iText.IO.Source.IRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>Read an array of bytes of specified length from the specified position of source to the buffer applying the offset.
                </summary>
            <remarks>
            Read an array of bytes of specified length from the specified position of source to the buffer applying the offset.
            If the number of bytes requested cannot be read, all the possible bytes will be read to the buffer,
            and the number of actually read bytes will be returned.
            </remarks>
            <param name="position">the position in the RandomAccessSource to read from</param>
            <param name="bytes">output buffer</param>
            <param name="off">offset into the output buffer where results will be placed</param>
            <param name="len">the number of bytes to read</param>
            <returns>the number of bytes actually read, or -1 if the file is at EOF</returns>
            <exception cref="T:System.IO.IOException">in case of any I/O error.</exception>
        </member>
        <member name="M:iText.IO.Source.IRandomAccessSource.Length">
            <summary>Gets the length of the source</summary>
            <returns>the length of this source</returns>
        </member>
        <member name="M:iText.IO.Source.IRandomAccessSource.Close">
            <summary>Closes this source.</summary>
            <remarks>Closes this source. The underlying data structure or source (if any) will also be closed</remarks>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.ArrayRandomAccessSource.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.ByteBuffer.Prepend(System.Byte)">
            <summary>
            Fill
            <c>ByteBuffer</c>
            from the end.
            Set byte at
            <c>capacity() - size() - 1</c>
            position.
            </summary>
            <param name="b">
            
            <c>byte</c>
            .
            </param>
            <returns>
            
            <c>ByteBuffer</c>
            .
            </returns>
        </member>
        <member name="M:iText.IO.Source.ByteBuffer.Prepend(System.Byte[])">
            <summary>
            Fill
            <c>ByteBuffer</c>
            from the end.
            Set bytes from
            <c>capacity() - size() - b.length</c>
            position.
            </summary>
            <param name="b">
            
            <c>byte</c>
            .
            </param>
            <returns>
            
            <c>ByteBuffer</c>
            .
            </returns>
        </member>
        <member name="T:System.util.zlib.ZDeflaterOutputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
        <member name="M:iText.IO.Source.GetBufferedRandomAccessSource.#ctor(iText.IO.Source.IRandomAccessSource)">
            <summary>Constructs a new OffsetRandomAccessSource</summary>
            <param name="source">the source</param>
        </member>
        <member name="M:iText.IO.Source.GetBufferedRandomAccessSource.Get(System.Int64)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.GetBufferedRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.GetBufferedRandomAccessSource.Length">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.IO.Source.GetBufferedRandomAccessSource.Close">
            <summary>Does nothing - the underlying source is not closed</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Source.GroupedRandomAccessSource">
            <summary>
            A RandomAccessSource that is based on a set of underlying sources,
            treating the sources as if they were a contiguous block of data.
            </summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.sources">
            <summary>The underlying sources (along with some meta data to quickly determine where each source begins and ends)
                </summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.currentSourceEntry">
            <summary>Cached value to make multiple reads from the same underlying source more efficient</summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.size">
            <summary>Cached size of the underlying channel</summary>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.#ctor(iText.IO.Source.IRandomAccessSource[])">
            <summary>
            Constructs a new
            <see cref="T:iText.IO.Source.GroupedRandomAccessSource"/>
            based on the specified set of sources
            </summary>
            <param name="sources">the sources used to build this group</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.GetStartingSourceIndex(System.Int64)">
            <summary>For a given offset, return the index of the source that contains the specified offset.</summary>
            <remarks>
            For a given offset, return the index of the source that contains the specified offset.
            This is an optimization feature to help optimize the access of the correct source without having to iterate
            through every single source each time.  It is safe to always return 0, in which case the full set of sources
            will be searched.
            Subclasses should override this method if they are able to compute the source index more efficiently
            (for example
            <see cref="!:FileChannelRandomAccessSource"/>
            takes advantage of fixed size page buffers to compute the index)
            </remarks>
            <param name="offset">the offset</param>
            <returns>the index of the input source that contains the specified offset, or 0 if unknown</returns>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.GetSourceEntryForOffset(System.Int64)">
            <summary>
            Returns the SourceEntry that contains the byte at the specified offset
            sourceReleased is called as a notification callback so subclasses can take care of cleanup
            when the source is no longer the active source
            </summary>
            <param name="offset">the offset of the byte to look for</param>
            <returns>the SourceEntry that contains the byte at the specified offset</returns>
            <exception cref="T:System.IO.IOException">if there is a problem with IO (usually the result of the sourceReleased() call)
                </exception>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.SourceReleased(iText.IO.Source.IRandomAccessSource)">
            <summary>Called when a given source is no longer the active source.</summary>
            <remarks>Called when a given source is no longer the active source.  This gives subclasses the abilty to release resources, if appropriate.
                </remarks>
            <param name="source">the source that is no longer the active source</param>
            <exception cref="T:System.IO.IOException">if there are any problems</exception>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.SourceInUse(iText.IO.Source.IRandomAccessSource)">
            <summary>Called when a given source is about to become the active source.</summary>
            <remarks>Called when a given source is about to become the active source.  This gives subclasses the abilty to retrieve resources, if appropriate.
                </remarks>
            <param name="source">the source that is about to become the active source</param>
            <exception cref="T:System.IO.IOException">if there are any problems</exception>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.Get(System.Int64)">
            <summary>
            <inheritDoc/>
            The source that contains the byte at position is retrieved, the correct offset into that source computed, then the value
            from that offset in the underlying source is returned.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.Length">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.Close">
            <summary>
            <inheritDoc/>
            <br/>
            Closes all of the underlying sources.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Source.GroupedRandomAccessSource.SourceEntry">
            <summary>Used to track each source, along with useful meta data</summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.source">
            <summary>The underlying source</summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.firstByte">
            <summary>The first byte (in the coordinates of the GroupedRandomAccessSource) that this source contains</summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.lastByte">
            <summary>The last byte (in the coordinates of the GroupedRandomAccessSource) that this source contains</summary>
        </member>
        <member name="F:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.index">
            <summary>The index of this source in the GroupedRandomAccessSource</summary>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.#ctor(System.Int32,iText.IO.Source.IRandomAccessSource,System.Int64)">
            <summary>Standard constructor</summary>
            <param name="index">the index</param>
            <param name="source">the source</param>
            <param name="offset">the offset of the source in the GroupedRandomAccessSource</param>
        </member>
        <member name="M:iText.IO.Source.GroupedRandomAccessSource.SourceEntry.OffsetN(System.Int64)">
            <summary>Given an absolute offset (in the GroupedRandomAccessSource coordinates), calculate the effective offset in the underlying source
                </summary>
            <param name="absoluteOffset">the offset in the parent GroupedRandomAccessSource</param>
            <returns>the effective offset in the underlying source</returns>
        </member>
        <member name="T:iText.IO.Source.IndependentRandomAccessSource">
            <summary>A RandomAccessSource that is wraps another RandomAccessSource but does not propagate close().</summary>
            <remarks>
            A RandomAccessSource that is wraps another RandomAccessSource but does not propagate close().  This is useful when
            passing a RandomAccessSource to a method that would normally close the source.
            </remarks>
        </member>
        <member name="F:iText.IO.Source.IndependentRandomAccessSource.source">
            <summary>The source</summary>
        </member>
        <member name="M:iText.IO.Source.IndependentRandomAccessSource.#ctor(iText.IO.Source.IRandomAccessSource)">
            <summary>Constructs a new IndependentRandomAccessSource object</summary>
            <param name="source">the source</param>
        </member>
        <member name="M:iText.IO.Source.IndependentRandomAccessSource.Get(System.Int64)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.IndependentRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.IndependentRandomAccessSource.Length">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:iText.IO.Source.IndependentRandomAccessSource.Close">
            <summary>Does nothing - the underlying source is not closed</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.OutputStream`1.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.OutputStream`1.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.OutputStream`1.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.OutputStream`1.Flush">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:iText.IO.Source.PdfTokenizer.closeStream">
            <summary>Streams are closed automatically.</summary>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.#ctor(iText.IO.Source.RandomAccessFileOrArray)">
            <summary>
            Creates a PdfTokenizer for the specified
            <see cref="T:iText.IO.Source.RandomAccessFileOrArray"/>
            .
            The beginning of the file is read to determine the location of the header, and the data source is adjusted
            as necessary to account for any junk that occurs in the byte source before the header
            </summary>
            <param name="file">the source</param>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.Seek(System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ReadFully(System.Byte[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.GetPosition">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.Length">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.Read">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ReadString(System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.GetHeaderOffset">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.CheckPdfHeader">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.CheckFdfHeader">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.GetStartxref">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.NextValidToken">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.NextToken">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.DecodeStringContent(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Resolve escape symbols or hexadecimal symbols.</summary>
            <remarks>
            Resolve escape symbols or hexadecimal symbols.
            <p/>
            NOTE Due to PdfReference 1.7 part 3.2.3 String value contain ASCII characters,
            so we can convert it directly to byte array.
            </remarks>
            <returns>
            byte[] for decrypting or for creating
            <see cref="T:System.String"/>
            .
            </returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.DecodeStringContent(System.Byte[],System.Boolean)">
            <summary>Resolve escape symbols or hexadecimal symbols.</summary>
            <remarks>
            Resolve escape symbols or hexadecimal symbols.
            <p/>
            NOTE Due to PdfReference 1.7 part 3.2.3 String value contain ASCII characters,
            so we can convert it directly to byte array.
            </remarks>
            <returns>
            byte[] for decrypting or for creating
            <see cref="T:System.String"/>
            .
            </returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32)">
            <summary>Is a certain character a whitespace? Currently checks on the following: '0', '9', '10', '12', '13', '32'.
                </summary>
            <remarks>
            Is a certain character a whitespace? Currently checks on the following: '0', '9', '10', '12', '13', '32'.
            <br/>The same as calling
            <see cref="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32,System.Boolean)">isWhiteSpace(ch, true)</see>
            .
            </remarks>
            <param name="ch">int</param>
            <returns>boolean</returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32,System.Boolean)">
            <summary>Checks whether a character is a whitespace.</summary>
            <remarks>Checks whether a character is a whitespace. Currently checks on the following: '0', '9', '10', '12', '13', '32'.
                </remarks>
            <param name="ch">int</param>
            <param name="isWhitespace">boolean</param>
            <returns>boolean</returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ThrowError(System.String,System.Object[])">
            <summary>Helper method to handle content errors.</summary>
            <remarks>
            Helper method to handle content errors. Add file position to
            <c>PdfRuntimeException</c>
            .
            </remarks>
            <param name="error">message.</param>
            <param name="messageParams">error params.</param>
            <wrap>
            error message into
            <c>PdfRuntimeException</c>
            and add position in file.
            </wrap>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.CheckTrailer(iText.IO.Source.ByteBuffer)">
            <summary>
            Checks whether
            <paramref name="line"/>
            equals to 'trailer'.
            </summary>
            <param name="line">for check.</param>
            <returns>true, if line is equals tio 'trailer', otherwise false.</returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ReadLineSegment(iText.IO.Source.ByteBuffer)">
            <summary>Reads data into the provided byte[].</summary>
            <remarks>
            Reads data into the provided byte[]. Checks on leading whitespace.
            See
            <see cref="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32)">isWhiteSpace(int)</see>
            or
            <see cref="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32,System.Boolean)">isWhiteSpace(int, boolean)</see>
            for a list of whitespace characters.
            <br/>The same as calling
            <see cref="M:iText.IO.Source.PdfTokenizer.ReadLineSegment(iText.IO.Source.ByteBuffer,System.Boolean)">readLineSegment(input, true)</see>
            .
            </remarks>
            <param name="buffer">@see ByteBuffer</param>
            <returns>boolean</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ReadLineSegment(iText.IO.Source.ByteBuffer,System.Boolean)">
            <summary>Reads data into the provided byte[].</summary>
            <remarks>
            Reads data into the provided byte[]. Checks on leading whitespace.
            See
            <see cref="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32)">isWhiteSpace(int)</see>
            or
            <see cref="M:iText.IO.Source.PdfTokenizer.IsWhitespace(System.Int32,System.Boolean)">isWhiteSpace(int, boolean)</see>
            for a list of whitespace characters.
            </remarks>
            <param name="buffer">@see ByteBuffer</param>
            <param name="isNullWhitespace">
            boolean to indicate whether '0' is whitespace or not.
            If in doubt, use true or overloaded method
            <see cref="M:iText.IO.Source.PdfTokenizer.ReadLineSegment(iText.IO.Source.ByteBuffer)">readLineSegment(input)</see>
            </param>
            <returns>boolean</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.CheckObjectStart(iText.IO.Source.PdfTokenizer)">
            <summary>Check whether line starts with object declaration.</summary>
            <param name="lineTokenizer">tokenizer, built by single line.</param>
            <returns>object number and generation if check is successful, otherwise - null.</returns>
        </member>
        <member name="M:iText.IO.Source.PdfTokenizer.ReusableRandomAccessSource.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Source.RAFRandomAccessSource">
            <summary>
            A RandomAccessSource that uses a
            <see cref="T:System.IO.FileStream"/>
            as it's source
            Note: Unlike most of the RandomAccessSource implementations, this class is not thread safe
            </summary>
        </member>
        <member name="F:iText.IO.Source.RAFRandomAccessSource.raf">
            <summary>The source</summary>
        </member>
        <member name="F:iText.IO.Source.RAFRandomAccessSource.length">
            <summary>The length of the underling RAF.</summary>
            <remarks>
            The length of the underling RAF.  Note that the length is cached at construction time to avoid the possibility
            of java.io.IOExceptions when reading the length.
            </remarks>
        </member>
        <member name="M:iText.IO.Source.RAFRandomAccessSource.#ctor(System.IO.FileStream)">
            <summary>Creates this object</summary>
            <param name="raf">the source for this RandomAccessSource</param>
            <exception cref="T:System.IO.IOException">if the RAF can't be read</exception>
        </member>
        <member name="M:iText.IO.Source.RAFRandomAccessSource.Get(System.Int64)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RAFRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RAFRandomAccessSource.Length">
            <summary>
            <inheritDoc/>
            Note: the length is determined when the
            <see cref="T:iText.IO.Source.RAFRandomAccessSource"/>
            is constructed.  If the file length changes
            after construction, that change will not be reflected in this call.
            </summary>
        </member>
        <member name="M:iText.IO.Source.RAFRandomAccessSource.Close">
            <summary>Closes the underlying RandomAccessFile</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Source.RandomAccessFileOrArray">
            <summary>Class that is used to unify reading from random access files and arrays.</summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessFileOrArray.plainRandomAccess">
            <summary>When true the file access is not done through a memory mapped file.</summary>
            <remarks>
            When true the file access is not done through a memory mapped file. Use it if the file
            is too big to be mapped in your address space.
            </remarks>
        </member>
        <member name="F:iText.IO.Source.RandomAccessFileOrArray.byteSource">
            <summary>The source that backs this object</summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessFileOrArray.byteSourcePosition">
            <summary>The physical location in the underlying byte source.</summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessFileOrArray.back">
            <summary>the pushed  back byte, if any</summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessFileOrArray.isBack">
            <summary>Whether there is a pushed back byte</summary>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.#ctor(iText.IO.Source.IRandomAccessSource)">
            <summary>Creates a RandomAccessFileOrArray that wraps the specified byte source.</summary>
            <remarks>
            Creates a RandomAccessFileOrArray that wraps the specified byte source.  The byte source will be closed when
            this RandomAccessFileOrArray is closed.
            </remarks>
            <param name="byteSource">the byte source to wrap</param>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.CreateView">
            <summary>Creates an independent view of this object (with it's own file pointer and push back queue).</summary>
            <remarks>
            Creates an independent view of this object (with it's own file pointer and push back queue).  Closing the new object will not close this object.
            Closing this object will have adverse effect on the view.
            </remarks>
            <returns>the new view</returns>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.CreateSourceView">
            <summary>Creates the view of the byte source of this object.</summary>
            <remarks>
            Creates the view of the byte source of this object. Closing the view won't affect this object.
            Closing source will have adverse effect on the view.
            </remarks>
            <returns>the byte source view.</returns>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.PushBack(System.Byte)">
            <summary>Pushes a byte back.</summary>
            <remarks>Pushes a byte back.  The next get() will return this byte instead of the value from the underlying data source
                </remarks>
            <param name="b">the byte to push</param>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Read">
            <summary>Reads a single byte</summary>
            <returns>the byte, or -1 if EOF is reached</returns>
            <exception cref="T:System.IO.IOException">in case of any reading error.</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads the specified amount of bytes to the buffer applying the offset.</summary>
            <param name="b">destination buffer</param>
            <param name="off">offset at which to start storing characters</param>
            <param name="len">maximum number of characters to read</param>
            <returns>the number of bytes actually read or -1 in case of EOF</returns>
            <exception cref="T:System.IO.IOException">in case of any I/O error</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Read(System.Byte[])">
            <summary>Reads the bytes to the buffer.</summary>
            <remarks>Reads the bytes to the buffer. This method will try to read as many bytes as the buffer can hold.
                </remarks>
            <param name="b">the destination buffer</param>
            <returns>the number of bytes actually read</returns>
            <exception cref="T:System.IO.IOException">in</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadFully(System.Byte[])">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadFully(System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Skip(System.Int64)">
            <summary>Make an attempt to skip the specified amount of bytes in source.</summary>
            <remarks>
            Make an attempt to skip the specified amount of bytes in source.
            However it may skip less amount of bytes. Possibly zero.
            </remarks>
            <param name="n">the number of bytes to skip</param>
            <returns>the actual number of bytes skipped</returns>
            <exception cref="T:System.IO.IOException">in case of any I/O error</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.SkipBytes(System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Close">
            <summary>Closes the underlying source.</summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Length">
            <summary>Gets the total amount of bytes in the source.</summary>
            <returns>source's size.</returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.Seek(System.Int64)">
            <summary>Sets the current position in the source to the specified index.</summary>
            <param name="pos">the position to set</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.GetPosition">
            <summary>Gets the current position of the source considering the pushed byte to the source.</summary>
            <returns>
            the index of last read byte in the source in
            or the index of last read byte in source - 1 in case byte was pushed.
            </returns>
            <exception cref="T:System.IO.IOException">in case of any I/O error.</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadBoolean">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadByte">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadUnsignedByte">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadShort">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Source.RandomAccessFileOrArray.ReadShortLE" -->
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadUnsignedShort">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Source.RandomAccessFileOrArray.ReadUnsignedShortLE" -->
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadChar">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Source.RandomAccessFileOrArray.ReadCharLE" -->
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadInt">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Source.RandomAccessFileOrArray.ReadIntLE" -->
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Source.RandomAccessFileOrArray.ReadUnsignedInt" -->
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadUnsignedIntLE">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadLong">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadLongLE">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadFloat">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadFloatLE">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadDouble">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadDoubleLE">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadLine">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessFileOrArray.ReadString(System.Int32,System.String)">
            <summary>
            Reads a
            <c>String</c>
            from the font file as bytes using the given encoding.
            </summary>
            <param name="length">the length of bytes to read</param>
            <param name="encoding">the given encoding</param>
            <returns>
            the
            <c>String</c>
            read
            </returns>
            <exception cref="T:System.IO.IOException">the font file could not be read</exception>
        </member>
        <member name="T:iText.IO.Source.RandomAccessSourceFactory">
            <summary>
            Factory to create
            <see cref="!:RandomAccessSource"/>
            objects based on various types of sources
            </summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessSourceFactory.forceRead">
            <summary>Whether the full content of the source should be read into memory at construction
            	</summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessSourceFactory.usePlainRandomAccess">
            <summary>
            Whether
            <see cref="T:System.IO.FileStream"/>
            should be used instead of a
            <see cref="!:java.nio.channels.FileChannel"/>
            , where applicable
            </summary>
        </member>
        <member name="F:iText.IO.Source.RandomAccessSourceFactory.exclusivelyLockFile">
            <summary>Whether the underlying file should have a RW lock on it or just an R lock
            	</summary>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.#ctor">
            <summary>Creates a factory that will give preference to accessing the underling data source using memory mapped files
            	</summary>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.SetForceRead(System.Boolean)">
            <summary>Determines whether the full content of the source will be read into memory
            	</summary>
            <param name="forceRead">true if the full content will be read, false otherwise</param>
            <returns>this object (this allows chaining of method calls)</returns>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.SetUsePlainRandomAccess(System.Boolean)">
            <summary>
            Determines whether
            <see cref="T:System.IO.FileStream"/>
            should be used as the primary data access mechanism
            </summary>
            <param name="usePlainRandomAccess">
            whether
            <see cref="T:System.IO.FileStream"/>
            should be used as the primary data access mechanism
            </param>
            <returns>this object (this allows chaining of method calls)</returns>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateSource(System.Byte[])">
            <summary>
            Creates a
            <see cref="!:RandomAccessSource"/>
            based on a byte array
            </summary>
            <param name="data">the byte array</param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateSource(System.IO.FileStream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateSource(System.Uri)">
            <summary>
            Creates a
            <see cref="!:RandomAccessSource"/>
            based on a URL.  The data available at the URL is read into memory and used
            as the source for the
            <see cref="!:RandomAccessSource"/>
            </summary>
            <param name="url">the url to read from</param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateSource(System.IO.Stream)">
            <summary>
            Creates a
            <see cref="!:RandomAccessSource"/>
            based on an
            <see cref="T:System.IO.Stream"/>
            .  The full content of the InputStream is read into memory and used
            as the source for the
            <see cref="!:RandomAccessSource"/>
            </summary>
            <param name="inputStream">the stream to read from</param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateBestSource(System.String)">
            <summary>
            Creates a
            <see cref="!:RandomAccessSource"/>
            based on a filename string.
            If the filename describes a URL, a URL based source is created
            If the filename describes a file on disk, the contents may be read into memory (if
            <c>forceRead</c>
            is true),
            opened using memory mapped file channel (if usePlainRandomAccess is false), or
            opened using
            <see cref="T:System.IO.FileStream"/>
            access (if usePlainRandomAccess is true)
            This call will automatically fail over to using
            <see cref="T:System.IO.FileStream"/>
            if the memory map operation fails
            </summary>
            <param name="filename">
            the name of the file or resource to create the
            <see cref="!:RandomAccessSource"/>
            for
            </param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateRanged(iText.IO.Source.IRandomAccessSource,System.Int64[])">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateByReadingToMemory(System.String)">
            <summary>
            Creates a new
            <see cref="!:RandomAccessSource"/>
            by reading the specified file/resource into memory
            </summary>
            <param name="filename">the name of the resource to read</param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
            <exception cref="T:System.IO.IOException">if reading the underling file or stream fails
            	</exception>
        </member>
        <member name="M:iText.IO.Source.RandomAccessSourceFactory.CreateByReadingToMemory(System.IO.Stream)">
            <summary>
            Creates a new
            <see cref="!:RandomAccessSource"/>
            by reading the specified file/resource into memory
            </summary>
            <param name="stream">the name of the resource to read</param>
            <returns>
            the newly created
            <see cref="!:RandomAccessSource"/>
            </returns>
            <exception cref="T:System.IO.IOException">if reading the underling file or stream fails
            	</exception>
        </member>
        <member name="T:iText.IO.Source.RASInputStream">
            <summary>
            An input stream that uses a
            <see cref="!:RandomAccessSource"/>
            as
            its underlying source.
            </summary>
        </member>
        <member name="F:iText.IO.Source.RASInputStream.source">
            <summary>The source.</summary>
        </member>
        <member name="F:iText.IO.Source.RASInputStream.position">
            <summary>The current position in the source.</summary>
        </member>
        <member name="M:iText.IO.Source.RASInputStream.#ctor(iText.IO.Source.IRandomAccessSource)">
            <summary>Creates an input stream based on the source.</summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:iText.IO.Source.RASInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.RASInputStream.ReadByte">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.ThreadSafeRandomAccessSource.Get(System.Int64)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.ThreadSafeRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.ThreadSafeRandomAccessSource.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Source.WindowRandomAccessSource">
            <summary>
            A RandomAccessSource that wraps another RandomAccessSource and provides a window of it at a specific offset and over
            a specific length.
            </summary>
            <remarks>
            A RandomAccessSource that wraps another RandomAccessSource and provides a window of it at a specific offset and over
            a specific length.  Position 0 becomes the offset position in the underlying source.
            </remarks>
        </member>
        <member name="F:iText.IO.Source.WindowRandomAccessSource.source">
            <summary>The source</summary>
        </member>
        <member name="F:iText.IO.Source.WindowRandomAccessSource.offset">
            <summary>The amount to offset the source by</summary>
        </member>
        <member name="F:iText.IO.Source.WindowRandomAccessSource.length">
            <summary>The length</summary>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.#ctor(iText.IO.Source.IRandomAccessSource,System.Int64)">
            <summary>Constructs a new OffsetRandomAccessSource that extends to the end of the underlying source</summary>
            <param name="source">the source</param>
            <param name="offset">the amount of the offset to use</param>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.#ctor(iText.IO.Source.IRandomAccessSource,System.Int64,System.Int64)">
            <summary>Constructs a new OffsetRandomAccessSource with an explicit length</summary>
            <param name="source">the source</param>
            <param name="offset">the amount of the offset to use</param>
            <param name="length">the number of bytes to be included in this RAS</param>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.Get(System.Int64)">
            <summary>
            <inheritDoc/>
            Note that the position will be adjusted to read from the corrected location in the underlying source
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.Get(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <inheritDoc/>
            Note that the position will be adjusted to read from the corrected location in the underlying source
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.Length">
            <summary>
            <inheritDoc/>
            Note that the length will be adjusted to read from the corrected location in the underlying source
            </summary>
        </member>
        <member name="M:iText.IO.Source.WindowRandomAccessSource.Close">
            <summary><inheritDoc/></summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Util.ArrayUtil">
            <summary>This file is a helper class for internal usage only.</summary>
            <remarks>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </remarks>
        </member>
        <member name="T:iText.IO.Util.DateTimeUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="T:iText.IO.Util.DecimalFormatUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="T:iText.IO.Util.EncodingUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.EncodingUtil.ConvertToBytes(System.Char[],System.String)">
            <exception cref="!:java.nio.charset.CharacterCodingException"/>
        </member>
        <member name="T:iText.IO.Util.FileUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.FileUtil.CreatePrintWriter(System.IO.Stream,System.String)">
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="T:iText.IO.Util.FilterReader">
            <summary>
            Abstract class for reading filtered character streams.
            The abstract class <code>FilterReader</code> itself
            provides default methods that pass all requests to
            the contained stream. Subclasses of <code>FilterReader</code>
            should override some of these methods and may also provide
            additional methods and fields.
            
            @author      Mark Reinhold
            @since       JDK1.1
            </summary>
        </member>
        <member name="M:iText.IO.Util.FilterReader.Read">
            <summary>
            Reads a single character.
            </summary>
        </member>
        <member name="M:iText.IO.Util.FilterReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads characters into a portion of an array.
            </summary>
        </member>
        <member name="T:iText.IO.Util.FilterUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.FilterUtil.FlateDecode(System.Byte[],System.Boolean)">
            <summary>A helper to FlateDecode.</summary>
            <param name="input">the input data</param>
            <param name="strict">
            <CODE>true</CODE> to read a correct stream. <CODE>false</CODE>
            to try to read a corrupted stream
            </param>
            <returns>the decoded data</returns>
        </member>
        <member name="M:iText.IO.Util.FilterUtil.FlateDecode(System.Byte[])">
            <summary>Decodes a stream that has the FlateDecode filter.</summary>
            <param name="input">the input data</param>
            <returns>the decoded data</returns>
        </member>
        <member name="M:iText.IO.Util.FilterUtil.InflateData(System.Byte[],System.Byte[])">
            <summary>
            This method provides support for general purpose decompression using the
            popular ZLIB compression library.
            </summary>
            <param name="deflated">the input data bytes</param>
            <param name="inflated">the buffer for the uncompressed data</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Util.HashCode" -->
        <member name="F:iText.IO.Util.HashCode.EMPTY_HASH_CODE">
            <summary>The hashCode value before any data is appended, equals to 1.</summary>
            <seealso cref="!:System.Collections.IList&lt;E&gt;.GetHashCode()"/>
        </member>
        <member name="M:iText.IO.Util.HashCode.GetHashCode">
            <summary>Returns accumulated hashCode</summary>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Boolean)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Int64)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Single)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Double)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Object)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Combine(System.Int32,System.Int32)">
            <summary>Combines hashCode of previous elements sequence and value's hashCode.</summary>
            <param name="hashCode">previous hashCode value</param>
            <param name="value">new element</param>
            <returns>combined hashCode</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Int32)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Int64)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Single)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Double)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Boolean)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="M:iText.IO.Util.HashCode.Append(System.Object)">
            <summary>Appends value's hashCode to the current hashCode.</summary>
            <param name="value">new element</param>
            <returns>this</returns>
        </member>
        <member name="T:iText.IO.Util.IanaEncodings">
            Translates a IANA encoding name to a Java encoding.
        </member>
        <member name="F:iText.IO.Util.IanaEncodings.map">
            The object that maps IANA to Java encodings. 
        </member>
        <!-- Badly formed XML comment ignored for member "T:iText.IO.Util.IntHashtable" -->
        <member name="F:iText.IO.Util.IntHashtable.table">
            <summary>The hash table data.</summary>
        </member>
        <member name="F:iText.IO.Util.IntHashtable.count">
            <summary>The total number of entries in the hash table.</summary>
        </member>
        <member name="F:iText.IO.Util.IntHashtable.threshold">
            <summary>The table is rehashed when its size exceeds this threshold.</summary>
            <remarks>
            The table is rehashed when its size exceeds this threshold.  (The
            value of this field is (int)(capacity * loadFactor).)
            </remarks>
            <serial/>
        </member>
        <member name="F:iText.IO.Util.IntHashtable.loadFactor">
            <summary>The load factor for the hashtable.</summary>
            <serial/>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.#ctor">
            <summary>
            <p>Constructs a new, empty hashtable with a default capacity and load
            factor, which is <code>20</code> and <code>0.75</code> respectively.</p>
            </summary>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.#ctor(System.Int32)">
            <summary>
            <p>Constructs a new, empty hashtable with the specified initial capacity
            and default load factor, which is <code>0.75</code>.</p>
            </summary>
            <param name="initialCapacity">the initial capacity of the hashtable.</param>
            <exception cref="T:System.ArgumentException">
            if the initial capacity is less
            than zero.
            </exception>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.#ctor(System.Int32,System.Single)">
            <summary>
            <p>Constructs a new, empty hashtable with the specified initial
            capacity and the specified load factor.</p>
            </summary>
            <param name="initialCapacity">the initial capacity of the hashtable.</param>
            <param name="loadFactor">the load factor of the hashtable.</param>
            <exception cref="T:System.ArgumentException">
            if the initial capacity is less
            than zero, or if the load factor is nonpositive.
            </exception>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Size">
            <summary><p>Returns the number of keys in this hashtable.</p></summary>
            <returns>the number of keys in this hashtable.</returns>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.IsEmpty">
            <summary><p>Tests if this hashtable maps no keys to values.</p></summary>
            <returns>
            <code>true</code> if this hashtable maps no keys to values;
            <code>false</code> otherwise.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Util.IntHashtable.Contains(System.Int32)" -->
        <member name="M:iText.IO.Util.IntHashtable.ContainsValue(System.Int32)">
            <summary>
            <p>Returns <code>true</code> if this HashMap maps one or more keys
            to this value.</p>
            <p>Note that this method is identical in functionality to contains
            (which predates the Map interface).</p>
            </summary>
            <param name="value">value whose presence in this HashMap is to be tested.</param>
            <returns>boolean <code>true</code> if the value is contained</returns>
            <seealso cref="!:System.Collections.IDictionary&lt;K, V&gt;"/>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.ContainsKey(System.Int32)">
            <summary><p>Tests if the specified int is a key in this hashtable.</p></summary>
            <param name="key">possible key.</param>
            <returns>
            <code>true</code> if and only if the specified int is a
            key in this hashtable, as determined by the <tt>equals</tt>
            method; <code>false</code> otherwise.
            </returns>
            <seealso cref="M:iText.IO.Util.IntHashtable.Contains(System.Int32)"/>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Get(System.Int32)">
            <summary><p>Returns the value to which the specified key is mapped in this map.</p></summary>
            <param name="key">a key in the hashtable.</param>
            <returns>
            the value to which the key is mapped in this hashtable;
            0 if the key is not mapped to any value in
            this hashtable.
            </returns>
            <seealso cref="M:iText.IO.Util.IntHashtable.Put(System.Int32,System.Int32)"/>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Rehash">
            <summary>
            <p>Increases the capacity of and internally reorganizes this
            hashtable, in order to accommodate and access its entries more
            efficiently.</p>
            <p>This method is called automatically when the number of keys
            in the hashtable exceeds this hashtable's capacity and load
            factor.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Util.IntHashtable.Put(System.Int32,System.Int32)" -->
        <member name="M:iText.IO.Util.IntHashtable.Remove(System.Int32)">
            <summary>
            <p>Removes the key (and its corresponding value) from this
            hashtable.</p>
            <p>This method does nothing if the key is not present in the
            hashtable.</p>
            </summary>
            <param name="key">the key that needs to be removed.</param>
            <returns>
            the value to which the key had been mapped in this hashtable,
            or <code>null</code> if the key did not have a mapping.
            </returns>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Clear">
            <summary><p>Clears this hashtable so that it contains no keys.</p></summary>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Clone">
            <exception cref="!:Java.Lang.CloneNotSupportedException"/>
        </member>
        <member name="T:iText.IO.Util.IntHashtable.Entry">
            <summary>
            <p>Innerclass that acts as a datastructure to create a new entry in the
            table.</p>
            </summary>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Entry.#ctor(System.Int32,System.Int32,iText.IO.Util.IntHashtable.Entry)">
            <summary><p>Create a new entry with the given values.</p></summary>
            <param name="key">The key used to enter this in the table</param>
            <param name="value">The value for this key</param>
            <param name="next">A reference to the next entry in the table</param>
        </member>
        <member name="M:iText.IO.Util.IntHashtable.Entry.Clone">
            <exception cref="!:Java.Lang.CloneNotSupportedException"/>
        </member>
        <member name="T:iText.IO.Util.JavaCollectionsUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="T:iText.IO.Util.JavaUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="T:iText.IO.Util.Properties">
            <summary>
            Summary description for Properties.
            </summary>
        </member>
        <member name="T:iText.IO.Util.PushbackReader">
            <summary>
            A character-stream reader that allows characters to be pushed back into the
            stream.
            
            @author      Mark Reinhold
            @since       JDK1.1
            </summary>
        </member>
        <member name="F:iText.IO.Util.PushbackReader._buf">
            <summary>
            Pushback buffer </summary>
        </member>
        <member name="F:iText.IO.Util.PushbackReader._pos">
            <summary>
            Current position in buffer </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:iText.IO.Util.PushbackReader.#ctor(System.IO.TextReader,System.Int32)" -->
        <member name="M:iText.IO.Util.PushbackReader.#ctor(System.IO.TextReader)">
            <summary>
            Creates a new pushback reader with a one-character pushback buffer.
            </summary>
            <param name="in">  The reader from which characters will be read </param>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.EnsureOpen">
            <summary>
            Checks to make sure that the stream has not been closed. </summary>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Read">
            <summary>
            Reads a single character.
            </summary>
            <returns>     The character read, or -1 if the end of the stream has been
                        reached
            </returns>
            <exception cref="T:iText.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads characters into a portion of an array.
            </summary>
            <param name="cbuf">  Destination buffer </param>
            <param name="off">   Offset at which to start writing characters </param>
            <param name="len">   Maximum number of characters to read
            </param>
            <returns>     The number of characters read, or -1 if the end of the
                        stream has been reached
            </returns>
            <exception cref="T:iText.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Unread(System.Int32)">
            <summary>
            Pushes back a single character by copying it to the front of the
            pushback buffer. After this method returns, the next character to be read
            will have the value <code>(char)c</code>.
            </summary>
            <param name="c">  The int value representing a character to be pushed back
            </param>
            <exception cref="T:iText.IO.IOException">  If the pushback buffer is full,
                                     or if some other I/O error occurs </exception>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Unread(System.Char[],System.Int32,System.Int32)">
            <summary>
            Pushes back a portion of an array of characters by copying it to the
            front of the pushback buffer.  After this method returns, the next
            character to be read will have the value <code>cbuf[off]</code>, the
            character after that will have the value <code>cbuf[off+1]</code>, and
            so forth.
            </summary>
            <param name="cbuf">  Character array </param>
            <param name="off">   Offset of first character to push back </param>
            <param name="len">   Number of characters to push back
            </param>
            <exception cref="T:iText.IO.IOException">  If there is insufficient room in the pushback
                                     buffer, or if some other I/O error occurs </exception>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Unread(System.Char[])">
            <summary>
            Pushes back an array of characters by copying it to the front of the
            pushback buffer.  After this method returns, the next character to be
            read will have the value <code>cbuf[0]</code>, the character after that
            will have the value <code>cbuf[1]</code>, and so forth.
            </summary>
            <param name="cbuf">  Character array to push back
            </param>
            <exception cref="T:iText.IO.IOException">  If there is insufficient room in the pushback
                                     buffer, or if some other I/O error occurs </exception>
        </member>
        <member name="M:iText.IO.Util.PushbackReader.Dispose(System.Boolean)">
            <summary>
            Closes the stream and releases any system resources associated with
            it. Once the stream has been closed, further read(),
            unread(), ready(), or skip() invocations will throw an IOException.
            Closing a previously closed stream has no effect.
            </summary>
            <exception cref="T:iText.IO.IOException">  If an I/O error occurs </exception>
        </member>
        <member name="T:iText.IO.Util.ResourceUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.ResourceUtil.GetResourceStream(System.String)">
            <summary>Gets the resource's inputstream.</summary>
            <param name="key">the full name of the resource.</param>
            <returns>
            the
            <c>InputStream</c>
            to get the resource or
            <see langword="null"/>
            if not found.
            </returns>
        </member>
        <member name="T:iText.IO.Util.SortUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.SortUtil.MergeSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            
            </summary>
            <param name="from">the index of the first element, inclusive, to be sorted</param>
            <param name="to">the index of the last element, exclusive, to be sorted</param>
        </member>
        <member name="T:iText.IO.Util.StreamUtil">
            <summary>This file is a helper class for internal usage only.</summary>
            <remarks>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </remarks>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.Skip(System.IO.Stream,System.Int64)">
            <summary>
            This method is an alternative for the
            <c>InputStream.skip()</c>
            -method that doesn't seem to work properly for big values of
            <paramref name="size"/>
            .
            </summary>
            <param name="stream">
            the
            <c>InputStream</c>
            </param>
            <param name="size">the number of bytes to skip</param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.CreateEscapedString(System.Byte[])">
            <summary>
            Escapes a
            <c>byte</c>
            array according to the PDF conventions.
            </summary>
            <param name="bytes">
            the
            <c>byte</c>
            array to escape
            </param>
            <returns>
            an escaped
            <c>byte</c>
            array
            </returns>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.WriteEscapedString(System.IO.Stream,System.Byte[])">
            <summary>
            Escapes a
            <c>byte</c>
            array according to the PDF conventions.
            </summary>
            <param name="outputStream">
            the
            <c>OutputStream</c>
            an escaped
            <c>byte</c>
            array write to.
            </param>
            <param name="bytes">
            the
            <c>byte</c>
            &gt; array to escape.
            </param>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.TransferBytes(System.IO.Stream,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.TransferBytes(iText.IO.Source.RandomAccessFileOrArray,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.InputStreamToArray(System.IO.Stream)">
            <summary>Reads the full content of a stream and returns them in a byte array</summary>
            <param name="stream">the stream to read</param>
            <returns>a byte array containing all of the bytes from the stream</returns>
            <exception cref="T:System.IO.IOException">if there is a problem reading from the input stream</exception>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.CopyBytes(iText.IO.Source.IRandomAccessSource,System.Int64,System.Int64,System.IO.Stream)">
            <summary>
            Copy bytes from the
            <c>RandomAccessSource</c>
            to
            <c>OutputStream</c>
            .
            </summary>
            <param name="source">
            the
            <c>RandomAccessSource</c>
            copy from.
            </param>
            <param name="start">start position of source copy from.</param>
            <param name="length">length copy to.</param>
            <param name="output">
            the
            <c>OutputStream</c>
            copy to.
            </param>
            <exception cref="T:System.IO.IOException">on error.</exception>
        </member>
        <member name="M:iText.IO.Util.StreamUtil.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads
            <paramref name="len"/>
            bytes from an input stream.
            </summary>
            <param name="b">the buffer into which the data is read.</param>
            <param name="off">an int specifying the offset into the data.</param>
            <param name="len">an int specifying the number of bytes to read.</param>
            <exception>
            EOFException
            if this stream reaches the end before reading all the bytes.
            </exception>
            <exception>
            IOException
            if an I/O error occurs.
            </exception>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Util.StringUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="T:iText.IO.Util.SystemUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.SystemUtil.GetEnvironmentVariable(System.String)">
            <summary>
            Gets environment variable with given name.
            </summary>
            <param name="name">the name of environment variable.</param>
            <returns>variable value or null if there is no such.</returns>
        </member>
        <member name="M:iText.IO.Util.SystemUtil.RunProcessAndWait(System.String,System.String)">
            <exception cref="T:System.IO.IOException"/>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:iText.IO.Util.SystemUtil.PrintProcessOutput(System.Diagnostics.Process)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:iText.IO.Util.TextUtil">
            <summary>This file is a helper class for internal usage only.</summary>
            <remarks>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </remarks>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsSurrogateHigh(System.Char)">
            <summary>
            Check if the value of a character belongs to a certain interval
            that indicates it's the higher part of a surrogate pair.
            </summary>
            <param name="c">the character</param>
            <returns>true if the character belongs to the interval</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsSurrogateLow(System.Char)">
            <summary>
            Check if the value of a character belongs to a certain interval
            that indicates it's the lower part of a surrogate pair.
            </summary>
            <param name="c">the character</param>
            <returns>true if the character belongs to the interval</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsSurrogatePair(System.String,System.Int32)">
            <summary>
            Checks if two subsequent characters in a String are
            are the higher and the lower character in a surrogate
            pair (and therefore eligible for conversion to a UTF 32 character).
            </summary>
            <param name="text">the String with the high and low surrogate characters</param>
            <param name="idx">the index of the 'high' character in the pair</param>
            <returns>true if the characters are surrogate pairs</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsSurrogatePair(System.Char[],System.Int32)">
            <summary>
            Checks if two subsequent characters in a character array are
            are the higher and the lower character in a surrogate
            pair (and therefore eligible for conversion to a UTF 32 character).
            </summary>
            <param name="text">the character array with the high and low surrogate characters</param>
            <param name="idx">the index of the 'high' character in the pair</param>
            <returns>true if the characters are surrogate pairs</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertToUtf32(System.Char,System.Char)">
            <summary>
            Returns the code point of a UTF32 character corresponding with
            a high and a low surrogate value.
            </summary>
            <param name="highSurrogate">the high surrogate value</param>
            <param name="lowSurrogate">the low surrogate value</param>
            <returns>a code point value</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertToUtf32(System.Char[],System.Int32)">
            <summary>Converts a unicode character in a character array to a UTF 32 code point value.</summary>
            <param name="text">a character array that has the unicode character(s)</param>
            <param name="idx">the index of the 'high' character</param>
            <returns>the code point value</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertToUtf32(System.String,System.Int32)">
            <summary>Converts a unicode character in a String to a UTF32 code point value</summary>
            <param name="text">a String that has the unicode character(s)</param>
            <param name="idx">the index of the 'high' character</param>
            <returns>the codepoint value</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertFromUtf32(System.Int32)">
            <summary>Converts a UTF32 code point value to a String with the corresponding character(s).</summary>
            <param name="codePoint">a Unicode value</param>
            <returns>the corresponding characters in a String</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertFromUtf32(System.Int32[],System.Int32,System.Int32)">
            <summary>
            /
            Converts a UTF32 code point sequence to a String with the corresponding character(s).
            </summary>
            <param name="text">a Unicode text sequence</param>
            <param name="startPos">start position of text to convert, inclusive</param>
            <param name="endPos">end position of txt to convert, exclusive</param>
            <returns>the corresponding characters in a String</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.ConvertFromUtf32ToCharArray(System.Int32)">
            <summary>Converts a UTF32 code point value to a char array with the corresponding character(s).</summary>
            <param name="codePoint">a Unicode value</param>
            <returns>the corresponding characters in a char arrat</returns>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsIdentifierIgnorable(System.Int32)">
            <summary>
            Determines if the specified character (Unicode code point) should be regarded
            as an ignorable character in a Java identifier or a Unicode identifier.
            </summary>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsNewLine(iText.IO.Font.Otf.Glyph)">
            <summary>
            Determines if represented Glyph is '\n' or '\r' character.
            </summary>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsSpaceOrWhitespace(iText.IO.Font.Otf.Glyph)">
            <summary>
            Determines if represented Glyph is space or whitespace character.
            </summary>
        </member>
        <member name="M:iText.IO.Util.TextUtil.IsUni0020(iText.IO.Font.Otf.Glyph)">
            <summary>
            Determines if represented Glyph is ' ' (SPACE) character.
            </summary>
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.COMMON">
            Unicode script "Common".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LATIN">
            Unicode script "Latin".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GREEK">
            Unicode script "Greek".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CYRILLIC">
            Unicode script "Cyrillic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.ARMENIAN">
            Unicode script "Armenian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.HEBREW">
            Unicode script "Hebrew".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.ARABIC">
            Unicode script "Arabic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SYRIAC">
            Unicode script "Syriac".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.THAANA">
            Unicode script "Thaana".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.DEVANAGARI">
            Unicode script "Devanagari".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BENGALI">
            Unicode script "Bengali".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GURMUKHI">
            Unicode script "Gurmukhi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GUJARATI">
            Unicode script "Gujarati".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.ORIYA">
            Unicode script "Oriya".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAMIL">
            Unicode script "Tamil".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TELUGU">
            Unicode script "Telugu".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KANNADA">
            Unicode script "Kannada".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MALAYALAM">
            Unicode script "Malayalam".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SINHALA">
            Unicode script "Sinhala".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.THAI">
            Unicode script "Thai".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LAO">
            Unicode script "Lao".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TIBETAN">
            Unicode script "Tibetan".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MYANMAR">
            Unicode script "Myanmar".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GEORGIAN">
            Unicode script "Georgian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.HANGUL">
            Unicode script "Hangul".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.ETHIOPIC">
            Unicode script "Ethiopic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CHEROKEE">
            Unicode script "Cherokee".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CANADIAN_ABORIGINAL">
            Unicode script "Canadian_Aboriginal".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OGHAM">
            Unicode script "Ogham".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.RUNIC">
            Unicode script "Runic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KHMER">
            Unicode script "Khmer".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MONGOLIAN">
            Unicode script "Mongolian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.HIRAGANA">
            Unicode script "Hiragana".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KATAKANA">
            Unicode script "Katakana".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BOPOMOFO">
            Unicode script "Bopomofo".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.HAN">
            Unicode script "Han".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.YI">
            Unicode script "Yi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OLD_ITALIC">
            Unicode script "Old_Italic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GOTHIC">
            Unicode script "Gothic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.DESERET">
            Unicode script "Deseret".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.INHERITED">
            Unicode script "Inherited".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAGALOG">
            Unicode script "Tagalog".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.HANUNOO">
            Unicode script "Hanunoo".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BUHID">
            Unicode script "Buhid".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAGBANWA">
            Unicode script "Tagbanwa".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LIMBU">
            Unicode script "Limbu".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAI_LE">
            Unicode script "Tai_Le".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LINEAR_B">
            Unicode script "Linear_B".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.UGARITIC">
            Unicode script "Ugaritic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SHAVIAN">
            Unicode script "Shavian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OSMANYA">
            Unicode script "Osmanya".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CYPRIOT">
            Unicode script "Cypriot".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BRAILLE">
            Unicode script "Braille".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BUGINESE">
            Unicode script "Buginese".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.COPTIC">
            Unicode script "Coptic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.NEW_TAI_LUE">
            Unicode script "New_Tai_Lue".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.GLAGOLITIC">
            Unicode script "Glagolitic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TIFINAGH">
            Unicode script "Tifinagh".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SYLOTI_NAGRI">
            Unicode script "Syloti_Nagri".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OLD_PERSIAN">
            Unicode script "Old_Persian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KHAROSHTHI">
            Unicode script "Kharoshthi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BALINESE">
            Unicode script "Balinese".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CUNEIFORM">
            Unicode script "Cuneiform".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.PHOENICIAN">
            Unicode script "Phoenician".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.PHAGS_PA">
            Unicode script "Phags_Pa".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.NKO">
            Unicode script "Nko".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SUNDANESE">
            Unicode script "Sundanese".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BATAK">
            Unicode script "Batak".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LEPCHA">
            Unicode script "Lepcha".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OL_CHIKI">
            Unicode script "Ol_Chiki".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.VAI">
            Unicode script "Vai".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SAURASHTRA">
            Unicode script "Saurashtra".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KAYAH_LI">
            Unicode script "Kayah_Li".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.REJANG">
            Unicode script "Rejang".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LYCIAN">
            Unicode script "Lycian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CARIAN">
            Unicode script "Carian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LYDIAN">
            Unicode script "Lydian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CHAM">
            Unicode script "Cham".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAI_THAM">
            Unicode script "Tai_Tham".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAI_VIET">
            Unicode script "Tai_Viet".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.AVESTAN">
            Unicode script "Avestan".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.EGYPTIAN_HIEROGLYPHS">
            Unicode script "Egyptian_Hieroglyphs".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SAMARITAN">
            Unicode script "Samaritan".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MANDAIC">
            Unicode script "Mandaic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.LISU">
            Unicode script "Lisu".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BAMUM">
            Unicode script "Bamum".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.JAVANESE">
            Unicode script "Javanese".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MEETEI_MAYEK">
            Unicode script "Meetei_Mayek".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.IMPERIAL_ARAMAIC">
            Unicode script "Imperial_Aramaic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OLD_SOUTH_ARABIAN">
            Unicode script "Old_South_Arabian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.INSCRIPTIONAL_PARTHIAN">
            Unicode script "Inscriptional_Parthian".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.INSCRIPTIONAL_PAHLAVI">
            Unicode script "Inscriptional_Pahlavi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.OLD_TURKIC">
            Unicode script "Old_Turkic".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.BRAHMI">
            Unicode script "Brahmi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.KAITHI">
            Unicode script "Kaithi".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MEROITIC_HIEROGLYPHS">
            Unicode script "Meroitic Hieroglyphs".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MEROITIC_CURSIVE">
            Unicode script "Meroitic Cursive".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SORA_SOMPENG">
            Unicode script "Sora Sompeng".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.CHAKMA">
            Unicode script "Chakma".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.SHARADA">
            Unicode script "Sharada".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.TAKRI">
            Unicode script "Takri".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.MIAO">
            Unicode script "Miao".
        </member>
        <member name="F:iText.IO.Util.UnicodeScript.UNKNOWN">
            Unicode script "Unknown".
        </member>
        <member name="T:iText.IO.Util.UnicodeScriptUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.UnicodeScriptUtil.Of(System.Int32)">
                    * Returns the enum constant representing the Unicode script of which
                    * the given character (Unicode code point) is assigned to.
                     *
                    * @param   codePoint the character (Unicode code point) in question.
                    * @return  The {@code UnicodeScript} constant representing the
                    *          Unicode script of which this character is assigned to.
                    *
                    * @exception IllegalArgumentException if the specified
                    * {@code codePoint} is an invalid Unicode code point.
                    * @see Character#isValidCodePoint(int)
                    *
        </member>
        <member name="T:iText.IO.Util.UrlUtil">
            <summary>
            This file is a helper class for internal usage only.
            Be aware that it's API and functionality may be changed in future.
            </summary>
        </member>
        <member name="M:iText.IO.Util.UrlUtil.ToURL(System.String)">
            <summary>This method makes a valid URL from a given filename.</summary>
            <param name="filename">a given filename</param>
            <returns>a valid URL</returns>
        </member>
        <member name="M:iText.IO.Util.UrlUtil.OpenStream(System.Uri)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:iText.IO.Util.UrlUtil.ToNormalizedURI(System.String)">
            <summary>
            This method makes a normalized URI from a given filename. 
            </summary>
            <param name="filename">a given filename</param>
            <returns>a valid Uri</returns>
        </member>
        <member name="M:iText.IO.Util.UrlUtil.ToNormalizedURI(System.IO.FileInfo)">
            <summary>
            This method makes a normalized URI from a given file. 
            </summary>
            <param name="filename">a given file</param>
            <returns>a valid Uri</returns>
        </member>
        <member name="T:System.util.zlib.ZInflaterInputStream">
            <summary>
            Summary description for DeflaterOutputStream.
            </summary>
        </member>
    </members>
</doc>
