<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EntityFramework.SqlServerCompact</name>
    </assembly>
    <members>
        <member name="T:System.Data.Entity.SqlServerCompact.ADP1.InternalErrorCode">
            <summary>
            Internal error code to use with the InternalError exception.
            </summary>
            <remarks>
            You must never renumber these, because we rely upon them when
            we get an exception report once we release the bits.
            </remarks>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ADP1.InternalErrorCode.SqlGenParametersNotPermitted">
            <summary>
            Thrown when SQL gen produces parameters for anything other than a
            modification command tree.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.AliasGenerator">
            <summary>
            Generates monotonically increasing names of the form PrefixCounter, where Prefix is an optional prefix string and Counter is the string representation of a monotonically increasing int value that wraps to zero at int.MaxValue
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.AliasGenerator.#ctor(System.String)">
            <summary>
            Constructs a new AliasGenerator with the specified prefix string
            </summary>
            <param name="prefix"> The prefix string that will appear as the first part of all aliases generated by this AliasGenerator. May be null to indicate that no prefix should be used </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.AliasGenerator.Next">
            <summary>
            Generates the next alias and increments the Counter.
            </summary>
            <returns> The generated alias </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.AliasGenerator.GetName(System.Int32)">
            <summary>
            Generates the alias for the index.
            </summary>
            <param name="index"> index to generate the alias for </param>
            <returns> The generated alias </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommandTreeUtils.FlattenAssociativeExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Creates a flat list of the associative arguments.
            For example, for ((A1 + (A2 - A3)) + A4) it will create A1, (A2 - A3), A4
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommandTreeUtils.FlattenAssociativeExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.Data.Entity.Core.Common.CommandTrees.DbExpression[])">
            <summary>
            Creates a flat list of the associative arguments.
            For example, for ((A1 + (A2 - A3)) + A4) it will create A1, (A2 - A3), A4
            Only 'unfolds' the given arguments that are of the given expression kind.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommandTreeUtils.ExtractAssociativeArguments(System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.Collections.Generic.List{System.Data.Entity.Core.Common.CommandTrees.DbExpression},System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Helper method for FlattenAssociativeExpression.
            Creates a flat list of the associative arguments and appends to the given argument list.
            For example, for ((A1 + (A2 - A3)) + A4) it will add A1, (A2 - A3), A4 to the list.
            Only 'unfolds' the given expression if it is of the given expression kind.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommonUtils.EscapeSquareBraceNames(System.String)">
            <summary>
            Method to add a closing square brace escape for all
            embedded closing square braces in a string
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommonUtils.EscapeNames(System.String,System.Char)">
            <summary>
            Routine to replace an interesting character with itself
            (to escape the interesting character)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommonUtils.DeleteDatabase(System.String)">
            <summary>
            Delete the database that the fileName points to.
            </summary>
            <param name="fileName"> Database file path. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.CommonUtils.DatabaseExists(System.String)">
            <summary>
            Check whether the database pointed to by the file name exists or not.
            </summary>
            <param name="fileName"> Database file path </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.Helper.GetFacet(System.Collections.Generic.IEnumerable{System.Data.Entity.Core.Metadata.Edm.FacetDescription},System.String)">
            <summary>
            Searches for Facet Description with the name specified.
            </summary>
            <param name="facetCollection"> Collection of facet description </param>
            <param name="facetName"> name of the facet </param>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.Resources.Strings">
            <summary>
            Strongly-typed and parameterized string resources.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ArgumentIsNullOrWhitespace(System.Object)">
            <summary>
            A string like "The argument '{0}' cannot be null, empty or contain only white space."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_InvalidCommandType(System.Object)">
            <summary>
            A string like "The CommandType enumeration value, {0}, is invalid."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.InvalidStringArgument(System.Object)">
            <summary>
            A string like "Parameter '{0}' is not valid. String arguments cannot be empty."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.Mapping_Provider_WrongConnectionType(System.Object)">
            <summary>
            A string like "The connection given is not of type '{0}'."
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Data.Entity.SqlServerCompact.Resources.Strings.Update_SqlEntitySetWithoutDmlFunctions(System.Object,System.Object,System.Object)" -->
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.Mapping_Provider_WrongManifestType(System.Object)">
            <summary>
            A string like "The provider manifest given is not of type '{0}'."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ProviderReturnedNullForGetDbInformation(System.Object)">
            <summary>
            A string like "The provider returned null for the informationType '{0}'."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.InvalidDatePartArgumentExpression(System.Object,System.Object)">
            <summary>
            A string like "DATEPART argument to function '{0}.{1}' must be a literal string"
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.InvalidDatePartArgumentValue(System.Object,System.Object,System.Object)">
            <summary>
            A string like "'{0}' is not a valid value for DATEPART argument in '{1}.{2}' function"
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.UnknownExpressionType(System.Object)">
            <summary>
            A string like "'{0}' is an unknown expression type."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ProviderDoesNotSupportType(System.Object)">
            <summary>
            A string like "The type '{0}' is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.NoStoreTypeForEdmType(System.Object,System.Object)">
            <summary>
            A string like "There is no store type corresponding to the EDM type '{0}' of primitive type '{1}'."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.FunctionNotSupported(System.Object)">
            <summary>
            A string like "The function '{0}' is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.UpdateStatementCannotBeGeneratedForAcquiringLock(System.Object)">
            <summary>
            A string like "Failed when preparing table {0} for write as write-consistency cannot be guaranteed. Try adding a writable column to the table."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.Update_NotSupportedServerGenKey(System.Object)">
            <summary>
            A string like "Server-generated keys are only supported for identity columns. More than one column is marked as server generated in table '{0}'."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.Update_NotSupportedIdentityType(System.Object,System.Object)">
            <summary>
            A string like "Server-generated keys are only supported for identity columns. The column '{0}' has type '{1}', which is not a valid type for an identity column."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_InternalProviderError(System.Object)">
            <summary>
            A string like "Internal .NET Framework Data Provider error {0}."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_InvalidEnumerationValue(System.Object,System.Object)">
            <summary>
            A string like "The {0} enumeration value, {1}, is not valid."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_NotSupportedEnumerationValue(System.Object,System.Object,System.Object)">
            <summary>
            A string like "The {0} enumeration value, {1}, is not supported by the {2} method."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_ConnectionStringSyntax(System.Object)">
            <summary>
            A string like "Format of the initialization string does not conform to specification starting at index {0}."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_InvalidConnectionOptionValue(System.Object)">
            <summary>
            A string like "Value is not valid for key '{0}'."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ServerGeneratedGuidKeyNotSupported(System.Object)">
            <summary>
            A string like "Server generated GUID column "{0}" cannot be part of the key."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.ColumnGreaterThanMaxLengthNotSupported(System.Object,System.Object)">
            <summary>
            A string like "{0} column with MaxLength greater than {1} is not supported."
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Data.Entity.SqlServerCompact.Resources.Strings.InvalidDatabaseName(System.Object)" -->
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Strings.SqlServerMigrationSqlGenerator_UnknownOperation(System.Object,System.Object)">
            <summary>
            A string like "The current migration SQL generator ({0}) is unable to generate SQL for operations of type '{1}'. Call SetSqlGenerator on your migrations configuration class to use a different SQL generator. To create a custom SQL generator that can handle this type of operation, add a new class that derives from {0} and override Generate(MigrationOperation)."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_CanNotRetrieveServerGeneratedKey">
            <summary>
            A string like "Records were updated, but the values were not retrieved back. See internal error for more details."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.ADP_InvalidCommandTimeOut">
            <summary>
            A string like "SqlCeCommand.CommandTimeout does not support non-zero values."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.DatabaseDoesNotExist">
            <summary>
            A string like "The specified database doesn't exists."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.UnableToDetermineStoreVersion">
            <summary>
            A string like "Could not determine store version; a valid store connection or a version hint is required."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.NiladicFunctionsCannotHaveParameters">
            <summary>
            A string like "Functions attributed as NiladicFunction='true' in the provider manifest cannot have parameter declarations"
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.FullOuterJoinNotSupported">
            <summary>
            A string like "FULL OUTER JOIN is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.CollateInOrderByNotSupported">
            <summary>
            A string like "COLLATE subclause in the ORDER BY clause is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.DMLQueryCannotReturnResults">
            <summary>
            A string like "Server-generated keys and server-generated values are not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.SkipNotSupportedException">
            <summary>
            A string like "SKIP clause is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.WithTiesNotSupportedException">
            <summary>
            A string like "WITH TIES subclause is not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.UserDefinedFunctionsNotSupported">
            <summary>
            A string like "User defined functions are not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.TVFsNotSupported">
            <summary>
            A string like "Table valued functions are not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.DistinctAggregatesNotSupported">
            <summary>
            A string like "DISTINCT attribute is not supported in aggregate functions by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.StoredProceduresNotSupported">
            <summary>
            A string like "Stored procedures are not supported by SQL Server Compact."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.InvalidConnectionTypeException">
            <summary>
            A string like "The parameter specified for the connection is not supported and is not of the SqlCeConnection type."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.ComputedColumnsNotSupported">
            <summary>
            A string like "The store generated pattern 'Computed' is supported for properties that are of type 'timestamp'  or 'rowversion' only."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.IncompleteDatabaseCreation">
            <summary>
            A string like "The database creation succeeded, but the creation of the database objects did not. See inner exception for more details."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.DeleteDatabaseNotAllowedWithinTransaction">
            <summary>
            A string like "Database file cannot be deleted within a transaction scope."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.CreateDatabaseNotAllowedWithinTransaction">
            <summary>
            A string like "Database file cannot be created within a transaction scope."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.DeleteDatabaseWithOpenConnection">
            <summary>
            A string like "Database file cannot be deleted. Close all open connections before calling DeleteDatabase()."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.ELinq_DbFunctionDirectCall">
            <summary>
            A string like "This function can only be invoked from LINQ to Entities."
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.AutomaticMigration">
            <summary>
            A string like "AutomaticMigration"
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.Resources.Strings.SqlCeColumnRenameNotSupported">
            <summary>
            A string like "Direct column renaming is not supported by SQL Server Compact. To rename a column in SQL Server Compact, you will need to recreate it."
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.Resources.Error">
            <summary>
            Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Error.SqlCeColumnRenameNotSupported">
            <summary>
            Migrations.Infrastructure.MigrationsException with message like "Direct column renaming is not supported by SQL Server Compact. To rename a column in SQL Server Compact, you will need to recreate it."
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.Data.Entity.SqlServerCompact.Resources.Error.InvalidDatabaseName(System.Object)" -->
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Error.SqlServerMigrationSqlGenerator_UnknownOperation(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "The current migration SQL generator ({0}) is unable to generate SQL for operations of type '{1}'. Call SetSqlGenerator on your migrations configuration class to use a different SQL generator. To create a custom SQL generator that can handle this type of operation, add a new class that derives from {0} and override Generate(MigrationOperation)."
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Error.ArgumentOutOfRange(System.String)">
            <summary>
            The exception that is thrown when the value of an argument is outside the allowable range of values as defined by the invoked method.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Error.NotImplemented">
            <summary>
            The exception that is thrown when the author has yet to implement the logic at this point in the program. This can act as an exception based TODO tag.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.Resources.Error.NotSupported">
            <summary>
            The exception that is thrown when an invoked method is not supported, or when there is an attempt to
            read, seek, or write to a stream that does not support the invoked functionality.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.Resources.EntityRes">
            <summary>
            AutoGenerated resource class. Usage:
            string s = EntityRes.GetString(EntityRes.MyIdenfitier);
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.StoreSchemaDefinition">
            <summary>
            Value to pass to GetInformation to get the StoreSchemaDefinition
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.StoreSchemaMapping">
            <summary>
            Value to pass to GetInformation to get the StoreSchemaMapping
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.ConceptualSchemaDefinition">
            <summary>
            Value to pass to GetInformation to get the ConceptualSchemaDefinition
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.MaxLengthFacetName">
            <summary>
            Name of the MaxLength Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.UnicodeFacetName">
            <summary>
            Name of the Unicode Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.FixedLengthFacetName">
            <summary>
            Name of the FixedLength Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.PrecisionFacetName">
            <summary>
            Name of the Precision Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.ScaleFacetName">
            <summary>
            Name of the Scale Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.NullableFacetName">
            <summary>
            Name of the Nullable Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.DefaultValueFacetName">
            <summary>
            Name of the DefaultValue Facet
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.ProviderManifest.CollationFacetName">
            <summary>
            Name of the Collation Facet
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.RemoteProviderHelper.GetRemoteProviderType(System.String)">
            <summary>
            Convinience method to load the type specific to Remote Provider
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.RemoteProviderHelper.CompareObjectEqualsToType(System.Object,System.String)">
            <summary>
            Compare whether the object obj is of the type typeName
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.RemoteProviderHelper.CreateRemoteProviderType(System.String)">
            <summary>
            Create an instance of the Remote Provider specific type
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.RemoteProviderHelper.ConstructFullAssemblyName(System.String)">
            <summary>
            Use current assembly information to construct the full
            assembly name for an assembly with name assemblyName.
            This is called for Microsoft.SqlServerCe.Client.dll only.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.RemoteProviderHelper.IsRemoteProviderLoaded">
            <summary>
            Returns whether the Remote Provider is loaded or not.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator">
            <summary>
            Provider to convert provider agnostic migration operations into SQL commands
            that can be run against a Microsoft SQL Server Compact Edition database.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Collections.Generic.IEnumerable{System.Data.Entity.Migrations.Model.MigrationOperation},System.String)">
            <summary>
            Converts a set of migration operations into Microsoft SQL Server specific SQL.
            </summary>
            <param name="migrationOperations"> The operations to be converted. </param>
            <param name="providerManifestToken"> Token representing the version of SQL Server being targeted (i.e. "2005", "2008"). </param>
            <returns> A list of SQL statements to be executed to perform the migration operations. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.UpdateDatabaseOperation)">
            <summary>
            Generates the specified update database operation which represents applying a series of migrations.
            The generated script is idempotent, meaning it contains conditional logic to check if individual migrations 
            have already been applied and only apply the pending ones.
            </summary>
            <param name="updateDatabaseOperation">The update database operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.MigrationOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.MigrationOperation"/>.
            Allows derived providers to handle additional operation types.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="migrationOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.CreateConnection">
            <summary>
            Creates an empty connection for the current provider.
            Allows derived providers to use connection other than <see cref="T:System.Data.SqlClient.SqlConnection"/>.
            </summary>
            <returns> An empty connection for the current provider. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.CreateProcedureOperation)">
            <summary>
            Generates the specified create procedure operation.
            </summary>
            <param name="createProcedureOperation">The create procedure operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.AlterProcedureOperation)">
            <summary>
            Generates the specified alter procedure operation.
            </summary>
            <param name="alterProcedureOperation">The alter procedure operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropProcedureOperation)">
            <summary>
            Generates the specified drop procedure operation.
            </summary>
            <param name="dropProcedureOperation">The drop procedure operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.CreateTableOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.CreateTableOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="createTableOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.GenerateMakeSystemTable(System.Data.Entity.Migrations.Model.CreateTableOperation,System.Data.Entity.Migrations.Utilities.IndentedTextWriter)">
            <summary>
            Generates SQL to mark a table as a system table.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="createTableOperation"> The table to mark as a system table. </param>
            <param name="writer"> The <see cref="T:System.Data.Entity.Migrations.Utilities.IndentedTextWriter"/> to write the generated SQL to. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.AddForeignKeyOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.AddForeignKeyOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="addForeignKeyOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropForeignKeyOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.DropForeignKeyOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="dropForeignKeyOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.CreateIndexOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.CreateIndexOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="createIndexOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropIndexOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.DropIndexOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="dropIndexOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.AddPrimaryKeyOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.AddPrimaryKeyOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="addPrimaryKeyOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropPrimaryKeyOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.DropPrimaryKeyOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="dropPrimaryKeyOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.AddColumnOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.AddColumnOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="addColumnOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropColumnOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.DropColumnOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="dropColumnOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.AlterColumnOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.AlterColumnOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="alterColumnOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.DropTableOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.DropTableOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="dropTableOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.SqlOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.SqlOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="sqlOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.RenameColumnOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.RenameColumnOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="renameColumnOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.RenameTableOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.RenameTableOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="renameTableOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.RenameProcedureOperation)">
            <summary>
            Generates the specified rename procedure operation.
            </summary>
            <param name="renameProcedureOperation">The rename procedure operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.MoveProcedureOperation)">
            <summary>
            Generates the specified move procedure operation.
            </summary>
            <param name="moveProcedureOperation">The move procedure operation.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.MoveTableOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.MoveTableOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="moveTableOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Migrations.Model.HistoryOperation)">
            <summary>
            Generates SQL for a <see cref="T:System.Data.Entity.Migrations.Model.HistoryOperation"/>.
            Generated SQL should be added using the Statement method.
            </summary>
            <param name="historyOperation"> The operation to produce SQL for. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Byte[])">
            <summary>
            Generates SQL to specify a constant byte[] default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Boolean)">
            <summary>
            Generates SQL to specify a constant bool default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.DateTime)">
            <summary>
            Generates SQL to specify a constant DateTime default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.DateTimeOffset)">
            <summary>
            Generates SQL to specify a constant DateTimeOffset default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Guid)">
            <summary>
            Generates SQL to specify a constant Guid default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.String)">
            <summary>
            Generates SQL to specify a constant string default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.TimeSpan)">
            <summary>
            Generates SQL to specify a constant TimeSpan default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Spatial.DbGeography)">
            <summary>
            Generates SQL to specify a constant geogrpahy default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Data.Entity.Spatial.DbGeometry)">
            <summary>
            Generates SQL to specify a constant geometry default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Generate(System.Object)">
            <summary>
            Generates SQL to specify a constant default value being set on a column.
            This method just generates the actual value, not the SQL to set the default value.
            </summary>
            <param name="defaultValue"> The value to be set. </param>
            <returns> SQL representing the default value. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.BuildColumnType(System.Data.Entity.Migrations.Model.ColumnModel)">
            <summary>
            Generates SQL to specify the data type of a column.
            This method just generates the actual type, not the SQL to create the column.
            </summary>
            <param name="columnModel"> The definition of the column. </param>
            <returns> SQL representing the data type. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Name(System.String)">
            <summary>
            Generates a quoted name. The supplied name may or may not contain the schema.
            </summary>
            <param name="name"> The name to be quoted. </param>
            <returns> The quoted name. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Quote(System.String)">
            <summary>
            Quotes an identifier for SQL Server.
            </summary>
            <param name="identifier"> The identifier to be quoted. </param>
            <returns> The quoted identifier. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Statement(System.String,System.Boolean)">
            <summary>
            Adds a new Statement to be executed against the database.
            </summary>
            <param name="sql"> The statement to be executed. </param>
            <param name="suppressTransaction"> Gets or sets a value indicating whether this statement should be performed outside of the transaction scope that is used to make the migration process transactional. If set to true, this operation will not be rolled back if the migration process fails. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Writer">
            <summary>
            Gets a new <see cref="T:System.Data.Entity.Migrations.Utilities.IndentedTextWriter"/> that can be used to build SQL.
            This is just a helper method to create a writer. Writing to the writer will
            not cause SQL to be registered for execution. You must pass the generated
            SQL to the Statement method.
            </summary>
            <returns> An empty text writer to use for SQL generation. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.Statement(System.Data.Entity.Migrations.Utilities.IndentedTextWriter)">
            <summary>
            Adds a new Statement to be executed against the database.
            </summary>
            <param name="writer"> The writer containing the SQL to be executed. </param>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator.GuidColumnDefault">
            <summary>
            Returns the column default value to use for store-generated GUID columns when
            no default value is explicitly specified in the migration.
            Always returns newid() for SQL Compact.
            </summary>
            <value>The string newid().</value>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest">
            <summary>
            The Provider Manifest for SQL Server CE
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.nvarcharMaxSize">
            <summary>
            maximum size of SSC unicode
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.Instance">
            <summary>
            Singleton object; RDP supports all features as that of LDP.
            So, this shouldn't be an issue anyways.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.#ctor(System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.GetDbInformation(System.String)">
            <summary>
            Providers should override this to return information specific to their provider.
            This method should never return null.
            </summary>
            <param name="informationType"> The name of the information to be retrieved. </param>
            <returns> An XmlReader at the begining of the information requested. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.GetEdmType(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            This method takes a type and a set of facets and returns the best mapped equivalent type
            in EDM.
            </summary>
            <param name="storeType"> A TypeUsage encapsulating a store type and a set of facets </param>
            <returns> A TypeUsage encapsulating an EDM type and a set of facets </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.GetStoreType(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            This method takes a type and a set of facets and returns the best mapped equivalent type
            in SQL Server, taking the store version into consideration.
            </summary>
            <param name="edmType"> A TypeUsage encapsulating an EDM type and a set of facets </param>
            <returns> A TypeUsage encapsulating a store type and a set of facets </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderManifest.SupportsInExpression">
            <summary>
            Returns a boolean that specifies whether the corresponding provider can handle expression trees 
            containing instances of DbInExpression.
            The SqlCe provider handles instances of DbInExpression.
            </summary>
            <returns> <c>true</c>. </returns>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlCeProviderServices">
            <summary>
            The ProviderServices object for the Sql CE provider
            </summary>
            <remarks>
            Note that instance of this type also resolves additional provider services for Microsoft SQL Server Compact Edition
            when this type is registered as an EF provider either using an entry in the application's config file or through
            code-based registration in <see cref="T:System.Data.Entity.DbConfiguration"/>.
            The services resolved are:
            Requests for <see cref="T:System.Data.Entity.Infrastructure.IDbConnectionFactory"/> are resolved to a Singleton instance of
            <see cref="T:System.Data.Entity.Infrastructure.SqlCeConnectionFactory"/> to create connections to SQL Compact by default.
            Requests for <see cref="T:System.Data.Entity.Migrations.Sql.MigrationSqlGenerator"/> for the invariant name "System.Data.SqlServerCe.4.0" are
            resolved to <see cref="T:System.Data.Entity.SqlServerCompact.SqlCeMigrationSqlGenerator"/> instances to provide default Migrations SQL
            generation for SQL Compact.
            </remarks>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.ProviderInvariantName">
            <summary>
            This is the well-known string using in configuration files and code-based configuration as
            the "provider invariant name" used to specify Microsoft SQL Server Compact Edition 4.0 for
            ADO.NET and Entity Framework provider services.
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.Instance">
            <summary>
            Singleton object;
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.DbCreateDatabaseScript(System.String,System.Data.Entity.Core.Metadata.Edm.StoreItemCollection)">
            <summary>
            API for generating script for creating schema objects from the Store Item Collection.
            </summary>
            <param name="providerManifestToken"> Provider manifest </param>
            <param name="storeItemCollection"> Store items </param>
            <returns> T-SQL script for generating schema objects. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.DbDatabaseExists(System.Data.Common.DbConnection,System.Nullable{System.Int32},System.Data.Entity.Core.Metadata.Edm.StoreItemCollection)">
            <summary>
            API for checkin whether database exists or not.
            This will internally only check whether the file that the connection points to exists or not.
            Note: In case of SQLCE, timeout and storeItemCollection parameters are ignored.
            </summary>
            <param name="connection"> Connection </param>
            <param name="timeOut"> Timeout for internal commands. </param>
            <param name="storeItemCollection"> Item Collection. </param>
            <returns> Bool indicating whether database exists or not. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.DbDeleteDatabase(System.Data.Common.DbConnection,System.Nullable{System.Int32},System.Data.Entity.Core.Metadata.Edm.StoreItemCollection)">
            <summary>
            API for deleting the database.
            In SQLCE case, this will translate to File.Delete() call.
            Note: Timeout and storeItemCollection parameters are ignored.
            </summary>
            <param name="connection"> Connection </param>
            <param name="timeOut"> Timeout for internal commands. </param>
            <param name="storeItemCollection"> Item Collection. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.DbCreateDatabase(System.Data.Common.DbConnection,System.Nullable{System.Int32},System.Data.Entity.Core.Metadata.Edm.StoreItemCollection)">
            <summary>
            API for creating the databse and schema objects given a StoreItemCollection.
            This will do following things:
            1. Create a new database using SqlCeEngine.CreateDatabase().
            2. Generate scripts for creating schema objects.
            3. Execute the scrip generated in step2.
            </summary>
            <param name="connection"> Connection </param>
            <param name="timeOut"> Timeout for internal commands </param>
            <param name="storeItemCollection"> Store Item Collection </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.RegisterInfoMessageHandler(System.Data.Common.DbConnection,System.Action{System.String})">
            <summary>
            Registers a handler to process non-error messages coming from the database provider.
            </summary>
            <param name="connection">The connection to receive information for.</param>
            <param name="handler">The handler to process messages.</param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.CreateDbCommandDefinition(System.Data.Entity.Core.Common.DbProviderManifest,System.Data.Entity.Core.Common.CommandTrees.DbCommandTree)">
            <summary>
            Create a Command Definition object, given the connection and command tree
            </summary>
            <param name="providerManifest"> provider manifest that was determined from metadata </param>
            <param name="commandTree"> command tree for the statement </param>
            <returns> an executable command definition object </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.CreateCommand(System.Data.Entity.Core.Common.DbProviderManifest,System.Data.Entity.Core.Common.CommandTrees.DbCommandTree)">
            <summary>
            Create a SqlCeCommand object, given the provider manifest and command tree
            </summary>
            <param name="providerManifest"> provider manifest </param>
            <param name="commandTree"> command tree for the statement </param>
            <returns> a command object </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetDbProviderManifestToken(System.Data.Common.DbConnection)">
            <summary>
            Returns provider manifest token for a given connection.
            </summary>
            <param name="connection">Connection to find manifest token from.</param>
            <returns>The provider manifest token for the specified connection.</returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetDbProviderManifest(System.String)">
            <summary>
            Returns the provider manifest by using the specified version information.
            </summary>
            <returns> The provider manifest by using the specified version information. </returns>
            <param name="versionHint"> The token information associated with the provider manifest. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.CreateSqlCeParameter(System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Constructs a SqlCeParameter
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetSqlDbType(System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Nullable{System.Int32}@,System.Nullable{System.Byte}@,System.Nullable{System.Byte}@)">
            <summary>
            Determines SqlDbType for the given primitive type. Extracts facet
            information as well.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetParameterSize(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Determines preferred value for SqlParameter.Size. Returns null
            where there is no preference.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetParameterPrecision(System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Nullable{System.Byte})">
            <summary>
            Returns SqlParameter.Precision where the type facet exists. Otherwise,
            returns null.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetScale(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Returns SqlParameter.Scale where the type facet exists. Otherwise,
            returns null.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetStringDbType(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate SqlDbType for the given string type.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeProviderServices.GetBinaryDbType(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Chooses the appropriate SqlDbType for the given binary type.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlDdlBuilder">
            <summary>
            Class for generating scripts to create schema objects.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlDdlBuilder.CreateObjectsScript(System.Data.Entity.Core.Metadata.Edm.StoreItemCollection,System.Boolean)">
            <summary>
            Helper function for generating the scripts for tables &amp; constraints.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlDdlBuilder.GetCommandText(System.Boolean)">
            <summary>
            Function that returns final command text by appending Constraints to ObjectBuilder.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlDdlBuilder.AppendCreateForeignKeys(System.Data.Entity.Core.Metadata.Edm.AssociationSet)">
            <summary>
            Function for generating foreign key constraints.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlDdlBuilder.AppendCreateTable(System.Data.Entity.Core.Metadata.Edm.EntitySet)">
            <summary>
            Function for generating create table statements.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlDdlBuilder.AppendSqlInvariantFormat(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            Append raw SQL into the string builder with formatting options and invariant culture formatting.
            </summary>
            <param name="builder"> </param>
            <param name="format"> A composite format string. </param>
            <param name="args"> An array of objects to format. </param>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlCeFunctions">
            <summary>
            Contains function stubs that expose SqlServerCe methods in Linq to Entities.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.String,System.String)">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.Byte[],System.Byte[])">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.Byte[],System.Byte[],System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.String,System.String,System.Nullable{System.Int64})">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.CharIndex(System.Byte[],System.Byte[],System.Nullable{System.Int64})">
            <summary>
            Proxy for the function SqlServerCe.CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.NChar(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.NCHAR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.PatIndex(System.String,System.String)">
            <summary>
            Proxy for the function SqlServerCe.PATINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Replicate(System.String,System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.REPLICATE
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Space(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.SPACE
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Decimal},System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Double},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.StringConvert(System.Nullable{System.Decimal},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.STR
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Stuff(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.String)">
            <summary>
            Proxy for the function SqlServerCe.STUFF
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Unicode(System.String)">
            <summary>
            Proxy for the function SqlServerCe.UNICODE
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Acos(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.ACOS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Acos(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.ACOS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Asin(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.ASIN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Asin(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.ASIN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Atan(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.ATAN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Atan(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.ATAN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Atan2(System.Nullable{System.Double},System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.ATN2
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Atan2(System.Nullable{System.Decimal},System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.ATN2
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Cos(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.COS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Cos(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.COS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Cot(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.COT
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Cot(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.COT
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Degrees(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.DEGREES
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Degrees(System.Nullable{System.Int64})">
            <summary>
            Proxy for the function SqlServerCe.DEGREES
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Degrees(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.DEGREES
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Degrees(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.DEGREES
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Exp(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.EXP
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Exp(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.EXP
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Log(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.LOG
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Log(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.LOG
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Log10(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.LOG10
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Log10(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.LOG10
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Pi">
            <summary>
            Proxy for the function SqlServerCe.PI
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Radians(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.RADIANS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Radians(System.Nullable{System.Int64})">
            <summary>
            Proxy for the function SqlServerCe.RADIANS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Radians(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.RADIANS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Radians(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.RADIANS
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Rand">
            <summary>
            Proxy for the function SqlServerCe.RAND
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Rand(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.RAND
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sign(System.Nullable{System.Int32})">
            <summary>
            Proxy for the function SqlServerCe.SIGN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sign(System.Nullable{System.Int64})">
            <summary>
            Proxy for the function SqlServerCe.SIGN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sign(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.SIGN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sign(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.SIGN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sin(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.SIN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Sin(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.SIN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.SquareRoot(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.SQRT
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.SquareRoot(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.SQRT
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Tan(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.TAN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.Tan(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.TAN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateAdd(System.String,System.Nullable{System.Double},System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATEADD
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateAdd(System.String,System.Nullable{System.Double},System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATEADD
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateDiff(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATEDIFF
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateDiff(System.String,System.String,System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATEDIFF
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateDiff(System.String,System.Nullable{System.DateTime},System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATEDIFF
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateDiff(System.String,System.String,System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATEDIFF
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateName(System.String,System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATENAME
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DateName(System.String,System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATENAME
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DatePart(System.String,System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATEPART
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DatePart(System.String,System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATEPART
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.GetDate">
            <summary>
            Proxy for the function SqlServerCe.GETDATE
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Nullable{System.Boolean})">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Nullable{System.Double})">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Nullable{System.Decimal})">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Nullable{System.DateTime})">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.String)">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Byte[])">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlCeFunctions.DataLength(System.Nullable{System.Guid})">
            <summary>
            Proxy for the function SqlServerCe.DATALENGTH
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator">
            <summary>
            Class generating SQL for a DML command tree.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.GetUpdatableColumn(System.Data.Entity.Core.Common.CommandTrees.DbUpdateCommandTree,System.String@)">
            <summary>
            This method is added as a part of the fix for bug 13533
            In this method we try to see from the command tree whether there is any
            updatable column(Property) available on the table(EntityType)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.GenerateReturningSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlStringBuilder,System.Data.Entity.Core.Common.CommandTrees.DbModificationCommandTree,System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.ExpressionTranslator,System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Generates SQL fragment returning server-generated values.
            Requires: translator knows about member values so that we can figure out
            how to construct the key predicate.
            <code>Sample SQL:
            
                select IdentityValue
                from MyTable
                where IdentityValue = @@identity 
            
                NOTE: not scope_identity() because we don't support it.</code>
            </summary>
            <param name="commandText"> Builder containing command text </param>
            <param name="tree"> Modification command tree </param>
            <param name="translator"> Translator used to produce DML SQL statement for the tree </param>
            <param name="returning"> Returning expression. If null, the method returns immediately without producing a SELECT statement. </param>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.ExpressionTranslator">
            <summary>
            Lightweight expression translator for DML expression trees, which have constrained
            scope and support.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.ExpressionTranslator.#ctor">
            <summary>
            For testing.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.ExpressionTranslator.#ctor(System.Data.Entity.SqlServerCompact.SqlGen.SqlStringBuilder,System.Data.Entity.Core.Common.CommandTrees.DbModificationCommandTree,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initialize a new expression translator populating the given string builder
            with command text. Command text builder and command tree must not be null.
            </summary>
            <param name="commandText"> Command text with which to populate commands </param>
            <param name="commandTree"> Command tree generating SQL </param>
            <param name="preserveMemberValues"> Indicates whether the translator should preserve member values while compiling t-SQL (only needed for server generation) </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.DmlSqlGenerator.ExpressionTranslator.RegisterMemberValue(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Call this method to register a property value pair so the translator "remembers"
            the values for members of the row being modified. These values can then be used
            to form a predicate for server-generation (based on the key of the row)
            </summary>
            <param name="propertyExpression"> DbExpression containing the column reference (property expression). </param>
            <param name="value"> DbExpression containing the value of the column. </param>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment">
            <summary>
            Represents the sql fragment for any node in the query tree.
            </summary>
            <remarks>
            The nodes in a query tree produce various kinds of sql
            <list type="bullet">
                <item>A select statement.</item>
                <item>A reference to an extent. (symbol)</item>
                <item>A raw string.</item>
            </list>
            We have this interface to allow for a common return type for the methods
            in the expression visitor <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbExpressionVisitor`1"/>
            Add the endd of translation, the sql fragments are converted into real strings.
            </remarks>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            Write the string represented by this fragment into the stream.
            </summary>
            <param name="writer"> The stream that collects the strings. </param>
            <param name="sqlGenerator"> Context information used for renaming. The global lists are used to generated new names without collisions. </param>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.JoinSymbol">
            <summary>
            A Join symbol is a special kind of Symbol.
            It has to carry additional information
            <list type="bullet">
                <item>
                    ColumnList for the list of columns in the select clause if this
                    symbol represents a sql select statement.  This is set by
                    <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)"/>
                    .
                </item>
                <item>ExtentList is the list of extents in the select clause.</item>
                <item>
                    FlattenedExtentList - if the Join has multiple extents flattened at the
                    top level, we need this information to ensure that extent aliases are renamed
                    correctly in
                    <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)"/>
                </item>
                <item>
                    NameToExtent has all the extents in ExtentList as a dictionary.
                    This is used by
                    <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression)"/>
                    to flatten
                    record accesses.
                </item>
                <item>
                    IsNestedJoin - is used to determine whether a JoinSymbol is an
                    ordinary join symbol, or one that has a corresponding SqlSelectStatement.
                </item>
            </list>
            All the lists are set exactly once, and then used for lookups/enumerated.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.Symbol">
            <summary>
            <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SymbolTable"/>
            This class represents an extent/nested select statement,
            or a column.
            The important fields are Name, Type and NewName.
            NewName starts off the same as Name, and is then modified as necessary.
            The rest are used by special symbols.
            e.g. NeedsRenaming is used by columns to indicate that a new name must
            be picked for the column in the second phase of translation.
            IsUnnest is used by symbols for a collection expression used as a from clause.
            This allows <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddFromSymbol(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol,System.Boolean)"/> to add the column list
            after the alias.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.Symbol.#ctor(System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Collections.Generic.Dictionary{System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol})">
            <summary>
            Use this constructor the symbol represents a SqlStatement with renamed output columns.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.Symbol.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            Write this symbol out as a string for sql.  This is just
            the new name of the symbol (which could be the same as the old name).
            We rename columns here if necessary.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SkipClause">
            <summary>
            SkipClause represents the a SKIP expression in a SqlSelectStatement.
            It has a count property, which indicates how many rows should be discarded.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SkipClause.#ctor(System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment)">
            <summary>
            Creates a SkipClause with the given skipCount.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SkipClause.#ctor(System.Int32)">
            <summary>
            Creates a SkipClause with the given skipCount.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SkipClause.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            Write out the OFFSET part of sql select statement
            It basically writes OFFSET X ROWS.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SkipClause.SkipCount">
            <summary>
            How many top rows should be discarded.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder">
            <summary>
            This class is like StringBuilder.  While traversing the tree for the first time,
            we do not know all the strings that need to be appended e.g. things that need to be
            renamed, nested select statements etc.  So, we use a builder that can collect
            all kinds of sql fragments.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder.Append(System.Object)">
            <summary>
            Add an object to the list - we do not verify that it is a proper sql fragment
            since this is an internal method.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder.AppendLine">
            <summary>
            This is to pretty print the SQL.  The writer <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter"/>
            needs to know about new lines so that it can add the right amount of
            indentation at the beginning of lines.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            We delegate the writing of the fragment to the appropriate type.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder.IsEmpty">
            <summary>
            Whether the builder is empty.  This is used by the <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbProjectExpression)"/>
            to determine whether a sql statement can be reused.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator">
            <summary>
            Translates the command object into a SQL string that can be executed on
            SSCE
            </summary>
            <remarks>
            The translation is implemented as a visitor <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbExpressionVisitor`1"/>
            over the query tree.  It makes a single pass over the tree, collecting the sql
            fragments for the various nodes in the tree <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment"/>.
            The major operations are
            <list type="bullet">
                <item>
                    Select statement minimization.  Multiple nodes in the query tree
                    that can be part of a single SQL select statement are merged. e.g. a
                    Filter node that is the input of a Project node can typically share the
                    same SQL statement.
                </item>
                <item>
                    Alpha-renaming.  As a result of the statement minimization above, there
                    could be name collisions when using correlated subqueries
                    <example>
                        <code>Filter(
                            b = Project( c.x
                            c = Extent(foo)
                            )
                            exists (
                            Filter(
                            c = Extent(foo)
                            b.x = c.x
                            )
                            )
                            )</code>
                        The first Filter, Project and Extent will share the same SQL select statement.
                        The alias for the Project i.e. b, will be replaced with c.
                        If the alias c for the Filter within the exists clause is not renamed,
                        we will get <c>c.x = c.x</c>, which is incorrect.
                        Instead, the alias c within the second filter should be renamed to c1, to give
                        <c>c.x = c1.x</c> i.e. b is renamed to c, and c is renamed to c1.
                    </example>
                </item>
                <item>
                    Join flattening.  In the query tree, a list of join nodes is typically
                    represented as a tree of Join nodes, each with 2 children. e.g.
                    <example>
                        <code>a = Join(InnerJoin
                            b = Join(CrossJoin
                            c = Extent(foo)
                            d = Extent(foo)
                            )
                            e = Extent(foo)
                            on b.c.x = e.x
                            )</code>
                        If translated directly, this will be translated to
                        <code>FROM ( SELECT c.*, d.*
                            FROM foo as c
                            CROSS JOIN foo as d) as b
                            INNER JOIN foo as e on b.x' = e.x</code>
                        It would be better to translate this as
                        <code>FROM foo as c
                            CROSS JOIN foo as d
                            INNER JOIN foo as e on c.x = e.x</code>
                        This allows the optimizer to choose an appropriate join ordering for evaluation.
                    </example>
                </item>
                <item>
                    Select * and column renaming.  In the example above, we noticed that
                    in some cases we add
                    <c>SELECT * FROM ...</c>
                    to complete the SQL
                    statement. i.e. there is no explicit PROJECT list.
                    In this case, we enumerate all the columns available in the FROM clause
                    This is particularly problematic in the case of Join trees, since the columns
                    from the extents joined might have the same name - this is illegal.  To solve
                    this problem, we will have to rename columns if they are part of a SELECT *
                    for a JOIN node - we do not need renaming in any other situation.
                    <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)"/>
                    .
                </item>
            </list>
            <para> Renaming issues. When rows or columns are renamed, we produce names that are unique globally with respect to the query. The names are derived from the original names, with an integer as a suffix. e.g. CustomerId will be renamed to CustomerId1, CustomerId2 etc. Since the names generated are globally unique, they will not conflict when the columns of a JOIN SELECT statement are joined with another JOIN. </para>
            <para>
                Record flattening. SQL server does not have the concept of records. However, a join statement produces records. We have to flatten the record accesses into a simple <c>alias.column</c> form.
                <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression)"/>
            </para>
            <para>
                Building the SQL. There are 2 phases
                <list type="numbered">
                    <item>
                        Traverse the tree, producing a sql builder
                        <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
                    </item>
                    <item>
                        Write the SqlBuilder into a string, renaming the aliases and columns
                        as needed.
                    </item>
                </list>
                In the first phase, we traverse the tree. We cannot generate the SQL string right away, since
                <list type="bullet">
                    <item>The WHERE clause has to be visited before the from clause.</item>
                    <item>
                        extent aliases and column aliases need to be renamed.  To minimize
                        renaming collisions, all the names used must be known, before any renaming
                        choice is made.
                    </item>
                </list>
                To defer the renaming choices, we use symbols
                <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.Symbol"/>
                . These are renamed in the second phase. Since visitor methods cannot transfer information to child nodes through parameters, we use some global stacks,
                <list type="bullet">
                    <item>
                        A stack for the current SQL select statement.  This is needed by
                        <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression)"/>
                        to create a
                        list of free variables used by a select statement.  This is needed for
                        alias renaming.
                    </item>
                    <item>
                        A stack for the join context.  When visiting an extent,
                        we need to know whether we are inside a join or not.  If we are inside
                        a join, we do not create a new SELECT statement.
                    </item>
                </list>
            </para>
            <para>
                Global state. To enable renaming, we maintain
                <list type="bullet">
                    <item>The set of all extent aliases used.</item>
                    <item>The set of all parameter names.</item>
                    <item>The set of all column names that may need to be renamed.</item>
                </list>
                Finally, we have a symbol table to lookup variable references. All references to the same extent have the same symbol.
            </para>
            <para>
                Sql select statement sharing. Each of the relational operator nodes
                <list type="bullet">
                    <item>Project</item>
                    <item>Filter</item>
                    <item>GroupBy</item>
                    <item>Sort/OrderBy</item>
                </list>
                can add its non-input (e.g. project, predicate, sort order etc.) to the SQL statement for the input, or create a new SQL statement. If it chooses to reuse the input's SQL statement, we play the following symbol table trick to accomplish renaming. The symbol table entry for the alias of the current node points to the symbol for the input in the input's SQL statement.
                <example>
                    <code>Project(b.x
                        b = Filter(
                        c = Extent(foo)
                        c.x = 5)
                        )</code>
                    The Extent node creates a new SqlSelectStatement.  This is added to the
                    symbol table by the Filter as {c, Symbol(c)}.  Thus, <c>c.x</c> is resolved to
                    <c>Symbol(c).x</c>.
                    Looking at the project node, we add {b, Symbol(c)} to the symbol table if the
                    SQL statement is reused, and {b, Symbol(b)}, if there is no reuse.
                    Thus, <c>b.x</c> is resolved to <c>Symbol(c).x</c> if there is reuse, and to
                    <c>Symbol(b).x</c> if there is no reuse.
                </example>
            </para>
            </remarks>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.selectStatementStack">
            <summary>
            Every relational node has to pass its SELECT statement to its children
            This allows them (DbVariableReferenceExpression eventually) to update the list of
            outer extents (free variables) used by this select statement.
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.isParentAJoinStack">
            <summary>
            Nested joins and extents need to know whether they should create
            a new Select statement, or reuse the parent's.  This flag
            indicates whether the parent is a join or not.
            </summary>
        </member>
        <member name="F:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.isVarRefSingle">
            <summary>
            VariableReferenceExpressions are allowed only as children of DbPropertyExpression
            or MethodExpression.  The cheapest way to ensure this is to set the following
            property in DbVariableReferenceExpression and reset it in the allowed parent expressions.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.InitializeStoreFunctionHandlers">
            <summary>
            All special store functions and their handlers
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.InitializeCanonicalFunctionHandlers">
            <summary>
            All special non-aggregate canonical functions and their handlers
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.InitializeDatepartKeywords">
            <summary>
            Valid datepart values
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.InitializeFunctionNameToOperatorDictionary">
            <summary>
            Initalizes the mapping from functions to TSql operators
            for all functions that translate to TSql operators
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.#ctor">
            <summary>
            Basic constructor. 
            Internal for test purposes only, otherwise should be treated as private. 
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GenerateSql(System.Data.Entity.Core.Common.CommandTrees.DbCommandTree,System.Collections.Generic.List{System.Data.Common.DbParameter}@,System.Data.CommandType@,System.Boolean)">
            <summary>
            General purpose static function that can be called from System.Data assembly
            </summary>
            <param name="tree"> command tree </param>
            <param name="parameters"> Parameters to add to the command tree corresponding to constants in the command tree. Used only in ModificationCommandTrees. </param>
            <returns> The string representing the SQL to be executed. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GenerateSql(System.Data.Entity.Core.Common.CommandTrees.DbQueryCommandTree)">
            <summary>
            Translate a command tree to a SQL string.
            The input tree could be translated to either a SQL SELECT statement
            or a SELECT expression.  This choice is made based on the return type
            of the expression
            CollectionType => select statement
            non collection type => select expression
            </summary>
            <returns> The string representing the SQL to be executed. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment)">
            <summary>
            Convert the SQL fragments to a string. Writes a string representing the SQL to be executed
            into the specified writer.
            </summary>
            <param name="writer"> </param>
            <param name="sqlStatement">The fragment to be emitted</param>
            <returns>The writer specified for fluent continuations. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbAndExpression)">
            <summary>
            Translate(left) AND Translate(right)
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbApplyExpression)">
            <summary>
            An apply is just like a join, so it shares the common join processing
            in <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding},System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression)"/>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbArithmeticExpression)">
            <summary>
            For binary expressions, we delegate to <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitBinaryExpression(System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression)"/>.
            We handle the other expressions directly.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbCaseExpression)">
            <summary>
            If the ELSE clause is null, we do not write it out.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbComparisonExpression)">
            <summary>
            The parser generates Not(Equals(...)) for &lt;&gt;.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitConstant(System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression,System.Boolean)">
            <summary>
            Generate tsql for a constant. Avoid the explicit cast (if possible) when
            the isCastOptional parameter is set
            </summary>
            <param name="e"> the constant expression </param>
            <param name="isCastOptional"> can we avoid the CAST </param>
            <returns> the tsql fragment </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.WrapWithCastIfNeeded(System.Boolean,System.Object,System.String,System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder)">
            <summary>
            Helper function for <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitConstant(System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression,System.Boolean)"/>
            Appends the given constant value to the result either 'as is' or wrapped with a cast to the given type.
            </summary>
            <param name="cast"> </param>
            <param name="value">A SQL string or an ISqlFragment instance.</param>
            <param name="typeName"> </param>
            <param name="result"> </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression)">
            <summary>
            We do not pass constants as parameters.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> . Strings are wrapped in single quotes and escaped. Numbers are written literally.
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbDistinctExpression)">
            <summary>
            The DISTINCT has to be added to the beginning of SqlSelectStatement.Select,
            but it might be too late for that.  So, we use a flag on SqlSelectStatement
            instead, and add the "DISTINCT" in the second phase.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbElementExpression)">
            <summary>
            An element expression returns a scalar - so it is translated to
            ( Select ... )
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbExceptExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Only concrete expression types will be visited.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbScanExpression)">
            <returns>
            If we are in a Join context, returns a <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> with the extent name, otherwise, a new
            <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            with the From field set.
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GetTargetTSql(System.Data.Entity.Core.Metadata.Edm.EntitySetBase)">
            <summary>
            Gets escaped TSql identifier describing this entity set.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)">
            <summary>
            The bodies of <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/>, <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbGroupByExpression)"/>,
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbProjectExpression)"/>, <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbSortExpression)"/> are similar.
            Each does the following.
            <list type="number">
                <item>Visit the input expression</item>
                <item>
                    Determine if the input's SQL statement can be reused, or a new
                    one must be created.
                </item>
                <item>Create a new symbol table scope</item>
                <item>
                    Push the Sql statement onto a stack, so that children can
                    update the free variable list.
                </item>
                <item>Visit the non-input expression.</item>
                <item>Cleanup</item>
            </list>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Lambda functions are not supported.
            The functions supported are:
            <list type="number">
                <item>Canonical Functions - We recognize these by their dataspace, it is DataSpace.CSpace</item>
                <item>Store Functions - We recognize these by the BuiltInAttribute and not being Canonical</item>
                <item>User-defined Functions - All the rest except for Lambda functions</item>
            </list>
            We handle Canonical and Store functions the same way: If they are in the list of functions
            that need special handling, we invoke the appropriate handler, otherwise we translate them to
            FunctionName(arg1, arg2, ..., argn).
            We translate user-defined functions to NamespaceName.FunctionName(arg1, arg2, ..., argn).
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbGroupByExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/> for general details.
            We modify both the GroupBy and the Select fields of the SqlSelectStatement.
            GroupBy gets just the keys without aliases,
            and Select gets the keys and the aggregates with aliases.
            Whenever there exists at least one aggregate with an argument that is not is not a simple
            <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/>  over <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/>,
            we create a nested query in which we alias the arguments to the aggregates.
            That is due to the following two limitations of Sql Server:
            <list type="number">
                <item>
                    If an expression being aggregated contains an outer reference, then that outer
                    reference must be the only column referenced in the expression (SQLBUDT #488741)
                </item>
                <item>
                    Sql Server cannot perform an aggregate function on an expression containing
                    an aggregate or a subquery. (SQLBUDT #504600)
                </item>
            </list>
            The default translation, without inner query is:
            SELECT
            kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn,
            aggf1(aexpr1) AS agg1, .. aggfn(aexprn) AS aggn
            FROM input AS a
            GROUP BY kexp1, kexp2, .. kexpn
            When we inject an innner query, the equivalent translation is:
            SELECT
            key1 AS key1, key2 AS key2, .. keyn AS keys,
            aggf1(agg1) AS agg1, aggfn(aggn) AS aggn
            FROM (
            SELECT
            kexp1 AS key1, kexp2 AS key2,... kexpn AS keyn,
            aexpr1 AS agg1, .. aexprn AS aggn
            FROM input AS a
            ) as a
            GROUP BY key1, key2, keyn
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIntersectExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbUnionAllExpression)"/>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression)">
            <summary>
            Not(IsEmpty) has to be handled specially, so we delegate to
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitIsEmptyExpression(System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)"/>.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> . <code>[NOT] EXISTS( ... )</code>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsNullExpression)">
            <summary>
            Not(IsNull) is handled specially, so we delegate to
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitIsNullExpression(System.Data.Entity.Core.Common.CommandTrees.DbIsNullExpression,System.Boolean)"/>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> <code>IS [NOT] NULL</code>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsOfExpression)">
            <summary>
            No error is raised if the store cannot support this.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbCrossJoinExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding},System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression)"/>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbJoinExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding},System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression)"/>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbLikeExpression)">
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbLimitExpression)">
            <summary>
            Translates to TOP expression.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)">
            <summary>
            DbNewInstanceExpression is allowed as a child of DbProjectExpression only.
            If anyone else is the parent, we throw.
            We also perform special casing for collections - where we could convert
            them into Unions
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitNewInstanceExpression(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)"/> for the actual implementation.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbNotExpression)">
            <summary>
            The Not expression may cause the translation of its child to change.
            These children are
            <list type="bullet">
                <item>
                    <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbNotExpression"/>
                    NOT(Not(x)) becomes x
                </item>
                <item>
                    <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression"/>
                    NOT EXISTS becomes EXISTS
                </item>
                <item>
                    <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbIsNullExpression"/>
                    IS NULL becomes IS NOT NULL
                </item>
                <item>
                    <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbComparisonExpression"/>
                    = becomes&lt;&gt;
                </item>
            </list>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbNullExpression)">
            <returns>
            <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbOfTypeExpression)">
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbOrExpression)">
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
            <seealso cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbAndExpression)"/>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbInExpression)">
            <summary>
            Visits a DbInExpression and generates the corresponding SQL fragment.
            </summary>
            <param name="e"> A <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbInExpression"/> that specifies the expression to be visited. </param>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> that specifies the generated SQL fragment.
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbParameterReferenceExpression)">
            <returns> A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbProjectExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/> for the general ideas.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
            <seealso cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression)">
            <summary>
            This method handles record flattening, which works as follows.
            consider an expression <c>Prop(y, Prop(x, Prop(d, Prop(c, Prop(b, Var(a)))))</c>
            where a,b,c are joins, d is an extent and x and y are fields.
            b has been flattened into a, and has its own SELECT statement.
            c has been flattened into b.
            d has been flattened into c.
            We visit the instance, so we reach Var(a) first.  This gives us a (join)symbol.
            Symbol(a).b gives us a join symbol, with a SELECT statement i.e. Symbol(b).
            From this point on , we need to remember Symbol(b) as the source alias,
            and then try to find the column.  So, we use a SymbolPair.
            We have reached the end when the symbol no longer points to a join symbol.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.JoinSymbol"/> if we have not reached the first Join node that has a SELECT statement. A
            <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SymbolPair"/>
            if we have seen the JoinNode, and it has a SELECT statement. A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/> with {Input}.propertyName otherwise.
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbQuantifierExpression)">
            <summary>
            Any(input, x) => Exists(Filter(input,x))
            All(input, x) => Not Exists(Filter(input, not(x))
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbSkipExpression)">
            <summary>
            For Sql9 it translates to:
            SELECT Y.x1, Y.x2, ..., Y.xn
            FROM (
            SELECT X.x1, X.x2, ..., X.xn, row_number() OVER (ORDER BY sk1, sk2, ...) AS [row_number]
            FROM input as X
            ) as Y
            WHERE Y.[row_number] &gt; count
            ORDER BY sk1, sk2, ...
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbSortExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
            <seealso cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbTreatExpression)">
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbUnionAllExpression)">
            <summary>
            This code is shared by <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbExceptExpression)"/>
            and <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIntersectExpression)"/>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitSetOpExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String)"/>
            Since the left and right expression may not be Sql select statements,
            we must wrap them up to look like SQL select statements.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression)">
            <summary>
            This method determines whether an extent from an outer scope(free variable)
            is used in the CurrentSelectStatement.
            An extent in an outer scope, if its symbol is not in the FromExtents
            of the CurrentSelectStatement.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.Symbol"/> .
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitAggregate(System.Data.Entity.Core.Common.CommandTrees.DbAggregate,System.Object)">
            <summary>
            Aggregates are not visited by the normal visitor walk.
            </summary>
            <param name="aggregate"> The aggreate go be translated </param>
            <param name="aggregateArgument"> The translated aggregate argument </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.ParanthesizeExpressionIfNeeded(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder)">
            <summary>
            Dump out an expression - optionally wrap it with parantheses if possible
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitBinaryExpression(System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Handler for inline binary expressions.
            Produces left op right.
            For associative operations does flattening.
            Puts parenthesis around the arguments if needed.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitComparisonExpression(System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Private handler for comparison expressions - almost identical to VisitBinaryExpression.
            We special case constants, so that we don't emit unnecessary casts
            </summary>
            <param name="op"> the comparison op </param>
            <param name="left"> the left-side expression </param>
            <param name="right"> the right-side expression </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitInputExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Data.Entity.SqlServerCompact.SqlGen.Symbol@)">
            <summary>
            This is called by the relational nodes.  It does the following
            <list>
                <item>
                    If the input is not a SqlSelectStatement, it assumes that the input
                    is a collection expression, and creates a new SqlSelectStatement
                </item>
            </list>
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/> and the main fromSymbol for this select statement.
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitIsEmptyExpression(System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression,System.Boolean)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression)"/>
            </summary>
            <param name="e"> </param>
            <param name="negate"> Was the parent a DbNotExpression? </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitCollectionConstructor(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)">
            <summary>
            Translate a NewInstance(Element(X)) expression into
            "select top(1) * from X"
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitIsNullExpression(System.Data.Entity.Core.Common.CommandTrees.DbIsNullExpression,System.Boolean)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsNullExpression)"/>
            </summary>
            <param name="e"> </param>
            <param name="negate"> Was the parent a DbNotExpression? </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding},System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            This handles the processing of join expressions.
            The extents on a left spine are flattened, while joins
            not on the left spine give rise to new nested sub queries.
            Joins work differently from the rest of the visiting, in that
            the parent (i.e. the join node) creates the SqlSelectStatement
            for the children to use.
            The "parameter" IsInJoinContext indicates whether a child extent should
            add its stuff to the existing SqlSelectStatement, or create a new SqlSelectStatement
            By passing true, we ask the children to add themselves to the parent join,
            by passing false, we ask the children to create new Select statements for
            themselves.
            This method is called from <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbApplyExpression)"/> and
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbJoinExpression)"/>.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.ProcessJoinInputResult(System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment,System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding,System.Int32)">
            <summary>
            This is called from <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitJoinExpression(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding},System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind,System.String,System.Data.Entity.Core.Common.CommandTrees.DbExpression)"/>.
            This is responsible for maintaining the symbol table after visiting
            a child of a join expression.
            The child's sql statement may need to be completed.
            The child's result could be one of
            <list type="number">
                <item>The same as the parent's - this is treated specially.</item>
                <item>A sql select statement, which may need to be completed</item>
                <item>An extent - just copy it to the from clause</item>
                <item>
                    Anything else (from a collection-valued expression) -
                    unnest and copy it.
                </item>
            </list>
            If the input was a Join, we need to create a new join symbol,
            otherwise, we create a normal symbol.
            We then call AddFromSymbol to add the AS clause, and update the symbol table.
            If the child's result was the same as the parent's, we have to clean up
            the list of symbols in the FromExtents list, since this contains symbols from
            the children of both the parent and the child.
            The happens when the child visited is a Join, and is the leftmost child of
            the parent.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.getAliasFromElementExpression(System.Data.Entity.Core.Common.CommandTrees.DbElementExpression)">
            <summary>
            This is called from <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitNewInstanceExpression(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)"/>.
            This is responsible for extracting the Alias for and Element expression
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitNewInstanceExpression(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)">
            <summary>
            We assume that this is only called as a child of a Project.
            This replaces <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbNewInstanceExpression)"/>, since
            we do not allow DbNewInstanceExpression as a child of any node other than
            DbProjectExpression.
            We write out the translation of each of the columns in the record.
            </summary>
            <returns>
            A <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder"/>
            </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitSetOpExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String)">
            <summary>
            Handler for set operations
            It generates left separator right.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsSpecialStoreFunction(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a store function that
            requires special handling
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsSpecialCanonicalFunction(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Determines whether the given function is a canonical function that
            requires special handling
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleFunctionDefault(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Default handling for functions.
            Translates them to FunctionName(arg1, arg2, ..., argn)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleFunctionDefaultGivenName(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression,System.String)">
            <summary>
            Default handling for functions with a given name.
            Translates them to FunctionName(arg1, arg2, ..., argn)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleFunctionArgumentsDefault(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression,System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder)">
            <summary>
            Default handling on function arguments.
            Appends the list of arguemnts to the given result
            If the function is niladic it does not append anything,
            otherwise it appends (arg1, arg2, .., argn)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialStoreFunction(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special build in functions
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialCanonicalFunction(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for special canonical functions
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialFunction(System.Collections.Generic.Dictionary{System.String,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.FunctionHandler},System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Dispatches the special function processing to the appropriate handler
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression,System.Boolean)">
            <summary>
            Handles functions that are translated into TSQL operators.
            The given function should have one or two arguments.
            Functions with one arguemnt are translated into
            op arg
            Functions with two arguments are translated into
            arg0 op arg1
            Also, the arguments can be optionaly enclosed in parethesis
            </summary>
            <param name="e"> </param>
            <param name="parenthesiseArguments"> Whether the arguments should be enclosed in parethesis </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleConcatFunction(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression,System.Boolean)"></see>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionBitwise(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleSpecialFunctionToOperator(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression,System.Boolean)"></see>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleUnsupportedFunction(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Throw error for any unsupported canonical functions
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleDatepartDateFunction(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handles special case in which datapart 'type' parameter is present. all the functions
            handles here have *only* the 1st parameter as datepart. datepart value is passed along
            the QP as string and has to be expanded as TSQL keyword.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionDatepart(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for canonical funcitons for extracting date parts.
            For example:
            Year(date) -> DATEPART( year, date)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionDatepart(System.String,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for turning a canonical function into DATEPART
            Results in DATEPART(datepart, e)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionCurrentDateTime(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Handler for the canonical function GetDate
            CurrentDate() -> GetDate()
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionIndexOf(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Function rename IndexOf -> CHARINDEX
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionNewGuid(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Function rename NewGuid -> NEWID
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionLength(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Function rename Length -> LEN
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionRound(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Round(numericExpression) -> Round(numericExpression, 0);
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionTrim(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            TRIM(string) -> LTRIM(RTRIM(string))
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionToLower(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Function rename ToLower -> LOWER
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCanonicalFunctionToUpper(System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator,System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            Function rename ToUpper -> UPPER
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.WriteFunctionName(System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder,System.Data.Entity.Core.Metadata.Edm.EdmFunction,System.Boolean@,System.String@)">
            <summary>
            Writes the function name to the given SqlBuilder.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.WriteFunctionName(System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder,System.Data.Entity.Core.Metadata.Edm.EdmFunction)">
            <summary>
            Writes the function name to the given SqlBuilder.
            Dummy method where we don't expect cast.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.SqlServerCompact.SqlGen.Symbol,System.Collections.Generic.List{System.Data.Entity.SqlServerCompact.SqlGen.Symbol},System.Collections.Generic.Dictionary{System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol},System.String@)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)"/>
            Add the column names from the referenced extent/join to the
            select statement.
            If the symbol is a JoinSymbol, we recursively visit all the extents,
            halting at real extents and JoinSymbols that have an associated SqlSelectStatement.
            The column names for a real extent can be derived from its type.
            The column names for a Join Select statement can be got from the
            list of columns that was created when the Join's select statement
            was created.
            We do the following for each column.
            <list type="number">
                <item>Add the SQL string for each column to the SELECT clause</item>
                <item>
                    Add the column to the list of columns - so that it can
                    become part of the "type" of a JoinSymbol
                </item>
                <item>
                    Check if the column name collides with a previous column added
                    to the same select statement.  Flag both the columns for renaming if true.
                </item>
                <item>Add the column to a name lookup dictionary for collision detection.</item>
            </list>
            </summary>
            <param name="selectStatement"> The select statement that started off as SELECT * </param>
            <param name="symbol"> The symbol containing the type information for the columns to be added. </param>
            <param name="columnList">
            Columns that have been added to the Select statement. This is created in
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)"/>
            .
            </param>
            <param name="columnDictionary"> A dictionary of the columns above. </param>
            <param name="separator"> Comma or nothing, depending on whether the SELECT clause is empty. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddColumn(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.SqlServerCompact.SqlGen.Symbol,System.Collections.Generic.List{System.Data.Entity.SqlServerCompact.SqlGen.Symbol},System.Collections.Generic.Dictionary{System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol},System.String@,System.String)">
            <summary>
            Helper method for AddColumns. Adds a column with the given column name
            to the Select list of the given select statement.
            </summary>
            <param name="selectStatement"> The select statement to whose SELECT part the column should be added </param>
            <param name="symbol"> The symbol from which the column to be added originated </param>
            <param name="columnList">
            Columns that have been added to the Select statement. This is created in
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)"/>
            .
            </param>
            <param name="columnDictionary"> A dictionary of the columns above. </param>
            <param name="separator"> Comma or nothing, depending on whether the SELECT clause is empty. </param>
            <param name="columnName"> The name of the column to be added. </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddDefaultColumns(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement)">
            <summary>
            Expands Select * to "select the_list_of_columns"
            If the columns are taken from an extent, they are written as
            {original_column_name AS Symbol(original_column)} to allow renaming.
            If the columns are taken from a Join, they are written as just
            {original_column_name}, since there cannot be a name collision.
            We concatenate the columns from each of the inputs to the select statement.
            Since the inputs may be joins that are flattened, we need to recurse.
            The inputs are inferred from the symbols in FromExtents.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddFromSymbol(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddFromSymbol(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddFromSymbol(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.SqlServerCompact.SqlGen.Symbol,System.Boolean)">
            <summary>
            This method is called after the input to a relational node is visited.
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbProjectExpression)"/> and <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.ProcessJoinInputResult(System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment,System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding,System.Int32)"/>
            There are 2 scenarios
            <list type="number">
                <item>
                    The fromSymbol is new i.e. the select statement has just been
                    created, or a join extent has been added.
                </item>
                <item>The fromSymbol is old i.e. we are reusing a select statement.</item>
            </list>
            If we are not reusing the select statement, we have to complete the
            FROM clause with the alias
            <code>-- if the input was an extent
                FROM = [SchemaName].[TableName]
                -- if the input was a Project
                FROM = (SELECT ... FROM ... WHERE ...)</code>
            These become
            <code>-- if the input was an extent
                FROM = [SchemaName].[TableName] AS alias
                -- if the input was a Project
                FROM = (SELECT ... FROM ... WHERE ...) AS alias</code>
            and look like valid FROM clauses.
            Finally, we have to add the alias to the global list of aliases used,
            and also to the current symbol table.
            </summary>
            <param name="selectStatement"> </param>
            <param name="inputVarName"> The alias to be used. </param>
            <param name="fromSymbol"> </param>
            <param name="addToSymbolTable"> </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.AddSortKeys(System.Data.Entity.SqlServerCompact.SqlGen.SqlBuilder,System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbSortClause})">
            <summary>
            Translates a list of SortClauses.
            Used in the translation of OrderBy
            </summary>
            <param name="orderByClause"> The SqlBuilder to which the sort keys should be appended </param>
            <param name="sortKeys"> </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.CreateNewSelectStatement(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Data.Entity.SqlServerCompact.SqlGen.Symbol@)">
            <summary>
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.CreateNewSelectStatement(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Boolean,System.Data.Entity.SqlServerCompact.SqlGen.Symbol@)"/>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.CreateNewSelectStatement(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.String,System.Data.Entity.Core.Metadata.Edm.TypeUsage,System.Boolean,System.Data.Entity.SqlServerCompact.SqlGen.Symbol@)">
            <summary>
            This is called after a relational node's input has been visited, and the
            input's sql statement cannot be reused.  <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbProjectExpression)"/>
            When the input's sql statement cannot be reused, we create a new sql
            statement, with the old one as the from clause of the new statement.
            The old statement must be completed i.e. if it has an empty select list,
            the list of columns must be projected out.
            If the old statement being completed has a join symbol as its from extent,
            the new statement must have a clone of the join symbol as its extent.
            We cannot reuse the old symbol, but the new select statement must behave
            as though it is working over the "join" record.
            </summary>
            <returns> A new select statement, with the old one as the from clause. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.EscapeSingleQuote(System.String,System.Boolean)">
            <summary>
            Before we embed a string literal in a SQL string, we should
            convert all ' to '', and enclose the whole string in single quotes.
            </summary>
            <returns> The escaped sql string. </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GetSqlPrimitiveType(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Returns the sql primitive/native type name.
            It will include size, precision or scale depending on type information present in the
            type facets
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.HandleCountExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Handles the expression represending DbLimitExpression.Limit and DbSkipExpression.Count.
            If it is a constant expression, it simply does to string thus avoiding casting it to the specific value
            (which would be done if <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression)"/> is called)
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsApplyExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is an Apply operation.
            This is only the case when the DbExpressionKind is CrossApply or OuterApply.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsJoinExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a particular expression is a Join operation.
            This is true for DbCrossJoinExpression and DbJoinExpression, the
            latter of which may have one of several different ExpressionKinds.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsComplexExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            This is used to determine if a calling expression needs to place
            round brackets around the translation of the expression e.
            Constants, parameters and properties do not require brackets,
            everything else does.
            </summary>
            <returns> true, if the expression needs brackets </returns>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsCompatible(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind)">
            <summary>
            Determine if the owner expression can add its unique sql to the input's
            SqlSelectStatement
            </summary>
            <param name="result"> The SqlSelectStatement of the input to the relational node. </param>
            <param name="expressionKind"> The kind of the expression node(not the input's) </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.QuoteIdentifier(System.String)">
            <summary>
            We use the normal box quotes for SQL server.  We do not deal with ANSI quotes
            i.e. double quotes.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.TransformIntersectOrExcept(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Boolean)">
            <summary>
            This method is used for transforming INTERSECT and EXCEPT for Sql8,
            which does not support INTERSECT and EXCEPT.
            The result is of the following format:
            SELECT DISTINCT a.a1, a.a2, ..., a.an
            FROM x as a
            WHERE (NOT) EXISTS(SELECT 0
            FROM y as b
            WHERE (b.b1 = a.a1 or (b.b1 is null and a.a1 is null))
            AND (b.b2 = a.a2 or (b.b2 is null and a.a2 is null))
            AND ...
            AND (b.bn = a.an or (b.bn is null and a.an is null)))
            where (NOT) is present when translating EXCEPT
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Entity.Core.Common.CommandTrees.DbExpression)">
            <summary>
            Simply calls <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Boolean)"/>
            with addDefaultColumns set to true
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitExpressionEnsureSqlStatement(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Boolean)">
            <summary>
            This is called from <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GenerateSql(System.Data.Entity.Core.Common.CommandTrees.DbQueryCommandTree)"/> and nodes which require a
            select statement as an argument e.g. <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbIsEmptyExpression)"/>,
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbUnionAllExpression)"/>.
            SqlGenerator needs its child to have a proper alias if the child is
            just an extent or a join.
            The normal relational nodes result in complete valid SQL statements.
            For the rest, we need to treat them as there was a dummy
            <code>-- originally {expression}
                -- change that to
                SELECT *
                FROM {expression} as c</code>
            DbLimitExpression needs to start the statement but not add the default columns
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.VisitFilterExpression(System.Data.Entity.Core.Common.CommandTrees.DbExpressionBinding,System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.Boolean)">
            <summary>
            This method is called by <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbFilterExpression)"/> and
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbQuantifierExpression)"/>
            </summary>
            <param name="input"> </param>
            <param name="predicate"> </param>
            <param name="negatePredicate">
            This is passed from <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbQuantifierExpression)"/> in the All(...) case.
            </param>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.WrapNonQueryExtent(System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement,System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment,System.Data.Entity.Core.Common.CommandTrees.DbExpressionKind)">
            <summary>
            If the sql fragment for an input expression is not a SqlSelect statement
            or other acceptable form (e.g. an extent as a SqlBuilder), we need
            to wrap it in a form acceptable in a FROM clause.  These are
            primarily the
            <list type="bullet">
                <item>The set operation expressions - union all, intersect, except</item>
                <item>TVFs, which are conceptually similar to tables</item>
            </list>
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsStoreFunction(System.Data.Entity.Core.Metadata.Edm.EdmFunction)">
            <summary>
            Is this a Store function (ie) does it have the builtinAttribute specified and it is not a canonical function?
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GroupByAggregatesNeedInnerQuery(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbAggregate},System.String)">
            <summary>
            Helper method for the Group By visitor
            Returns true if at least one of the aggregates in the given list
            has an argument that is not a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression"/> and is not
            a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/> over <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/>,
            either potentially capped with a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbCastExpression"/>
            This is really due to the following two limitations of Sql Server:
            <list type="number">
                <item>
                    If an expression being aggregated contains an outer reference, then that outer
                    reference must be the only column referenced in the expression (SQLBUDT #488741)
                </item>
                <item>
                    Sql Server cannot perform an aggregate function on an expression containing
                    an aggregate or a subquery. (SQLBUDT #504600)
                </item>
            </list>
            Potentially, we could furhter optimize this.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GroupByAggregateNeedsInnerQuery(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String)">
            <summary>
            Returns true if the given expression is not a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression"/> or a
            <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/> over  a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/>
            referencing the given inputVarRefName, either
            potentially capped with a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbCastExpression"/>.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GroupByKeysNeedInnerQuery(System.Collections.Generic.IList{System.Data.Entity.Core.Common.CommandTrees.DbExpression},System.String)">
            <summary>
            Helper method for the Group By visitor
            Returns true if at least one of the expressions in the given list
            is not <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/> over <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/>
            referencing the given inputVarRefName potentially capped with a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbCastExpression"/>.
            This is really due to the following limitation: Sql Server requires each GROUP BY expression
            (key) to contain at least one column that is not an outer reference. (SQLBUDT #616523)
            Potentially, we could further optimize this.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GroupByKeyNeedsInnerQuery(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String)">
            <summary>
            Returns true if the given expression is not <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/> over
            <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/> referencing the given inputVarRefName
            potentially capped with a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbCastExpression"/>.
            This is really due to the following limitation: Sql Server requires each GROUP BY expression
            (key) to contain at least one column that is not an outer reference. (SQLBUDT #616523)
            Potentially, we could further optimize this.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.GroupByExpressionNeedsInnerQuery(System.Data.Entity.Core.Common.CommandTrees.DbExpression,System.String,System.Boolean)">
            <summary>
            Helper method for processing Group By keys and aggregates.
            Returns true if the given expression is not a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbConstantExpression"/>
            (and allowConstants is specified)or a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression"/> over
            a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression"/> referencing the given inputVarRefName,
            either potentially capped with a <see cref="T:System.Data.Entity.Core.Common.CommandTrees.DbCastExpression"/>.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.CastReturnTypeToInt32(System.Data.Entity.Core.Common.CommandTrees.DbFunctionExpression)">
            <summary>
            determines if the function requires the return type be enforeced by use of a cast expression
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.CurrentSelectStatement">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.IsParentAJoin">
            <summary>
            The top of the stack
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement">
            <summary>
            A SqlSelectStatement represents a canonical SQL SELECT statement.
            It has fields for the 5 main clauses
            <list type="number">
                <item>SELECT</item>
                <item>FROM</item>
                <item>WHERE</item>
                <item>GROUP BY</item>
                <item>ORDER BY</item>
            </list>
            We do not have HAVING, since the CQT does not have such a node.
            Each of the fields is a SqlBuilder, so we can keep appending SQL strings
            or other fragments to build up the clause.
            We have a IsDistinct property to indicate that we want distict columns.
            This is given out of band, since the input expression to the select clause
            may already have some columns projected out, and we use append-only SqlBuilders.
            The DISTINCT is inserted when we finally write the object into a string.
            Also, we have a Top property, which is non-null if the number of results should
            be limited to certain number. It is given out of band for the same reasons as DISTINCT.
            The FromExtents contains the list of inputs in use for the select statement.
            There is usually just one element in this - Select statements for joins may
            temporarily have more than one.
            If the select statement is created by a Join node, we maintain a list of
            all the extents that have been flattened in the join in AllJoinExtents
            <example>
                in J(j1= J(a,b), c)
                FromExtents has 2 nodes JoinSymbol(name=j1, ...) and Symbol(name=c)
                AllJoinExtents has 3 nodes Symbol(name=a), Symbol(name=b), Symbol(name=c)
            </example>
            If any expression in the non-FROM clause refers to an extent in a higher scope,
            we add that extent to the OuterExtents list.  This list denotes the list
            of extent aliases that may collide with the aliases used in this select statement.
            It is set by <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression)"/>.
            An extent is an outer extent if it is not one of the FromExtents.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            Write out a SQL select statement as a string.
            We have to
            <list type="number">
                <item>
                    Check whether the aliases extents we use in this statement have
                    to be renamed.
                    We first create a list of all the aliases used by the outer extents.
                    For each of the FromExtents( or AllJoinExtents if it is non-null),
                    rename it if it collides with the previous list.
                </item>
                <item>Write each of the clauses (if it exists) as a string</item>
            </list>
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement.OutputColumnsRenamed">
            <summary>
            Whether the columns ouput by this sql statement were renamed from what given in the command tree.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement.OutputColumns">
            <summary>
            A dictionary of output columns, relevant only if output columns are renamed.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.SqlSelectStatement.IsDistinct">
            <summary>
            Do we need to add a DISTINCT at the beginning of the SELECT
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter">
            <summary>
            This extends StringWriter primarily to add the ability to add an indent
            to each line that is written out.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SymbolPair">
            <summary>
            The SymbolPair exists to solve the record flattening problem.
            <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression)"/>
            Consider a property expression D(v, "j3.j2.j1.a.x")
            where v is a VarRef, j1, j2, j3 are joins, a is an extent and x is a columns.
            This has to be translated eventually into {j'}.{x'}
            The source field represents the outermost SqlStatement representing a join
            expression (say j2) - this is always a Join symbol.
            The column field keeps moving from one join symbol to the next, until it
            stops at a non-join symbol.
            This is returned by <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbPropertyExpression)"/>,
            but never makes it into a SqlBuilder.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.SymbolTable">
            <summary>
            The symbol table is quite primitive - it is a stack with a new entry for
            each scope.  Lookups search from the top of the stack to the bottom, until
            an entry is found.
            The symbols are of the following kinds
            <list type="bullet">
                <item>
                    <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.Symbol"/>
                    represents tables (extents/nested selects/unnests)
                </item>
                <item>
                    <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.JoinSymbol"/>
                    represents Join nodes
                </item>
                <item>
                    <see cref="T:System.Data.Entity.SqlServerCompact.SqlGen.Symbol"/>
                    columns.
                </item>
            </list>
            Symbols represent names <see cref="M:System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator.Visit(System.Data.Entity.Core.Common.CommandTrees.DbVariableReferenceExpression)"/> to be resolved,
            or things to be renamed.
            </summary>
        </member>
        <member name="T:System.Data.Entity.SqlServerCompact.SqlGen.TopClause">
            <summary>
            TopClause represents the a TOP expression in a SqlSelectStatement.
            It has a count property, which indicates how many TOP rows should be selected and a
            boolen WithTies property.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.TopClause.#ctor(System.Data.Entity.SqlServerCompact.SqlGen.ISqlFragment,System.Boolean)">
            <summary>
            Creates a TopClause with the given topCount and withTies.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.TopClause.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a TopClause with the given topCount and withTies.
            This function is not called if we have both TOP and SKIP. In that case SqlSelectStatment.WriteOffsetFetch is used.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.TopClause.WriteSql(System.Data.Entity.SqlServerCompact.SqlGen.SqlWriter,System.Data.Entity.SqlServerCompact.SqlGen.SqlGenerator)">
            <summary>
            Write out the TOP part of sql select statement
            It basically writes TOP (X) [WITH TIES].
            The brackets around X are ommited for Sql8.
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.TopClause.WithTies">
            <summary>
            Do we need to add a WITH_TIES to the top statement
            </summary>
        </member>
        <member name="P:System.Data.Entity.SqlServerCompact.SqlGen.TopClause.TopCount">
            <summary>
            How many top rows should be selected.
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.TypeHelpers.HasNulledOutFacetValues(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            It will return true if there there non-boolean facets types that
            are nulled out.
            This function needs to be removed till the
            HasNulledOutFacetValues of TypeUsage class become public
            </summary>
        </member>
        <member name="M:System.Data.Entity.SqlServerCompact.SqlGen.TypeHelpers.PrimitiveTypeName(System.Data.Entity.Core.Metadata.Edm.TypeUsage)">
            <summary>
            Returns the name of Primitive Data Type
            </summary>
        </member>
    </members>
</doc>
