<?xml version="1.0"?>
<doc>
    <assembly>
        <name>StructureMap</name>
    </assembly>
    <members>
        <member name="M:StructureMap.IContext.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.IContext.GetInstance``1">
            <summary>
            Get the object of type T that is valid for this build session.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetInstance``1(System.String)">
            <summary>
            Get the object of type T that is valid for this build session by name.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.RegisterDefault(System.Type,System.Object)">
            <summary>
            Register a default object for the given PluginType that will
            be used throughout the rest of the current object request
            </summary>
            <param name="pluginType"></param>
            <param name="defaultObject"></param>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance``1">
            <summary>
            Same as GetInstance, but can gracefully return null if 
            the Type does not already exist
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.TryGetInstance``1(System.String)">
            <summary>
            Same as GetInstance(name), but can gracefully return null if 
            the Type and name does not already exist
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.All``1">
            <summary>
            Gets all objects in the current object graph that can be cast
            to T that have already been created
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContext.GetAllInstances``1">
            <summary>
            Creates/Resolves every configured instance of PlutinType T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:StructureMap.IContext.BuildStack">
            <summary>
            Gets a reference to the <see cref="P:StructureMap.IContext.BuildStack">BuildStack</see> for this build session
            </summary>
        </member>
        <member name="P:StructureMap.IContext.ParentType">
            <summary>
            The concrete type of the immediate parent object in the object graph
            </summary>
        </member>
        <member name="P:StructureMap.IContext.Root">
            <summary>
            Gets the root "frame" of the object request
            </summary>
        </member>
        <member name="P:StructureMap.IContext.RequestedName">
            <summary>
            The requested instance name of the object graph
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression">
            <summary>
            Expression Builder that has grammars for defining policies at the 
            PluginType level.  This expression is used for registering 
            open generic types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.TheDefaultIsConcreteType(System.Type)">
            <summary>
            Convenience method that sets the default concrete type of the PluginType.  The "concreteType"
            can only accept types that do not have any primitive constructor arguments.
            StructureMap has to know how to construct all of the constructor argument types.
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(StructureMap.Pipeline.Instance)">
            <summary>
            Use this configured Instance as is
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(System.Type)">
            <summary>
            Shorter way to call TheDefaultIsConcreteType
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Use(System.Object)">
            <summary>
            Shortcut to add a value by type
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.AddType(System.Type)">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type.  This will only work if the Concrete Type
            has no primitive constructor or mandatory Setter arguments.
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Add(System.Type)">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type.  This will only work if the Concrete Type
            has no primitive constructor or mandatory Setter arguments.
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Add(System.Object)">
            <summary>
            Configure this type as the supplied value
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.CacheBy(StructureMap.InstanceScope)">
            <summary>
            Sets the object creation of the instances of the PluginType.  For example:  PerRequest,
            Singleton, ThreadLocal, HttpContext, or Hybrid
            </summary>
            <param name="scope"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreation(System.Action{System.Object})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.EnrichWith(System.Func{System.Object,System.Object})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreation(System.Action{System.Object})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.EnrichWith(System.Func{StructureMap.IContext,System.Object,System.Object})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.OnCreation(System.Action{System.Object})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.LifecycleIs(StructureMap.Pipeline.ILifecycle)">
            <summary>
            Registers an IBuildInterceptor for this Plugin Type that executes before
            any object of this PluginType is created.  IBuildInterceptor's can be
            used to create a custom scope
            </summary>
            <param name="lifecycle"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.Singleton">
            <summary>
            Convenience method to mark a PluginFamily as a Singleton
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.HybridHttpOrThreadLocalScoped">
            <summary>
            Convenience method to mark a PluginFamily as a Hybrid lifecycle
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.HttpContextScoped">
            <summary>
            Convenience method to mark a PluginFamily as HttpContext scoped
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.LifecycleIs(StructureMap.InstanceScope)">
            <summary>
            
            </summary>
            <param name="lifecycle"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.AddConcreteType(System.Type)">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type.  You can also chain other declarations after
            this method to add constructor and setter arguments
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericFamilyExpression.AddConcreteType(System.Type,System.String)">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type by a specified name.  You can also chain other declarations after
            this method to add constructor and setter arguments
            </summary>
            <param name="concreteType"></param>
            <param name="instanceName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IExplicitProperty.EqualTo(System.Object)">
            <summary>
            Specify the value of this explicit argument
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With``1(``0)">
            <summary>
            Pass in additional arguments by type T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With(System.Type,System.Object)">
            <summary>
            Pass in additional arguments by type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.With(System.String)">
            <summary>
            Pass in additional arguments by name
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance``1">
            <summary>
            Gets the default instance of type T using the explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance``1(System.String)">
            <summary>
            Gets a named instance of type T using the explicitly configured arguments from teh "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetInstance(System.Type)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ExplicitArgsExpression.GetAllInstances``1">
            <summary>
            Gets all configured instances of type T using explicitly configured arguments
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Graph.Constructor.GetConstructor(System.Type)">
            <summary>
            Returns the System.Reflection.ConstructorInfo for the PluggedType.  Uses either
            the "greediest" constructor with the most arguments or the constructor function
            marked with the [DefaultConstructor]
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Graph.IPluginFamily.DefaultInstanceKey">
            <summary>
            The InstanceKey of the default instance of the PluginFamily
            </summary>
        </member>
        <member name="P:StructureMap.Graph.IPluginFamily.PluginType">
            <summary>
            The CLR Type that defines the "Plugin" interface for the PluginFamily
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Assembly(System.Reflection.Assembly)">
            <summary>
            Add an Assembly to the scanning operation
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Assembly(System.String)">
            <summary>
            Add an Assembly by name to the scanning operation
            </summary>
            <param name="assemblyName"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.TheCallingAssembly">
            <summary>
            Add the currently executing Assembly to the scanning operation
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssemblyContainingType``1">
            <summary>
            Add the Assembly that contains type T to the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssemblyContainingType(System.Type)">
            <summary>
            Add the Assembly that contains type to the scanning operation
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromPath(System.String)">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromPath(System.String,System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the designated path and add any Assembly's found in this folder to the
            scanning operation.  The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
            <param name="path"></param>
            <param name="assemblyFilter"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromApplicationBaseDirectory">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation.
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AssembliesFromApplicationBaseDirectory(System.Predicate{System.Reflection.Assembly})">
            <summary>
            Sweep the application base directory of current app domain and add any Assembly's 
            found to the scanning operation. The assemblyFilter can be used to filter or limit the 
            Assembly's that are picked up.
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.With(StructureMap.Graph.ITypeScanner)">
            <summary>
            Adds an ITypeScanner object to the scanning operation
            </summary>
            <param name="scanner"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.With``1">
            <summary>
            Creates and adds a new ITypeScanner of type T to this scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.LookForRegistries">
            <summary>
            Directs the scanning operation to automatically detect and include any Registry
            classes found in the Assembly's being scanned
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AddAllTypesOf``1">
            <summary>
            Add all concrete types of the Plugin Type as Instances of Plugin Type
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.AddAllTypesOf(System.Type)">
            <summary>
            Add all concrete types of the Plugin Type as Instances of Plugin Type
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.IgnoreStructureMapAttributes">
            <summary>
            Makes this scanning operation ignore all [PluginFamily] and [Pluggable] attributes
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude types that match the Predicate from being scanned
            </summary>
            <param name="exclude"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeNamespace(System.String)">
            <summary>
            Exclude all types in this nameSpace or its children from the scanning operation
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeNamespaceContainingType``1">
            <summary>
            Exclude all types in this nameSpace or its children from the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Include(System.Func{System.Type,System.Boolean})">
            <summary>
            Only include types matching the Predicate in the scanning operation. You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.IncludeNamespace(System.String)">
            <summary>
            Only include types from this nameSpace or its children in the scanning operation.  You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.IncludeNamespaceContainingType``1">
            <summary>
            Only include types from this nameSpace or its children in the scanning operation.  You can 
            use multiple Include() calls in a single scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ExcludeType``1">
            <summary>
            Exclude this specific type from the scanning operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.Convention``1">
            <summary>
            Adds a registration convention to be applied to all the types in this
            logical "scan" operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.With(StructureMap.Graph.IRegistrationConvention)">
            <summary>
            Adds a registration convention to be applied to all the types in this
            logical "scan" operation
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.WithDefaultConventions">
            <summary>
            Adds the DefaultConventionScanner to the scanning operations.  I.e., a concrete
            class named "Something" that implements "ISomething" will be automatically 
            added to PluginType "ISomething"
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.ConnectImplementationsToTypesClosing(System.Type)">
            <summary>
            Scans for PluginType's and Concrete Types that close the given open generic type
            </summary>
            <example>
            
            </example>
            <param name="openGenericType"></param>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.RegisterConcreteTypesAgainstTheFirstInterface">
            <summary>
            Automatically registers all concrete types without primitive arguments
            against its first interface, if any
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IAssemblyScanner.SingleImplementationsOfInterface">
            <summary>
            Directs the scanning to automatically register any type that is the single
            implementation of an interface against that interface.
            The filters apply
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.WithDefaultConventions">
            <summary>
            Adds the DefaultConventionScanner to the scanning operations.  I.e., a concrete
            class named "Something" that implements "ISomething" will be automatically 
            added to PluginType "ISomething"
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.ConnectImplementationsToTypesClosing(System.Type)">
            <summary>
            Scans for PluginType's and Concrete Types that close the given open generic type
            </summary>
            <example>
            
            </example>
            <param name="openGenericType"></param>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.RegisterConcreteTypesAgainstTheFirstInterface">
            <summary>
            Automatically registers all concrete types without primitive arguments
            against its first interface, if any
            </summary>
        </member>
        <member name="M:StructureMap.Graph.AssemblyScanner.SingleImplementationsOfInterface">
            <summary>
            Directs the scanning to automatically register any type that is the single
            implementation of an interface against that interface.
            The filters apply
            </summary>
        </member>
        <member name="T:StructureMap.Interceptors.TypeInterceptor">
            <summary>
            A TypeInterceptor that is only applied if the MatchesType()
            method is true for a given Type
            </summary>
        </member>
        <member name="T:StructureMap.Interceptors.InstanceInterceptor">
            <summary>
            An InstanceInterceptor can be registered on a per-Instance basis
            to act on, or even replace, the object that is created before
            it is passed back to the caller.  This is primarily a hook
            for runtime AOP scenarios.
            </summary>
        </member>
        <member name="M:StructureMap.Interceptors.TypeInterceptor.MatchesType(System.Type)">
            <summary>
            Does this TypeInterceptor apply to the given type?
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Interceptors.MatchedTypeInterceptor.InterceptWith(System.Func{System.Object,System.Object})">
            <summary>
            Specify how objects matching the Type predicate
            will be intercepted
            </summary>
            <param name="interception"></param>
        </member>
        <member name="M:StructureMap.Interceptors.MatchedTypeInterceptor.InterceptWith(System.Func{StructureMap.IContext,System.Object,System.Object})">
            <summary>
            Specify how objects matching the Type predicate
            will be intercepted
            </summary>
            <param name="interception"></param>
        </member>
        <member name="T:StructureMap.Pipeline.ConfiguredInstance">
            <summary>
            An Instance class that builds objects by calling a constructor function on a concrete type
            and filling setter properties.  ConfiguredInstance should only be used for open generic types.
            Favor <see cref="T:StructureMap.Pipeline.SmartInstance`1">SmartInstance{T}</see> for all other usages.
            </summary>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.OnCreation``1(System.Action{``0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <typeparam name="TYPE"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.OnCreation``1(System.Action{StructureMap.IContext,``0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <typeparam name="TYPE"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildArray``1(System.String)">
            <summary>
            Inline definition of a dependency array like IService[] or IHandler[]
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildArray(System.String)">
            <summary>
            Inline definition of a dependency array like IService[] or IHandler[]
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildArray``1">
            <summary>
            Inline definition of a dependency array like IService[] or IHandler[]
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.Child``1">
            <summary>
            Start the definition of a child instance for type CONSTRUCTORARGUMENTTYPE
            </summary>
            <typeparam name="CONSTRUCTORARGUMENTTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.Child(System.Type)">
            <summary>
            Start the definition of a child instance for type CONSTRUCTORARGUMENTTYPE
            </summary>
            <typeparam name="CONSTRUCTORARGUMENTTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.Child(System.String)">
            <summary>
            Inline definition of a constructor or a setter property dependency
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.Child``1(System.String)">
            <summary>
            Starts the definition of a child instance specifying the argument name
            in the case of a constructor function that consumes more than one argument
            of type T
            </summary>
            <typeparam name="CONSTRUCTORARGUMENTTYPE"></typeparam>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.CtorDependency``1(System.String)">
            <summary>
            Inline definition of a constructor dependency
            </summary>
            <typeparam name="CONSTRUCTORARGUMENTTYPE"></typeparam>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.SetterDependency``1(System.String)">
            <summary>
            Inline definition of a setter dependency
            </summary>
            <typeparam name="CONSTRUCTORARGUMENTTYPE"></typeparam>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.WithProperty(System.String)">
            <summary>
            Start the definition of a primitive argument to a constructor argument
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.WithCtorArg(System.String)">
            <summary>
            Configure a primitive constructor argument
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildArrayExpression.Contains(StructureMap.Pipeline.Instance[])">
            <summary>
            Configures an array of Instance's for the array dependency
            </summary>
            <param name="instances"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression">
            <summary>
            Part of the Fluent Interface, represents a nonprimitive argument to a 
            constructure function
            </summary>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression.IsNamedInstance(System.String)">
            <summary>
            Use a previously configured and named instance for the child
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression.IsConcreteType``1">
            <summary>
            Start the definition of a child instance by defining the concrete type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression.IsConcreteType(System.Type)">
            <summary>
            Start the definition of a child instance by defining the concrete type
            </summary>
            <param name="pluggedType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression.Is(StructureMap.Pipeline.Instance)">
            <summary>
            Registers a configured instance to use as the argument to the parent's
            constructor
            </summary>
            <param name="child"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ConfiguredInstance.ChildInstanceExpression.IsAutoFilled">
            <summary>
            Directs StructureMap to fill this dependency with the Default Instance of the 
            constructor or property type
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.ExpressedInstance`1">
            <summary>
            Base class for many of the Instance subclasses to support 
            method chaining in the Registry DSL for common options
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.WithName(System.String)">
            <summary>
            Set the name of this Instance
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.OnCreation``1(System.Action{``0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <typeparam name="TYPE"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <typeparam name="TYPE"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <typeparam name="TYPE"></typeparam>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.ExpressedInstance`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
            Register an <see cref="T:StructureMap.Interceptors.InstanceInterceptor">InstanceInterceptor</see> with this Instance
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.DefaultConstructorAttribute">
            <summary>
            Used to override the constructor of a class to be used by StructureMap to create
            a Pluggable object
            </summary>
        </member>
        <member name="M:StructureMap.DefaultConstructorAttribute.GetConstructor(System.Type)">
            <summary>
            Examines a System.Type object and determines the ConstructorInfo to use in creating
            instances of the Type
            </summary>
            <param name="ExportedType"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.PluggableAttribute">
            <summary>
            Used to implicitly mark a class as a Plugin candidate for StructureMap
            </summary>
        </member>
        <member name="M:StructureMap.PluggableAttribute.MarkedAsPluggable(System.Type)">
            <summary>
            Determines whether a Type object is marked as Pluggable
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.PluggableAttribute.ConcreteKey">
            <summary>
            The ConcreteKey alias of the Type
            </summary>
        </member>
        <member name="T:StructureMap.PluginFamilyAttribute">
            <summary>
            Declares a class, abstract class, or interface to be the target of a PluginFamily in the container
            </summary>
        </member>
        <member name="M:StructureMap.PluginFamilyAttribute.MarkedAsPluginFamily(System.Type)">
            <summary>
            Determines if a Type object is marked as a PluginFamily
            </summary>
            <param name="objectType"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.PluginFamilyAttribute.Scope">
            <summary>
            If set, determines the shared "scope" of the instance -- PerRequest, Singleton, ThreadLocal,
            HttpContext, etc.
            </summary>
        </member>
        <member name="P:StructureMap.PluginFamilyAttribute.DefaultKey">
            <summary>
            InstanceKey of the default instance.  Used to implicitly define the default without
            declaring the instance in StructureMap.config
            </summary>
        </member>
        <member name="P:StructureMap.PluginFamilyAttribute.IsSingleton">
            <summary>
            Declares the target to be built by StructureMap as a Singleton.  One object instance will
            be created for each named instance
            </summary>
        </member>
        <member name="T:StructureMap.Attributes.SetterPropertyAttribute">
            <summary>
            Marks a Property in a Pluggable class as filled by setter injection 
            </summary>
        </member>
        <member name="T:StructureMap.ValidationMethodAttribute">
            <summary>
            Marks a method with no parameters as a method that validates an instance.  StructureMap
            uses this method to validate the configuration file.  If the method does not throw an
            exception, the object is assumed to be valid.
            </summary>
        </member>
        <member name="M:StructureMap.ValidationMethodAttribute.GetValidationMethods(System.Type)">
            <summary>
            Returns an array of any MethodInfo's on a Type that are marked as ValidationMethod
            </summary>
            <param name="objectType">CLR Type to search for validation methods</param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.XmlConstants">
            <summary>
            Constants for the names of Xml nodes and attributes in the StructureMap.config
            file
            </summary>
        </member>
        <member name="F:StructureMap.Configuration.ConfigurationParserBuilder.DefaultConfigurationFilename">
            <summary>
            The name of the default configuration file. The value is always <c>StructurMap.config</c>
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.ConfigurationParserBuilder.GetStructureMapConfigurationPath">
            <summary>
            Returns the absolute path to the StructureMap.config file
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1">
            <summary>
            Expression Builder that has grammars for defining policies at the 
            PluginType level
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddInstances(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Add multiple Instance's to this PluginType
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.ConditionallyUse(System.Action{StructureMap.Pipeline.ConditionalInstance{`0}.ConditionalInstanceExpression})">
            <summary>
            Conditional binding of instances
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.UseSpecial(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Access to all of the uncommon Instance types
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddSpecial(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Access to all of the uncommon Instance types
            </summary>
            <param name="configure"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.TheDefaultIsConcreteType``1">
            <summary>
            Convenience method that sets the default concrete type of the PluginType.  Type T
            can only accept types that do not have any primitive constructor arguments.
            StructureMap has to know how to construct all of the constructor argument types.
            </summary>
            <typeparam name="CONCRETETYPE"></typeparam>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use``1" -->
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(System.Func{StructureMap.IContext,`0})">
            <summary>
            Shorthand to say TheDefault.Is.ConstructedBy(func)
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(System.Func{`0})">
            <summary>
            Shorthand to say TheDefault.Is.ConstructedBy(func)
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Use(`0)">
            <summary>
            Shorthand to say TheDefault.IsThis(@object)
            </summary>
            <param name="object"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.CacheBy(StructureMap.InstanceScope)">
            <summary>
            Sets the object creation of the instances of the PluginType.  For example:  PerRequest,
            Singleton, ThreadLocal, HttpContext, or Hybrid
            </summary>
            <param name="scope"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Singleton">
            <summary>
            Convenience method to mark a PluginFamily as a Singleton
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.HybridHttpOrThreadLocalScoped">
            <summary>
            Convenience method to mark a PluginFamily as a Hybrid lifecycle
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.HttpContextScoped">
            <summary>
            Convenience method to mark a PluginFamily as HttpContext scoped
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreationForAll(System.Action{`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
            Adds an Interceptor to only this PluginType
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{StructureMap.IContext,`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreationForAll(System.Action{StructureMap.IContext,`0})">
            <summary>
            Register an Action to run against any object of this PluginType immediately after
            it is created, but before the new object is passed back to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichWith(StructureMap.Interceptors.EnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{`0})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichAllWith(StructureMap.Interceptors.EnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{`0})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichWith(StructureMap.Interceptors.ContextEnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{StructureMap.IContext,`0})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.EnrichAllWith(StructureMap.Interceptors.ContextEnrichmentHandler{`0})">
            <summary>
            Register a Func to run against any object of this PluginType immediately after it is created,
            but before the new object is passed back to the caller.  Unlike <see cref="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.OnCreation(System.Action{StructureMap.IContext,`0})">OnCreation()</see>,
            EnrichWith() gives the the ability to return a different object.  Use this method for runtime AOP
            scenarios or to return a decorator.
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddConcreteType``1">
            <summary>
            Shortcut method to add an additional Instance to this Plugin Type
            as just a Concrete Type.  This will only work if the Concrete Type
            has no primitive constructor or mandatory Setter arguments.
            </summary>
            <typeparam name="PLUGGEDTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.LifecycleIs(StructureMap.Pipeline.ILifecycle)">
            <summary>
            Registers an ILifecycle for this Plugin Type that executes before
            any object of this PluginType is created.  ILifecycle's can be
            used to create a custom scope
            </summary>
            <param name="lifecycle"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AddInstancesFrom(StructureMap.MementoSource)">
            <summary>
            Largely deprecated and unnecessary with the ability to add Xml configuration files
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.AlwaysUnique">
            <summary>
            Forces StructureMap to always use a unique instance to
            stop the "BuildSession" caching
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Add(`0)">
            <summary>
            Adds the object to to the PLUGINTYPE
            </summary>
            <param name="object"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.Add(System.Func{StructureMap.IContext,`0})">
            <summary>
            Add an Instance to this type created by a Lambda
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Configuration.DSL.Expressions.CreatePluginFamilyExpression`1.TheDefault">
            <summary>
            Define the Default Instance for this PluginType
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.ProfileExpression">
            <summary>
            Expression class to help define a runtime Profile
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.For``1">
            <summary>
            Starts the definition of the default instance for the containing Profile.  This is
            still valid, but Type() is recommended
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.Type``1">
            <summary>
            Designate or define the Instance for a type within
            this Profile
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.For(System.Type)">
            <summary>
            Use statement to define the Profile defaults for a Generic type
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression">
            <summary>
            Expression Builder inside of a Profile creation for
            open generic types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.UseConcreteType(System.Type)">
            <summary>
            Use this concreteType for the Instance of this Profile for the PluginType
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.Use(System.Type)">
            <summary>
            Use this concreteType for the Instance of this Profile for the PluginType
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.Use(StructureMap.Pipeline.Instance)">
            <summary>
            Use this Instance for the Profile Instance of this Plugin Type
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.UseNamedInstance(System.String)">
            <summary>
            Use the named Instance as the Profile Instance for this PluginType
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.Use(System.String)">
            <summary>
            Use the named Instance as the Profile Instance for this PluginType
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.GenericDefaultExpression.Use(System.Func{StructureMap.IContext,System.Object})">
            <summary>
            For this type and profile, build the object with this Lambda
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1">
            <summary>
            Expression Builder within defining a Profile
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.UseNamedInstance(System.String)">
            <summary>
            Use a named, preconfigured instance as the default instance for this profile 
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use(System.String)">
            <summary>
            Use a named, preconfigured instance as the default instance for this profile 
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use(StructureMap.Pipeline.Instance)">
            <summary>
            Define the default instance of the PluginType for the containing Profile
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use(System.Func{`0})">
            <summary>
            For this Profile, use an Instance with this Func
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use(System.Func{StructureMap.IContext,`0})">
            <summary>
            For this Profile, use an Instance with this Func
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use(`0)">
            <summary>
            For this Profile, use this object
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.UseSpecial(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`0}})">
            <summary>
            Access to the uncommon types of Instance
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.UseConcreteType``1">
            <summary>
            For this Profile, use the Concrete Type
            </summary>
            <typeparam name="CONCRETETYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.ProfileExpression.InstanceDefaultExpression`1.Use``1">
            <summary>
            For this profile, use this concrete type
            </summary>
            <typeparam name="CONCRETETYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Registry">
            <summary>
            A Registry class provides methods and grammars for configuring a Container or ObjectFactory.
            Using a Registry subclass is the recommended way of configuring a StructureMap Container.
            </summary>
            <example>
            public class MyRegistry : Registry
            {
                public MyRegistry()
                {
                    ForRequestedType(typeof(IService)).TheDefaultIsConcreteType(typeof(Service));
                }
            }
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.AddType(System.Type)">
            <summary>
            Add the pluggedType as an instance to any configured pluginType where pluggedType
            could be assigned to the pluginType
            </summary>
            <param name="pluggedType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IncludeRegistry``1">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IncludeRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.BuildInstancesOf``1">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForRequestedType(System.Type)">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  This method is specifically
            meant for registering open generic types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForConcreteType``1">
            <summary>
            This method is a shortcut for specifying the default constructor and 
            setter arguments for a ConcreteType.  ForConcreteType is shorthand for:
            ForRequestedType[T]().Use[T].**************
            when the PluginType and ConcreteType are the same Type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForRequestedType``1">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.ForSingletonOf``1">
            <summary>
            Convenience method.  Equivalent of ForRequestedType[PluginType]().AsSingletons()
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Build">
            <summary>
            Uses the configuration expressions of this Registry to create a PluginGraph
            object that could be used to initialize a Container.  This method is 
            mostly for internal usage, but might be helpful for diagnostics
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.InstanceOf``1">
            <summary>
            Adds an additional, non-Default Instance to the PluginType T.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.InstanceOf(System.Type)">
            <summary>
            Adds an additional, non-Default Instance to the designated pluginType
            This method is mostly meant for open generic types
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Profile(System.String)">
            <summary>
            Expression Builder to define the defaults for a named Profile.  Each call
            to CreateProfile is additive.
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Profile(System.String,System.Action{StructureMap.Configuration.DSL.Expressions.ProfileExpression})">
            <summary>
            An alternative way to use CreateProfile that uses ProfileExpression
            as a Nested Closure.  This usage will result in cleaner code for 
            multiple declarations
            </summary>
            <param name="profileName"></param>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.RegisterInterceptor(StructureMap.Interceptors.TypeInterceptor)">
            <summary>
            Registers a new TypeInterceptor object with the Container
            </summary>
            <param name="interceptor"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.IfTypeMatches(System.Predicate{System.Type})">
            <summary>
            Allows you to define a TypeInterceptor inline with Lambdas or anonymous delegates
            </summary>
            <param name="match"></param>
            <returns></returns>
            <example>
            IfTypeMatches( ... ).InterceptWith( o => new ObjectWrapper(o) );
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Scan(System.Action{StructureMap.Graph.IAssemblyScanner})">
            <summary>
            Designates a policy for scanning assemblies to auto
            register types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.FillAllPropertiesOfType``1">
            <summary>
            Directs StructureMap to always inject dependencies into any and all public Setter properties
            of the type PLUGINTYPE.
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.SetAllProperties(System.Action{StructureMap.Configuration.DSL.SetterConvention})">
            <summary>
            Creates automatic "policies" for which public setters are considered mandatory
            properties by StructureMap that will be "setter injected" as part of the 
            construction process.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.SelectConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Use to programmatically select the constructor function of a concrete
            class.  Applies globally to all Containers in a single AppDomain.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Forward``2">
            <summary>
            All requests For the "TO" types will be filled by fetching the "FROM"
            type and casting it to "TO"
            GetInstance(typeof(TO)) basically becomes (TO)GetInstance(typeof(FROM))
            </summary>
            <typeparam name="FROM"></typeparam>
            <typeparam name="TO"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Register``1(``0)">
            <summary>
            Syntactic Sugar for saying ForRequestedType().TheDefault.IsThis( @object )
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="object"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Register``1(StructureMap.Pipeline.Instance)">
            <summary>
            Syntactic Sugar for saying ForRequestedType().TheDefault.IsThis( instance )
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="instance"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.IRegistry.For``1" -->
        <member name="M:StructureMap.Configuration.DSL.IRegistry.For(System.Type)">
            <summary>
            Shorthand for ForRequestedType(pluginType)
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.IRegistry.Redirect``2" -->
        <member name="M:StructureMap.Configuration.DSL.IRegistry.Configure(System.Action{StructureMap.Graph.PluginGraph})">
            <summary>
            Advanced Usage Only!  Skips the Registry and goes right to the inner
            Semantic Model of StructureMap.  Use with care
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType.  Mostly useful
            for conventions
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name.  Mostly
            useful for conventions
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.AddType(System.Type)">
            <summary>
            Add the pluggedType as an instance to any configured pluginType where pluggedType. 
            Mostly useful for conventions
            </summary>
            <param name="pluggedType"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IncludeRegistry``1">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IncludeRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports the configuration from another registry into this registry.
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.BuildInstancesOf``1">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForRequestedType(System.Type)">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  This method is specifically
            meant for registering open generic types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForConcreteType``1">
            <summary>
            This method is a shortcut for specifying the default constructor and 
            setter arguments for a ConcreteType.  ForConcreteType is shorthand for:
            For[T]().Use[T].**************
            when the PluginType and ConcreteType are the same Type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForRequestedType``1">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.ForSingletonOf``1">
            <summary>
            Convenience method.  Equivalent of ForRequestedType[PluginType]().Singletons()
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Build">
            <summary>
            Uses the configuration expressions of this Registry to create a PluginGraph
            object that could be used to initialize a Container.  This method is 
            mostly for internal usage, but might be helpful for diagnostics
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.InstanceOf``1">
            <summary>
            Adds an additional, non-Default Instance to the PluginType T.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.InstanceOf(System.Type)">
            <summary>
            Adds an additional, non-Default Instance to the designated pluginType
            This method is mostly meant for open generic types
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Profile(System.String)">
            <summary>
            Expression Builder to define the defaults for a named Profile.  Each call
            to CreateProfile is additive.
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Profile(System.String,System.Action{StructureMap.Configuration.DSL.Expressions.ProfileExpression})">
            <summary>
            An alternative way to use CreateProfile that uses ProfileExpression
            as a Nested Closure.  This usage will result in cleaner code for 
            multiple declarations
            </summary>
            <param name="profileName"></param>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.RegisterInterceptor(StructureMap.Interceptors.TypeInterceptor)">
            <summary>
            Registers a new TypeInterceptor object with the Container
            </summary>
            <param name="interceptor"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.IfTypeMatches(System.Predicate{System.Type})">
            <summary>
            Allows you to define a TypeInterceptor inline with Lambdas or anonymous delegates
            </summary>
            <param name="match"></param>
            <returns></returns>
            <example>
            IfTypeMatches( ... ).InterceptWith( o => new ObjectWrapper(o) );
            </example>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Scan(System.Action{StructureMap.Graph.IAssemblyScanner})">
            <summary>
            Designates a policy for scanning assemblies to auto
            register types
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.FillAllPropertiesOfType``1">
            <summary>
            Directs StructureMap to always inject dependencies into any and all public Setter properties
            of the type PLUGINTYPE.
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.SetAllProperties(System.Action{StructureMap.Configuration.DSL.SetterConvention})">
            <summary>
            Creates automatic "policies" for which public setters are considered mandatory
            properties by StructureMap that will be "setter injected" as part of the 
            construction process.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.SelectConstructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Use to programmatically select the constructor function of a concrete
            class.  Applies globally to all Containers in a single AppDomain.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Forward``2">
            <summary>
            All requests For the "TO" types will be filled by fetching the "FROM"
            type and casting it to "TO"
            GetInstance(typeof(TO)) basically becomes (TO)GetInstance(typeof(FROM))
            </summary>
            <typeparam name="FROM"></typeparam>
            <typeparam name="TO"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Register``1(``0)">
            <summary>
            Syntactic Sugar for saying ForRequestedType().TheDefault.IsThis( @object )
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="object"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.Register``1(StructureMap.Pipeline.Instance)">
            <summary>
            Syntactic Sugar for saying ForRequestedType().TheDefault.IsThis( instance )
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.For``1">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  BuildInstancesOf()
            and ForRequestedType() are synonyms
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Registry.For(System.Type)">
            <summary>
            Expression Builder used to define policies for a PluginType including
            Scoping, the Default Instance, and interception.  This method is specifically
            meant for registering open generic types
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Configuration.DSL.Registry.Redirect``2" -->
        <member name="M:StructureMap.Configuration.DSL.Registry.Configure(System.Action{StructureMap.Graph.PluginGraph})">
            <summary>
            Advanced Usage Only!  Skips the Registry and goes right to the inner
            Semantic Model of StructureMap.  Use with care
            </summary>
            <param name="configure"></param>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Registry.BuildWithExpression`1">
            <summary>
            Define the constructor and setter arguments for the default T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:StructureMap.Exceptions.InstancePropertyValueException">
            <summary>
            Thrown by IProperty classes when an invalid value is applied to 
            a property of an InstanceGraph
            </summary>
        </member>
        <member name="T:StructureMap.StructureMapException">
            <summary>
            Main exception for StructureMap.  Use the ErrorCode to aid in troubleshooting
            StructureMap problems
            </summary>
        </member>
        <member name="T:StructureMap.Graph.Plugin">
            <summary>
            Represents a concrete class that can be built by StructureMap as an instance of the parent 
            PluginFamilys PluginType. The properties of a Plugin are the CLR Type of the concrete class, 
            and the human-friendly concrete key that StructureMap will use to identify the Type.
            </summary>
        </member>
        <member name="P:StructureMap.Graph.Plugin.ConcreteKey">
            <summary>
            The ConcreteKey that identifies the Plugin within a PluginFamily
            </summary>
        </member>
        <member name="P:StructureMap.Graph.Plugin.PluggedType">
            <summary>
            The concrete CLR Type represented by the Plugin
            </summary>
        </member>
        <member name="P:StructureMap.Graph.Plugin.Setters">
            <summary>
            Property's that will be filled by setter injection
            </summary>
        </member>
        <member name="T:StructureMap.Graph.PluginFamily">
            <summary>
            Conceptually speaking, a PluginFamily object represents a point of abstraction or variability in 
            the system.  A PluginFamily defines a CLR Type that StructureMap can build, and all of the possible
            Plugins implementing the CLR Type.
            </summary>
        </member>
        <member name="P:StructureMap.Graph.PluginFamily.PluginType">
            <summary>
            The CLR Type that defines the "Plugin" interface for the PluginFamily
            </summary>
        </member>
        <member name="P:StructureMap.Graph.PluginFamily.DefaultInstanceKey">
            <summary>
            The InstanceKey of the default instance of the PluginFamily
            </summary>
        </member>
        <member name="T:StructureMap.Graph.PluginFamilyCollection">
            <summary>
            Custom collection class for PluginFamily's
            </summary>
        </member>
        <member name="M:StructureMap.Graph.IPluginGraph.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Graph.IPluginGraph.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Graph.IPluginGraph.AddType(System.Type)">
            <summary>
            Add the pluggedType as an instance to any configured pluginType where pluggedType
            could be assigned to the pluginType
            </summary>
            <param name="pluggedType"></param>
        </member>
        <member name="T:StructureMap.Graph.PluginGraph">
            <summary>
            Models the runtime configuration of a StructureMap Container
            </summary>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.Seal">
            <summary>
            Closes the PluginGraph for adding or removing members.  Runs all the <see cref="T:StructureMap.Graph.AssemblyScanner"> AssemblyScanner's</see>
            and attempts to attach concrete types to the proper plugin types.  Calculates the Profile defaults. 
            </summary>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.AddType(System.Type,System.Type)">
            <summary>
            Adds the concreteType as an Instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.AddType(System.Type,System.Type,System.String)">
            <summary>
            Adds the concreteType as an Instance of the pluginType with a name
            </summary>
            <param name="pluginType"></param>
            <param name="concreteType"></param>
            <param name="name"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.AddType(System.Type)">
            <summary>
            Add the pluggedType as an instance to any configured pluginType where pluggedType
            could be assigned to the pluginType
            </summary>
            <param name="pluggedType"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.Scan(System.Action{StructureMap.Graph.AssemblyScanner})">
            <summary>
            Adds an AssemblyScanner to the PluginGraph.  Used for Testing.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:StructureMap.Graph.PluginGraph.Configure(System.Action{StructureMap.Configuration.DSL.Registry})">
            <summary>
            Add configuration to a PluginGraph with the Registry DSL
            </summary>
            <param name="action"></param>
        </member>
        <member name="P:StructureMap.Graph.PluginGraph.IsSealed">
            <summary>
            Designates whether a PluginGraph has been "Sealed."
            </summary>
        </member>
        <member name="T:StructureMap.Graph.SetterProperty">
            <summary>
            Represents a PropertyInfo of a Plugin.PluggedType that is filled by Setter Injection
            </summary>
        </member>
        <member name="T:StructureMap.Graph.SetterPropertyCollection">
            <summary>
            Custom collection class for SetterProperty objects
            </summary>
        </member>
        <member name="T:StructureMap.Graph.TypePath">
            <summary>
            Designates a CLR type that is loaded by name.
            </summary>
        </member>
        <member name="T:StructureMap.IInstanceFactory">
            <summary>
            Interface for a "Factory" pattern class that creates object instances of the PluginType
            </summary>
        </member>
        <member name="T:StructureMap.IContainer">
            <summary>
            The main "container" object that implements the Service Locator pattern
            </summary>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type using the supplied Instance.  Mostly used internally
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1">
            <summary>
            Creates or finds the default instance of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type T using the supplied Instance.  Mostly used internally
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances``1">
            <summary>
            Creates or resolves all registered instances of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance``1">
            <summary>
            Creates or finds the default instance of type T. Returns the default value of T if it is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.TryGetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of type T. Returns the default value of T if the named instance is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
            Used to add additional configuration to a Container *after* the initialization.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.IContainer.Inject``1(``0)">
            <summary>
            Injects the given object into a Container as the default for the designated
            PLUGINTYPE.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.IContainer.Inject(System.Type,System.Object)">
            <summary>
            Injects the given object into a Container as the default for the designated
            pluginType.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <param name="pluginType"></param>
            <param name="object"></param>
        </member>
        <member name="M:StructureMap.IContainer.SetDefaultsToProfile(System.String)">
            <summary>
            Sets the default instance for all PluginType's to the designated Profile.
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:StructureMap.IContainer.WhatDoIHave">
            <summary>
            Returns a report detailing the complete configuration of all PluginTypes and Instances
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.AssertConfigurationIsValid">
            <summary>
            Use with caution!  Does a full environment test of the configuration of this container.  Will try to create every configured
            instance and afterward calls any methods marked with the [ValidationMethod] attribute
            </summary>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances``1(StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets all configured instances of type T using explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetAllInstances(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of type T using the explicitly configured arguments from the "args"
            </summary>
            <param name="type"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With``1(``0)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With(System.String)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency or primitive argument
            with the designated name should be the next value.
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="pluginType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.EjectAllInstancesOf``1">
            <summary>
            Removes all configured instances of type T from the Container.  Use with caution!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.IContainer.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.IContainer.ForGenericType(System.Type)">
            <summary>
            Convenience method to request an object using an Open Generic
            Type and its parameter Types
            </summary>
            <param name="templateType"></param>
            <returns></returns>
            <example>
            IFlattener flattener1 = container.ForGenericType(typeof (IFlattener&lt;&gt;))
                .WithParameters(typeof (Address)).GetInstanceAs&lt;IFlattener&gt;();
            </example>
        </member>
        <member name="M:StructureMap.IContainer.GetInstance``1(StructureMap.Pipeline.ExplicitArguments,System.String)">
            <summary>
            Gets the named instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="args"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.With(System.Type,System.Object)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <param name="pluginType"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.IContainer.ForObject(System.Object)" -->
        <member name="M:StructureMap.IContainer.GetNestedContainer">
            <summary>
            Starts a "Nested" Container for atomic, isolated access
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IContainer.GetNestedContainer(System.String)">
            <summary>
            Starts a new "Nested" Container for atomic, isolated service location.  Opens 
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.IContainer.Model">
            <summary>
            Provides queryable access to the configured PluginType's and Instances of this Container
            </summary>
        </member>
        <member name="T:StructureMap.InstanceFactory">
            <summary>
            Default implementation of IInstanceFactory
            </summary>
        </member>
        <member name="M:StructureMap.InstanceFactory.#ctor(StructureMap.Graph.PluginFamily)">
            <summary>
            Constructor to use when troubleshooting possible configuration issues.
            </summary>
            <param name="family"></param>
        </member>
        <member name="M:StructureMap.Container.#ctor(StructureMap.Graph.PluginGraph)">
            <summary>
            Constructor to create an Container
            </summary>
            <param name="pluginGraph">PluginGraph containing the instance and type definitions 
            for the Container</param>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type T using the supplied Instance.  Mostly used internally
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1(StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets the default instance of the pluginType using the explicitly configured arguments from the "args"
            </summary>
            <param name="pluginType"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances(System.Type,StructureMap.Pipeline.ExplicitArguments)">
            <summary>
            Gets all configured instances of type T using explicitly configured arguments from the "args"
            </summary>
            <param name="type"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance``1">
            <summary>
            Creates or finds the default instance of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances``1">
            <summary>
            Creates or resolves all registered instances of type T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.SetDefaultsToProfile(System.String)">
            <summary>
            Sets the default instance for all PluginType's to the designated Profile.
            </summary>
            <param name="profile"></param>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance``1">
            <summary>
            Creates or finds the default instance of type T. Returns the default value of T if it is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.Container.TryGetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of type T. Returns the default value of T if the named instance is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetInstance(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type using the supplied Instance.  Mostly used internally
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
            Used to add additional configuration to a Container *after* the initialization.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="M:StructureMap.Container.WhatDoIHave">
            <summary>
            Returns a report detailing the complete configuration of all PluginTypes and Instances
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.With``1(``0)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.With(System.Type,System.Object)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <param name="pluginType"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.With(System.String)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency or primitive argument
            with the designated name should be the next value.
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.AssertConfigurationIsValid">
            <summary>
            Use with caution!  Does a full environment test of the configuration of this container.  Will try to create every configured
            instance and afterward calls any methods marked with the [ValidationMethod] attribute
            </summary>
        </member>
        <member name="M:StructureMap.Container.EjectAllInstancesOf``1">
            <summary>
            Removes all configured instances of type T from the Container.  Use with caution!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Container.ForGenericType(System.Type)">
            <summary>
            Convenience method to request an object using an Open Generic
            Type and its parameter Types
            </summary>
            <param name="templateType"></param>
            <returns></returns>
            <example>
            IFlattener flattener1 = container.ForGenericType(typeof (IFlattener&lt;&gt;))
                .WithParameters(typeof (Address)).GetInstanceAs&lt;IFlattener&gt;();
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.Container.ForObject(System.Object)" -->
        <member name="M:StructureMap.Container.GetNestedContainer">
            <summary>
            Starts a "Nested" Container for atomic, isolated access
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.GetNestedContainer(System.String)">
            <summary>
            Starts a new "Nested" Container for atomic, isolated service location.  Opens 
            </summary>
            <param name="profileName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Container.Inject``1(``0)">
            <summary>
            Injects the given object into a Container as the default for the designated
            PLUGINTYPE.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Container.Inject(System.Type,System.Object)">
            <summary>
            Injects the given object into a Container as the default for the designated
            pluginType.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <param name="pluginType"></param>
            <param name="object"></param>
        </member>
        <member name="M:StructureMap.Container.Inject(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
            Sets the default instance for the PluginType
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
        </member>
        <member name="P:StructureMap.Container.Model">
            <summary>
            Provides queryable access to the configured PluginType's and Instances of this Container
            </summary>
        </member>
        <member name="T:StructureMap.InstanceMemento">
            <summary>
            GoF Memento representing an Object Instance
            </summary>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetProperty(System.String)">
            <summary>
            Retrieves the named property value as a string
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.getPropertyValue(System.String)">
            <summary>
            Template method for implementation specific retrieval of the named property
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetChildMemento(System.String)">
            <summary>
            Returns the named child InstanceMemento
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.getChild(System.String)">
            <summary>
            Template method for implementation specific retrieval of the named property
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.GetChildrenArray(System.String)">
            <summary>
            This method is made public for testing.  It is not necessary for normal usage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.InstanceMemento.Substitute(StructureMap.InstanceMemento)">
            <summary>
            Used to create a templated InstanceMemento
            </summary>
            <param name="memento"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.InstanceMemento.ConcreteKey">
            <summary>
            The named type of the object instance represented by the InstanceMemento.  Translates to a concrete
            type
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.InstanceKey">
            <summary>
            The named key of the object instance represented by the InstanceMemento
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.TemplateName">
            <summary>
            Gets the referred template name
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.InstanceMemento.IsReference">
            <summary>
            Template pattern property specifying whether the InstanceMemento is simply a reference
            to another named instance.  Useful for child objects.
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.ReferenceKey">
            <summary>
            Template pattern property specifying the instance key that the InstanceMemento refers to
            </summary>
        </member>
        <member name="P:StructureMap.InstanceMemento.IsDefault">
            <summary>
            Is the InstanceMemento a reference to the default instance of the plugin type?
            </summary>
        </member>
        <member name="T:StructureMap.Interceptors.PluginTypeInterceptor">
            <summary>
            A TypeInterceptor that always applies to all Instances of a given Plugin Type
            </summary>
        </member>
        <member name="T:StructureMap.MementoSource">
            <summary>
            Abstract class that is the supertype of all storage and retrieval mechanisms of
            InstanceMemento instances
            </summary>
        </member>
        <member name="M:StructureMap.MementoSource.GetMemento(System.String)">
            <summary>
            Retrieves the named InstanceMemento
            </summary>
            <param name="instanceKey">The instanceKey of the requested InstanceMemento</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MementoSource.GetAllMementos">
            <summary>
            Retrieves an array of all InstanceMemento's stored by this MementoSource
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MementoSource.containsKey(System.String)">
            <summary>
            Template pattern method.  Determines if the MementoSource contains a definition for the
            requested instanceKey.
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MementoSource.retrieveMemento(System.String)">
            <summary>
            Template pattern method.  Retrieves an InstanceMemento for the instanceKey
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.MementoSource.SourceType">
            <summary>
            The type of MementoSource
            </summary>
        </member>
        <member name="P:StructureMap.MementoSource.Description">
            <summary>
            String description of the MementoSource.  Used in the StructureMap-Client UI.
            </summary>
        </member>
        <member name="T:StructureMap.MemoryInstanceMemento">
            <summary>
            An in-memory implementation of InstanceMemento.  
            </summary>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.CreateReferencedInstanceMemento(System.String)">
            <summary>
            Creates an instance of MemoryInstanceMemento that represents a reference to another
            instance.
            </summary>
            <param name="referenceKey">The referenced instance key to another instance</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.CreateDefaultInstanceMemento">
            <summary>
            Creates a MemoryInstanceMemento that represents a reference to the default instance
            of a plugin type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.#ctor(System.String,System.String)">
            <summary>
            Constructs a MemoryInstanceMemento without properties
            </summary>
            <param name="concreteKey">The concrete key of the plugin type</param>
            <param name="instanceKey">The identifying instance key</param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.#ctor(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Constructs a MemoryInstanceMemento with properties
            </summary>
            <param name="concreteKey">The concrete key of the plugin type</param>
            <param name="instanceKey">The identifying instance key</param>
            <param name="properties">NameValueCollection of instance properties</param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.SetProperty(System.String,System.String)">
            <summary>
            Sets the value of the named property
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.RemoveProperty(System.String)">
            <summary>
            Deletes a named property from the DefaultInstanceMemento
            </summary>
            <param name="Name"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.AddChild(System.String,StructureMap.InstanceMemento)">
            <summary>
            Links a child InstanceMemento as a named property
            </summary>
            <param name="name"></param>
            <param name="Memento"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.AddChildArray(System.String,StructureMap.InstanceMemento[])">
            <summary>
            Links an array of InstanceMemento's to a named array property
            </summary>
            <param name="name"></param>
            <param name="childMementos"></param>
        </member>
        <member name="M:StructureMap.MemoryInstanceMemento.GetChildrenArray(System.String)">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.innerConcreteKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.innerInstanceKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.IsReference">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="P:StructureMap.MemoryInstanceMemento.ReferenceKey">
            <summary>
            See <cref>InstanceMemento</cref>
            </summary>
        </member>
        <member name="T:StructureMap.ObjectFactory">
            <summary>
            The main static Facade for the StructureMap container
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.Reset">
            <summary>
            Restarts ObjectFactory and blows away all Singleton's and cached instances.  Use with caution.
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.ReleaseAndDisposeAllHttpScopedObjects">
            <summary>
            Remove and dispose all objects scoped by HttpContext.  Call this method at the *end* of an Http request to clean up resources
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.Inject(System.Type,System.Object)">
            <summary>
            Injects the given object into a Container as the default for the designated
            pluginType.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <param name="pluginType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.ObjectFactory.Inject``1(``0)">
            <summary>
            Injects the given object into a Container as the default for the designated
            PLUGINTYPE.  Mostly used for temporarily setting up return values of the Container
            to introduce mocks or stubs during automated testing scenarios
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.ObjectFactory.WhatDoIHave">
            <summary>
            Returns a report detailing the complete configuration of all PluginTypes and Instances
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.AssertConfigurationIsValid">
            <summary>
            Use with caution!  Does a full environment test of the configuration of this container.  Will try to create every configured
            instance and afterward calls any methods marked with the [ValidationMethod] attribute
            </summary>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance``1">
            <summary>
            Creates or finds the default instance of type T
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance(System.Type,StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type using the supplied Instance.  Mostly used internally
            </summary>
            <param name="targetType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetInstance``1(StructureMap.Pipeline.Instance)">
            <summary>
            Creates a new instance of the requested type T using the supplied Instance.  Mostly used internally
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetNamedInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetNamedInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of T
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetAllInstances(System.Type)">
            <summary>
            Creates or resolves all registered instances of the pluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.GetAllInstances``1">
            <summary>
            Creates or resolves all registered instances of type T
            </summary>
            <typeparam name="PLUGINTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.With``1(``0)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.With(System.String)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency or primitive argument
            with the designated name should be the next value.
            </summary>
            <param name="argName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.With(System.Type,System.Object)">
            <summary>
            Starts a request for an instance or instances with explicitly configured arguments.  Specifies that any dependency
            of type T should be "arg"
            </summary>
            <param name="pluginType"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.EjectAllInstancesOf``1">
            <summary>
            Removes all configured instances of type T from the Container.  Use with caution!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.ObjectFactory.TryGetInstance(System.Type,System.String)">
            <summary>
            Creates or finds the named instance of the pluginType. Returns null if the named instance is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.TryGetInstance(System.Type)">
            <summary>
            Creates or finds the default instance of the pluginType. Returns null if the pluginType is not known to the container.
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.TryGetInstance``1">
            <summary>
            Creates or finds the default instance of type T. Returns the default value of T if it is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.TryGetInstance``1(System.String)">
            <summary>
            Creates or finds the named instance of type T. Returns the default value of T if the named instance is not known to the container.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.ObjectFactory.BuildUp(System.Object)">
            <summary>
            The "BuildUp" method takes in an already constructed object
            and uses Setter Injection to push in configured dependencies
            of that object
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:StructureMap.ObjectFactory.ForGenericType(System.Type)">
            <summary>
            Convenience method to request an object using an Open Generic
            Type and its parameter Types
            </summary>
            <param name="templateType"></param>
            <returns></returns>
            <example>
            IFlattener flattener1 = container.ForGenericType(typeof (IFlattener&lt;&gt;))
                .WithParameters(typeof (Address)).GetInstanceAs&lt;IFlattener&gt;();
            </example>
        </member>
        <!-- Badly formed XML comment ignored for member "M:StructureMap.ObjectFactory.ForObject(System.Object)" -->
        <member name="M:StructureMap.ObjectFactory.Configure(System.Action{StructureMap.ConfigurationExpression})">
            <summary>
            Used to add additional configuration to a Container *after* the initialization.
            </summary>
            <param name="configure"></param>
        </member>
        <member name="P:StructureMap.ObjectFactory.Model">
            <summary>
            Provides queryable access to the configured PluginType's and Instances of the inner Container
            </summary>
        </member>
        <member name="P:StructureMap.ObjectFactory.Profile">
            <summary>
            Sets the default instance for all PluginType's to the designated Profile.
            </summary>
        </member>
        <member name="T:StructureMap.PluginGraphBuilder">
            <summary>
            Reads configuration XML documents and builds the structures necessary to initialize
            the Container/IInstanceFactory/InstanceBuilder/ObjectInstanceActivator objects
            </summary>
        </member>
        <member name="M:StructureMap.PluginGraphBuilder.Build">
            <summary>
            Reads the configuration information and returns the PluginGraph definition of
            plugin families and plugin's
            </summary>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Source.BasicXmlMementoSource">
            <summary>
            Generic implementation of an XmlMementoSource
            </summary>
        </member>
        <member name="T:StructureMap.Source.XmlMementoSource">
            <summary>
            Base class for all MementoSource classes that store InstanceMemento's as 
            node-normalized Xml
            </summary>
        </member>
        <member name="T:StructureMap.Source.DirectoryXmlMementoSource">
            <summary>
            Implementation of MementoSource that stores and retrieves an XmlInstanceMemento per file in a named directory.  
            DirectoryXmlMementoSource is meant to simplify complicated object graph configurations by isolating each instance to a separate
            editable file.
            </summary>
        </member>
        <member name="M:StructureMap.Source.DirectoryXmlMementoSource.#ctor(System.String,System.String,StructureMap.Source.XmlMementoStyle)">
            <summary>
            Stores an Xml InstanceMemento per file in a directory
            </summary>
            <param name="directory">A ";" delimited list of directories to look for mementos.  DirectoryXmlMementoSource 
            will use the FIRST directory it finds</param>
            <param name="extension">The file extension of the InstanceMemento files without a dot.  Typically "xml"</param>
            <param name="mementoStyle">NodeNormalized or AttributeNormalized</param>
        </member>
        <member name="M:StructureMap.Source.EmbeddedFolderXmlMementoSource.#ctor(StructureMap.Source.XmlMementoStyle,System.String,System.String,System.String)">
            <summary>
            Implementation of MementoSource that stores and retrieves an XmlInstanceMemento per Embedded Resource file 
            in a named namespace.  EmbeddedFolderXmlMementoSource is meant to simplify complicated object graph configurations 
            by isolating each instance to a separate
            editable file.
            </summary>
            <param name="style">NodeNormalized or AttributeNormalized</param>
            <param name="assemblyName">The name of the Assembly with the embedded resources</param>
            <param name="folderPath">The root namespace of all of the mementos.</param>
            <param name="extension">The file extension of the memento files - "xml"</param>
        </member>
        <member name="T:StructureMap.Source.MemoryMementoSource">
            <summary>
            An in-memory MementoSource
            </summary>
        </member>
        <member name="M:StructureMap.Source.SingleEmbeddedXmlMementoSource.#ctor(System.String,StructureMap.Source.XmlMementoStyle,System.String,System.String)">
            <summary>
            Retrieves Xml InstanceMemento's from an xml file stored as an embedded resource in an assembly.
            </summary>
            <param name="nodeName">Designates the nodes that are memento nodes</param>
            <param name="style">NodeNormalized or AttributeNormalized</param>
            <param name="assemblyName">The name of the Assembly the file is embedded into</param>
            <param name="path">The path to the embedded resource within the file</param>
        </member>
        <member name="M:StructureMap.Source.TemplatedMementoSource.#ctor(StructureMap.MementoSource,StructureMap.MementoSource)">
            <summary>
            Default Constructor
            </summary>
            <param name="innerSource">MementoSource that contains the Memento Templates</param>
            <param name="templateSource">MementoSource that contains instances consisting of Template valuee</param>
        </member>
        <member name="T:StructureMap.Source.XmlAttributeFileMementoSource">
            <summary>
            Stores Attribute-normalized InstanceMemento's in an external file
            </summary>
        </member>
        <member name="T:StructureMap.Source.XmlFileMementoSource">
            <summary>
            Implementation of XmlMementoSource that reads InstanceMemento's from an external file.
            Useful to break the StructureMap.config file into smaller pieces.
            </summary>
        </member>
        <member name="M:StructureMap.Source.XmlFileMementoSource.#ctor(System.String,System.String,System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="FilePath">Path to the xml file that contains the instance configuration</param>
            <param name="XPath">XPath expression to the parent node that contains the InstanceMemento nodes.
            If empty, it defaults to the top node</param>
            <param name="NodeName">The name of the nodes that are InstanceMemento nodes.  Useful to store 
            different types of instances in the same file</param>
        </member>
        <member name="T:StructureMap.Source.XmlAttributeInstanceMemento">
            <summary>
            An implementation of InstanceMemento that stores properties as Xml attributes
            Limited functionality
            </summary>
        </member>
        <member name="T:StructureMap.Source.XmlNodeInstanceMemento">
            <summary>
            Implementation of InstanceMemento that stores information in a node-normalized
            Xml format.
            </summary>
        </member>
        <member name="M:StructureMap.CloseGenericTypeExpression.StructureMap#OpenGenericTypeSpecificationExpression#As``1">
            <summary>
            specify what type you'd like the service returned as
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.CloseGenericTypeExpression.GetClosedTypeOf(System.Type)">
            <summary>
            Specify the open generic type that should have a single generic parameter
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.ConfigurationExpression">
            <summary>
            Used as the argument in the Container.Configure() method to describe
            configuration directives and specify the sources of configuration for
            a Container
            </summary>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddRegistry``1">
            <summary>
            Creates and adds a Registry object of type T.  
            </summary>
            <typeparam name="T">The Registry Type</typeparam>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports all the configuration from a Registry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddConfigurationFromXmlFile(System.String)">
            <summary>
            Imports configuration from an Xml file.  The fileName
            must point to an Xml file with valid StructureMap
            configuration
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:StructureMap.ConfigurationExpression.AddConfigurationFromNode(System.Xml.XmlNode)">
            <summary>
            Imports configuration directly from an XmlNode.  This
            method was intended for scenarios like Xml being embedded
            into an assembly.  The node must be a 'StructureMap' node
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:StructureMap.ConfigurationExpression.IncludeConfigurationFromConfigFile">
            <summary>
            If true, directs StructureMap to look for configuration in the App.config.
            The default value is false.
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.IsExpression`1">
            <summary>
            Expression Builder to define an Instance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IsExpression`1.IsThis(StructureMap.Pipeline.Instance)">
            <summary>
            Register a previously built Instance.  This provides a "catch all"
            method to attach custom Instance objects.  Synonym for Instance()
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IsExpression`1.IsThis(`0)">
            <summary>
            Inject this object directly.  Synonym to Object()
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Configuration.DSL.Expressions.IsExpression`1.Is">
            <summary>
            Gives you full access to all the different ways to specify an "Instance"
            </summary>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.GenericIsExpression">
            <summary>
            An Expression Builder to define Instances of a PluginType.
            This is mostly used for configuring open generic types
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericIsExpression.Is(System.Type)">
            <summary>
            Shortcut to register a Concrete Type as an instance.  This method supports
            method chaining to allow you to add constructor and setter arguments for 
            the concrete type
            </summary>
            <param name="concreteType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.GenericIsExpression.TheInstanceNamed(System.String)">
            <summary>
            Shortcut to simply use the Instance with the given name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1">
            <summary>
            An Expression Builder that is used throughout the Registry DSL to
            add and define Instances
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Instance(StructureMap.Pipeline.Instance)">
            <summary>
            Register a previously built Instance.  This provides a "catch all"
            method to attach custom Instance objects.  Synonym for IsThis()
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Object(`0)">
            <summary>
            Inject this object directly.  Synonym to IsThis()
            </summary>
            <param name="theObject"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.OfConcreteType``1">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Starts
            the definition of a <see cref="T:StructureMap.Pipeline.SmartInstance`1">SmartInstance</see>
            </summary>
            <typeparam name="PLUGGEDTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Type``1">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Starts
            the definition of a <see cref="T:StructureMap.Pipeline.SmartInstance`1">SmartInstance</see>
            </summary>
            <typeparam name="PLUGGEDTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.OfConcreteType(System.Type)">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Use this
            method for open generic types, and favor the generic version of OfConcreteType
            for all other types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Type(System.Type)">
            <summary>
            Build the Instance with the constructor function and setter arguments.  Use this
            method for open generic types, and favor the generic version of OfConcreteType
            for all other types
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.ConstructedBy(System.Func{`0})">
            <summary>
            Create an Instance that builds an object by calling a Lambda or
            an anonymous delegate with no arguments
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.ConstructedBy(System.Func{StructureMap.IContext,`0})">
            <summary>
            Create an Instance that builds an object by calling a Lambda or
            an anonymous delegate with the <see cref="T:StructureMap.IContext">IContext</see> representing
            the current object graph.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.TheInstanceNamed(System.String)">
            <summary>
            Use the Instance of this PluginType with the specified name.  This is
            generally only used while configuring child dependencies within a deep
            object graph
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.TheDefault">
            <summary>
            Use the default Instance of this PluginType.  This is
            generally only used while configuring child dependencies within a deep
            object graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.PrototypeOf(`0)">
            <summary>
            Creates an Instance that stores this object of type T,
            and returns a cloned copy of the template.  
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.SerializedCopyOf(`0)">
            <summary>
            Caches template as a serialized byte stream.  Uses deserialization
            to create copies when the Instance is built.
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.LoadControlFrom(System.String)">
            <summary>
            Creates an Instance that will load an ASCX user control from the url
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Configuration.DSL.Expressions.IInstanceExpression`1.Conditional(System.Action{StructureMap.Pipeline.ConditionalInstance{`0}.ConditionalInstanceExpression})">
            <summary>
            Creates an Instance according to conditional rules
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Configuration.DSL.SetterConvention">
            <summary>
            Used as an expression builder to specify setter injection policies
            </summary>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.OfType``1">
            <summary>
            Directs StructureMap to treat all public setters of type T as
            mandatory properties
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.TypeMatches(System.Predicate{System.Type})">
            <summary>
            Directs StructureMap to tread all public setters with
            a PropertyType that matches the predicate as a
            mandatory setter
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.Matching(System.Predicate{System.Reflection.PropertyInfo})">
            <summary>
            Directs StructureMap to treat all public setters that match the 
            rule as mandatory properties
            </summary>
            <param name="rule"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.WithAnyTypeFromNamespace(System.String)">
            <summary>
            Directs StructureMap to treat all public setters with a property
            type in the specified namespace as mandatory properties
            </summary>
            <param name="nameSpace"></param>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.WithAnyTypeFromNamespaceContainingType``1">
            <summary>
            Directs StructureMap to treat all public setters with a property
            type in the specified namespace as mandatory properties
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:StructureMap.Configuration.DSL.SetterConvention.NameMatches(System.Predicate{System.String})">
            <summary>
            Directs StructureMap to treat all public setters where to property name
            matches the specified rule as a mandatory property
            </summary>
            <param name="rule"></param>
        </member>
        <member name="T:StructureMap.Construction.InstanceBuilder">
            <summary>
            Base class for creating an object instance from an InstanceMemento.  SubClasses are
            emitted for each concrete Plugin with constructor parameters.
            </summary>
        </member>
        <member name="T:StructureMap.Graph.ConfigurableRegistrationConvention">
            <summary>
            Allows built-in registration conventions to be configurable through the assembly scanning DSL
            </summary>
            <remarks>
            Intended for StructureMap internal use only. 
            Custom registration convention instances can be directly configured 
            before being passed to IAssemblyScanner.With(IRegistrationConvention).
            </remarks>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.EjectAndRemove(StructureMap.Query.InstanceRef)">
            <summary>
            Ejects any instances of this instance from the current container
            and permanently removes the instance from the container configuration
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:StructureMap.Query.IPluginTypeConfiguration.EjectAndRemoveAll">
            <summary>
            Eject all instances of this PluginType from the current container,
            but leaves the lifecycle behavior
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.IPluginTypeConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Query.EmptyConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.EmptyConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="M:StructureMap.Query.GenericFamilyConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.GenericFamilyConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="T:StructureMap.Query.IModel">
            <summary>
            Models the state of a Container or ObjectFactory.  Can be used to query for the 
            existence of types registered with StructureMap
            </summary>
        </member>
        <member name="M:StructureMap.Query.IModel.HasDefaultImplementationFor(System.Type)">
            <summary>
            Can StructureMap fulfill a request to ObjectFactory.GetInstance(pluginType) from the 
            current configuration.  This does not include concrete classes that could be auto-configured
            upon demand
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasDefaultImplementationFor``1">
            <summary>
            Can StructureMap fulfill a request to ObjectFactory.GetInstance&lt;T&gt;() from the 
            current configuration.  This does not include concrete classes that could be auto-configured
            upon demand
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.InstancesOf(System.Type)">
            <summary>
            Queryable access to all of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for a given PluginType
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.InstancesOf``1">
            <summary>
            Queryable access to all of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for a given PluginType
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasImplementationsFor(System.Type)">
            <summary>
            Does the current container have existing configuration for the "pluginType"
            </summary>
            <param name="pluginType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.HasImplementationsFor``1">
            <summary>
            Does the current container have existing configuration for the type T
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.DefaultTypeFor``1">
            <summary>
            Find the concrete type for the default Instance of T.
            In other words, when I call Container.GetInstance(Type),
            what do I get?  May be indeterminate
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.DefaultTypeFor(System.Type)">
            <summary>
            Find the concrete type for the default Instance of pluginType.
            In other words, when I call Container.GetInstance(Type),
            what do I get?  May be indeterminate
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.For``1">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.For(System.Type)">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemoveTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects, configuration, and Plugin Types matching this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemovePluginTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects and configuration for any Plugin Type that matches this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.EjectAndRemove(System.Type)">
            <summary>
            Eject all objects and Instance configuration for this PluginType
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Query.IModel.GetAllPossible``1">
            <summary>
            Get each and every configured instance that could possibly
            be cast to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.IModel.PluginTypes">
            <summary>
            Access to all the <seealso cref="T:StructureMap.Query.IPluginTypeConfiguration">Plugin Type</seealso> registrations 
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.UniquePerRequestLifecycle">
            <summary>
            Makes sure that every request for this object returns a unique object
            </summary>
        </member>
        <member name="M:StructureMap.Query.InstanceFactoryTypeConfiguration.HasImplementations">
            <summary>
            Simply query to see if there are any implementations registered
            </summary>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Query.InstanceFactoryTypeConfiguration.Default">
            <summary>
            The "instance" that will be used when Container.GetInstance(PluginType) is called.
            See <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see> for more information
            </summary>
        </member>
        <member name="P:StructureMap.Query.InstanceFactoryTypeConfiguration.Lifecycle">
            <summary>
            The build "policy" for this PluginType.  Used by the WhatDoIHave() diagnostics methods
            </summary>
        </member>
        <member name="P:StructureMap.Query.InstanceFactoryTypeConfiguration.Instances">
            <summary>
            All of the <see cref="T:StructureMap.Query.InstanceRef">InstanceRef</see>'s registered
            for this PluginType
            </summary>
        </member>
        <member name="P:StructureMap.Query.InstanceRef.ConcreteType">
            <summary>
            The actual concrete type of this Instance.  Not every type of IInstance
            can determine the ConcreteType
            </summary>
        </member>
        <member name="M:StructureMap.Query.PluginTypeConfigurationExtensions.EjectAndRemove(StructureMap.Query.IPluginTypeConfiguration,System.String)">
            <summary>
            Ejects and removes all objects and the configuration for the named instance from the 
            container
            </summary>
            <param name="configuration"></param>
            <param name="instanceName"></param>
        </member>
        <member name="M:StructureMap.Query.PluginTypeConfigurationExtensions.EjectAndRemove(StructureMap.Query.IPluginTypeConfiguration,System.Func{StructureMap.Query.InstanceRef,System.Boolean})">
            <summary>
            Ejects and removes all objects and configuration for the instances that match the filter
            </summary>
            <param name="configuration"></param>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.TypeRules.TypeExtensions.CanBeCastTo(System.Type,System.Type)">
            <summary>
            Determines if the pluggedType can be upcast to the pluginType
            </summary>
            <param name="pluginType"></param>
            <param name="pluggedType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.TypeRules.TypeExtensions.IsExplicitlyMarkedAsPlugin(System.Type,System.Type)">
            <summary>
            Determines if the PluggedType is a valid Plugin into the
            PluginType
            </summary>
            <param name="pluginType"></param>
            <param name="pluggedType"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddConfigurationFromXmlFile(System.String)">
            <summary>
            Imports configuration from an Xml file.  The fileName
            must point to an Xml file with valid StructureMap
            configuration
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddConfigurationFromNode(System.Xml.XmlNode)">
            <summary>
            Imports configuration directly from an XmlNode.  This
            method was intended for scenarios like Xml being embedded
            into an assembly.  The node must be a 'StructureMap' node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddRegistry``1">
            <summary>
            Creates and adds a Registry object of type T.  
            </summary>
            <typeparam name="T">The Registry Type</typeparam>
        </member>
        <member name="M:StructureMap.IInitializationExpression.AddRegistry(StructureMap.Configuration.DSL.Registry)">
            <summary>
            Imports all the configuration from a Registry object
            </summary>
            <param name="registry"></param>
        </member>
        <member name="P:StructureMap.IInitializationExpression.UseDefaultStructureMapConfigFile">
            <summary>
            If true, makes the existence of the StructureMap.config mandatory.
            The default is false.
            </summary>
        </member>
        <member name="P:StructureMap.IInitializationExpression.IgnoreStructureMapConfig">
            <summary>
            If true, the StructureMap.config file will be ignored even if it exists.
            The default is false.
            </summary>
        </member>
        <member name="P:StructureMap.IInitializationExpression.PullConfigurationFromAppConfig">
            <summary>
            If true, directs StructureMap to look for configuration in the App.config.
            The default value is false.
            </summary>
        </member>
        <member name="P:StructureMap.IInitializationExpression.DefaultProfileName">
            <summary>
            Designate the Default Profile.  This will be applied as soon as the 
            Container is initialized.
            </summary>
        </member>
        <member name="M:StructureMap.Query.Model.For``1">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.Model.For(System.Type)">
            <summary>
            Retrieves the configuration for the given type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemoveTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects, configuration, and Plugin Types matching this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemovePluginTypes(System.Func{System.Type,System.Boolean})">
            <summary>
            Eject all objects and configuration for any Plugin Type that matches this filter
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:StructureMap.Query.Model.EjectAndRemove(System.Type)">
            <summary>
            Eject all objects and Instance configuration for this PluginType
            </summary>
            <param name="pluginType"></param>
        </member>
        <member name="M:StructureMap.Query.Model.GetAllPossible``1">
            <summary>
            Get each and every configured instance that could possibly
            be cast to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.RequestedType">
            <summary>
            The requested PluginType of the Instance being create
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.Name">
            <summary>
            The Name of the Instance being created
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.IBuildFrame.ConcreteType">
            <summary>
            The actual ConcreteType being created.  This will not always
            be available
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.BuildFrame">
            <summary>
            Models the current place in an object graph during the construction of
            an instance.  Provides contextual information that can be used
            to alter the desired construction of child objects
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.RequestedType">
            <summary>
            The requested PluginType of the Instance being create
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.Name">
            <summary>
            The Name of the Instance being created
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildFrame.ConcreteType">
            <summary>
            The actual ConcreteType being created.  This will not always
            be available
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.BuildStack">
            <summary>
            Provides metadata about the object graph being constructed.  More or less a stack trace of the GetInstance() pipeline
            that can be used for "contextual" object construction
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Root">
            <summary>
            The top level of the object graph.  Describes the original requested instance
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Current">
            <summary>
            The current BuildFrame
            </summary>
        </member>
        <member name="P:StructureMap.Pipeline.BuildStack.Parent">
            <summary>
            The immediate parent BuildFrame
            </summary>
        </member>
        <member name="T:StructureMap.Pipeline.PropertyExpression`1">
            <summary>
            Defines the value of a primitive argument to a constructur argument
            </summary>
        </member>
        <member name="M:StructureMap.Pipeline.PropertyExpression`1.EqualTo(System.Object)">
            <summary>
            Sets the value of the constructor argument
            </summary>
            <param name="propertyValue"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.PropertyExpression`1.EqualToAppSetting(System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.PropertyExpression`1.EqualToAppSetting(System.String,System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings when it exists. Otherwise uses the provided default value.
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <param name="defaultValue">The value to use if an entry for <paramref name="appSettingKey"/> does not exist in the appSettings section.</param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.SmartInstance`1">
            <summary>
            Instance that builds objects with by calling constructor functions and using setter properties
            </summary>
            <typeparam name="T">The concrete type constructed by SmartInstance</typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.WithName(System.String)">
            <summary>
            Sets the name of this Instance
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Named(System.String)">
            <summary>
            Sets the name of this Instance
            </summary>
            <param name="instanceKey"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.OnCreation(System.Action{`0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.OnCreation(System.Action{StructureMap.IContext,`0})">
            <summary>
            Register an Action to perform on the object created by this Instance
            before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith(StructureMap.Interceptors.EnrichmentHandler{`0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith``1(StructureMap.Interceptors.EnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith(StructureMap.Interceptors.ContextEnrichmentHandler{`0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnrichWith``1(StructureMap.Interceptors.ContextEnrichmentHandler{``0})">
            <summary>
            Register a Func to potentially enrich or substitute for the object
            created by this Instance before it is returned to the caller
            </summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.InterceptWith(StructureMap.Interceptors.InstanceInterceptor)">
            <summary>
            Register an <see cref="T:StructureMap.Interceptors.InstanceInterceptor">InstanceInterceptor</see> with this Instance
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.WithCtorArg(System.String)">
            <summary>
            Define a primitive constructor argument
            </summary>
            <param name="argumentName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.SetProperty(System.Action{`0})">
            <summary>
            Set simple setter properties
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.WithProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Define a primitive setter property by specifying the property name with
            an expression
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.WithProperty(System.String)">
            <summary>
            Define a primitive setter property by specifying the property name
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.CtorDependency``1">
            <summary>
            Inline definition of a constructor dependency.  Select the constructor argument by type.  Do not
            use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="CTORTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Ctor``1">
            <summary>
            Inline definition of a constructor dependency.  Select the constructor argument by type.  Do not
            use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="CTORTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.CtorDependency``1(System.String)">
            <summary>
            Inline definition of a constructor dependency.  Select the constructor argument by type and constructor name.  
            Use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="CTORTYPE"></typeparam>
            <param name="constructorArg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Ctor``1(System.String)">
            <summary>
            Inline definition of a constructor dependency.  Select the constructor argument by type and constructor name.  
            Use this method if there is more than one constructor arguments of the same type
            </summary>
            <typeparam name="CTORTYPE"></typeparam>
            <param name="constructorArg"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.SetterDependency``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Inline definition of a setter dependency.  The property name is specified with an Expression
            </summary>
            <typeparam name="SETTERTYPE"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Setter``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Inline definition of a setter dependency.  The property name is specified with an Expression
            </summary>
            <typeparam name="SETTERTYPE"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.SetterDependency``1">
            <summary>
            Inline definition of a setter dependency.  Only use this method if there
            is only a single property of the SETTERTYPE
            </summary>
            <typeparam name="SETTERTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.Setter``1">
            <summary>
            Inline definition of a setter dependency.  Only use this method if there
            is only a single property of the SETTERTYPE
            </summary>
            <typeparam name="SETTERTYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.TheArrayOf``1">
            <summary>
            Inline definition of a dependency on an Array of the CHILD type.  I.e. CHILD[].
            This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="CHILD"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.TheArrayOf``1(System.String)">
            <summary>
            Inline definition of a dependency on an Array of the CHILD type and the specified setter property or constructor argument name.  I.e. CHILD[].
            This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="CHILD"></typeparam>
            <param name="ctorOrPropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnumerableOf``1">
            <summary>
            Inline definition of a dependency on an Array of the CHILD type.  I.e. CHILD[].
            This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="CHILD"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.EnumerableOf``1(System.String)">
            <summary>
            Inline definition of a dependency on an Array of the CHILD type and the specified setter property or constructor argument name.  I.e. CHILD[].
            This method can be used for either constructor arguments or setter properties
            </summary>
            <typeparam name="CHILD"></typeparam>
            <param name="ctorOrPropertyName"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.SmartInstance`1.ArrayDefinitionExpression`1">
            <summary>
            Expression Builder to help define multiple Instances for an Array dependency
            </summary>
            <typeparam name="ARRAY"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.ArrayDefinitionExpression`1.Contains(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`1}})">
            <summary>
            Nested Closure that allows you to add an unlimited number of child Instances
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.ArrayDefinitionExpression`1.Contains(StructureMap.Pipeline.Instance[])">
            <summary>
            Specify an array of Instance objects directly for an Array dependency
            </summary>
            <param name="children"></param>
            <returns></returns>
        </member>
        <member name="T:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1">
            <summary>
            Expression Builder that helps to define child dependencies inline 
            </summary>
            <typeparam name="CHILD"></typeparam>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.EqualToAppSetting(System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.EqualToAppSetting(System.String,System.String)">
            <summary>
            Sets the value of the constructor argument to the key/value in the 
            AppSettings when it exists. Otherwise uses the provided default value.
            </summary>
            <param name="appSettingKey">The key in appSettings for the value to use.</param>
            <param name="defaultValue">The value to use if an entry for <paramref name="appSettingKey"/> does not exist in the appSettings section.</param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.Is(System.Action{StructureMap.Configuration.DSL.Expressions.IInstanceExpression{`1}})">
            <summary>
            Nested Closure to define a child dependency inline
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.Is(StructureMap.Pipeline.Instance)">
            <summary>
            Shortcut to set an inline dependency to an Instance
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.Is(`1)">
            <summary>
            Shortcut to set an inline dependency to a designated object
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.EqualTo(`1)">
            <summary>
            Shortcut to set an inline dependency to a designated object
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.IsTheDefault">
            <summary>
            Set an Inline dependency to the Default Instance of the Property type
            Used mostly to force an optional Setter property to be filled by
            StructureMap
            </summary>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.Is``1">
            <summary>
            Shortcut method to define a child dependency inline
            </summary>
            <typeparam name="CONCRETETYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="M:StructureMap.Pipeline.SmartInstance`1.DependencyExpression`1.Is``1(System.Action{StructureMap.Pipeline.SmartInstance{``0}})">
            <summary>
            Shortcut method to define a child dependency inline and configure
            the child dependency
            </summary>
            <typeparam name="CONCRETETYPE"></typeparam>
            <returns></returns>
        </member>
        <member name="T:StructureMap.ExpressionVisitorBase">
            <summary>
            Provides virtual methods that can be used by subclasses to parse an expression tree.
            </summary>
            <remarks>
            This class actually already exists in the System.Core assembly...as an internal class.
            I can only speculate as to why it is internal, but it is obviously much too dangerous
            for anyone outside of Microsoft to be using...
            </remarks>
        </member>
    </members>
</doc>
